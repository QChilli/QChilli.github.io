<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>测试 | Blog</title><meta name="author" content="Chilli"><meta name="copyright" content="Chilli"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="STM32单片机基础篇1. 开发板简介1. 开发板实物图2. 核心板原理图3. 扩展板原理图4. STM32最小系统STM32单片机能工作的最小外围电路就叫 最小系统 。最小系统通常包括： STM32芯片、电源、时钟、下载调试和复位 5 部分组成。1. STM32芯片选用的是 STM32F103ZET6 这款芯片。2. 电源123a. 采用3.3V电源供电。我们电路采用了两路供电">
<meta property="og:type" content="article">
<meta property="og:title" content="测试">
<meta property="og:url" content="https://qchilli.github.io/2024/09/01/%E6%9D%82%E8%B0%88/sb/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:description" content="STM32单片机基础篇1. 开发板简介1. 开发板实物图2. 核心板原理图3. 扩展板原理图4. STM32最小系统STM32单片机能工作的最小外围电路就叫 最小系统 。最小系统通常包括： STM32芯片、电源、时钟、下载调试和复位 5 部分组成。1. STM32芯片选用的是 STM32F103ZET6 这款芯片。2. 电源123a. 采用3.3V电源供电。我们电路采用了两路供电">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://source.fomal.cc/img/default_cover_3.webp">
<meta property="article:published_time" content="2024-08-31T20:05:00.000Z">
<meta property="article:modified_time" content="2024-09-03T11:26:02.935Z">
<meta property="article:author" content="Chilli">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://source.fomal.cc/img/default_cover_3.webp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://qchilli.github.io/2024/09/01/%E6%9D%82%E8%B0%88/sb/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Chilli","link":"链接: ","source":"来源: Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-right"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '测试',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2024-09-03 19:26:02'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/custom.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://www.fomal.cc/static/css/runtime.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://source.fomal.cc/img/default_cover_3.webp')"><nav id="nav"><span id="blog-info"><a href="/" title="Blog"><span class="site-name">Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">测试</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-08-31T20:05:00.000Z" title="发表于 2024-09-01 04:05:00">2024-09-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-03T11:26:02.935Z" title="更新于 2024-09-03 19:26:02">2024-09-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%9D%82%E8%B0%88/">杂谈</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">21.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>85分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="测试"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="STM32单片机基础篇"><a href="#STM32单片机基础篇" class="headerlink" title="STM32单片机基础篇"></a>STM32单片机基础篇</h1><h2 id="1-开发板简介"><a href="#1-开发板简介" class="headerlink" title="1. 开发板简介"></a>1. 开发板简介</h2><h2 id="1-开发板实物图"><a href="#1-开发板实物图" class="headerlink" title="1. 开发板实物图"></a>1. 开发板实物图</h2><h2 id="2-核心板原理图"><a href="#2-核心板原理图" class="headerlink" title="2. 核心板原理图"></a>2. 核心板原理图</h2><h2 id="3-扩展板原理图"><a href="#3-扩展板原理图" class="headerlink" title="3. 扩展板原理图"></a>3. 扩展板原理图</h2><h2 id="4-STM32最小系统"><a href="#4-STM32最小系统" class="headerlink" title="4. STM32最小系统"></a>4. STM32最小系统</h2><h6 id="STM32单片机能工作的最小外围电路就叫-最小系统-。"><a href="#STM32单片机能工作的最小外围电路就叫-最小系统-。" class="headerlink" title="STM32单片机能工作的最小外围电路就叫 最小系统 。"></a>STM32单片机能工作的最小外围电路就叫 最小系统 。</h6><h6 id="最小系统通常包括：-STM32芯片、电源、时钟、下载调试和复位-5-部分组成。"><a href="#最小系统通常包括：-STM32芯片、电源、时钟、下载调试和复位-5-部分组成。" class="headerlink" title="最小系统通常包括： STM32芯片、电源、时钟、下载调试和复位 5 部分组成。"></a>最小系统通常包括： STM32芯片、电源、时钟、下载调试和复位 5 部分组成。</h6><h6 id="1-STM32芯片"><a href="#1-STM32芯片" class="headerlink" title="1. STM32芯片"></a>1. STM32芯片</h6><h6 id="选用的是-STM32F103ZET6-这款芯片。"><a href="#选用的是-STM32F103ZET6-这款芯片。" class="headerlink" title="选用的是 STM32F103ZET6 这款芯片。"></a>选用的是 STM32F103ZET6 这款芯片。</h6><h6 id="2-电源"><a href="#2-电源" class="headerlink" title="2. 电源"></a>2. 电源</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a. 采用3.3V电源供电。我们电路采用了两路供电。</span><br><span class="line">b. 一路是USB的TypeC供电，TypeC提供的是5V，使用芯片AMS1117把5V转成 3 .3V。</span><br><span class="line">c. 另一路是STLink下载器直接提供3.3V供电（下载器内部已经把5V转成了3.3V）。</span><br></pre></td></tr></table></figure>
<ul>
<li><p>MCU电源</p>
</li>
<li><p>USB供电转3.3v</p>
</li>
<li><p>MCU调试口</p>
</li>
</ul>
<h6 id="不用额外再接串口模块。"><a href="#不用额外再接串口模块。" class="headerlink" title="不用额外再接串口模块。"></a>不用额外再接串口模块。</h6><h6 id="3-时钟"><a href="#3-时钟" class="headerlink" title="3. 时钟"></a>3. 时钟</h6><h6 id="SMT32提供了两路外部时钟：-外部高速时钟和外部低速时钟-。"><a href="#SMT32提供了两路外部时钟：-外部高速时钟和外部低速时钟-。" class="headerlink" title="SMT32提供了两路外部时钟： 外部高速时钟和外部低速时钟 。"></a>SMT32提供了两路外部时钟： 外部高速时钟和外部低速时钟 。</h6><h6 id="4-复位"><a href="#4-复位" class="headerlink" title="4. 复位"></a>4. 复位</h6><h6 id="5-下载调试"><a href="#5-下载调试" class="headerlink" title="5. 下载调试"></a>5. 下载调试</h6><h2 id="2-点亮LED灯案例（寄存器）"><a href="#2-点亮LED灯案例（寄存器）" class="headerlink" title="2. 点亮LED灯案例（寄存器）"></a>2. 点亮LED灯案例（寄存器）</h2><h6 id="我们首先使用基于寄存器开发方式点亮第一个LED灯。"><a href="#我们首先使用基于寄存器开发方式点亮第一个LED灯。" class="headerlink" title="我们首先使用基于寄存器开发方式点亮第一个LED灯。"></a>我们首先使用基于寄存器开发方式点亮第一个LED灯。</h6><h6 id="在代码期间会涉及到一些寄存器知识，先不要深究，后面再详细介绍。现在要做的就是点亮第一"><a href="#在代码期间会涉及到一些寄存器知识，先不要深究，后面再详细介绍。现在要做的就是点亮第一" class="headerlink" title="在代码期间会涉及到一些寄存器知识，先不要深究，后面再详细介绍。现在要做的就是点亮第一"></a>在代码期间会涉及到一些寄存器知识，先不要深究，后面再详细介绍。现在要做的就是点亮第一</h6><h6 id="个LED灯。"><a href="#个LED灯。" class="headerlink" title="个LED灯。"></a>个LED灯。</h6><h3 id="1-需求描述"><a href="#1-需求描述" class="headerlink" title="1. 需求描述"></a>1. 需求描述</h3><h6 id="快速体验STM32开发：点亮LED1。"><a href="#快速体验STM32开发：点亮LED1。" class="headerlink" title="快速体验STM32开发：点亮LED1。"></a>快速体验STM32开发：点亮LED1。</h6><h3 id="2-硬件电路设计"><a href="#2-硬件电路设计" class="headerlink" title="2. 硬件电路设计"></a>2. 硬件电路设计</h3><h6 id="LED1-LED3是普通LED灯，LED4为电源指示灯。"><a href="#LED1-LED3是普通LED灯，LED4为电源指示灯。" class="headerlink" title="LED1-LED3是普通LED灯，LED4为电源指示灯。"></a>LED1-LED3是普通LED灯，LED4为电源指示灯。</h6><h6 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a. LED1连接的是端口PA0</span><br><span class="line">b. 只要让PA0引脚输出低电平就可以点亮LED1。</span><br></pre></td></tr></table></figure>
<h3 id="3-创建项目工程"><a href="#3-创建项目工程" class="headerlink" title="3. 创建项目工程"></a>3. 创建项目工程</h3><h4 id="1-创建工程准备"><a href="#1-创建工程准备" class="headerlink" title="1. 创建工程准备"></a>1. 创建工程准备</h4><h6 id="1-创建需要的目录"><a href="#1-创建需要的目录" class="headerlink" title="1. 创建需要的目录"></a>1. 创建需要的目录</h6><p>在磁盘上创建一个目录atguigu，然后再在atguigu目录下创建我们的第一个工程目录<br>led_register。</p>
<h6 id="2-准备启动文件"><a href="#2-准备启动文件" class="headerlink" title="2. 准备启动文件"></a>2. 准备启动文件</h6><h6 id="STM32程序需要启动文件，我们需要提前准备好。先去ST官网下载官方提供的外设标准库，里面"><a href="#STM32程序需要启动文件，我们需要提前准备好。先去ST官网下载官方提供的外设标准库，里面" class="headerlink" title="STM32程序需要启动文件，我们需要提前准备好。先去ST官网下载官方提供的外设标准库，里面"></a>STM32程序需要启动文件，我们需要提前准备好。先去ST官网下载官方提供的外设标准库，里面</h6><p>有提供标准的启动文件，我们从里面copy一份出来。</p>
<p>标准外设库下载地址： <strong><a target="_blank" rel="noopener" href="https://www.st.com/zh/embedded-software/stm32-standard-">https://www.st.com/zh/embedded-software/stm32-standard-</a><br>peripheral-libraries/products.html</strong> </p>
<p>下载完成之后解压，后面我们需要从里面copy文件出来。</p>
<ol>
<li>创建目录放入启动文件和其他核心文件<br>为了方便管理，我们把启动文件放入专⻔目录中。在刚才创建的工程目录中创建一个目录：Start<br>（名字没有强制要求，随意，但是最好不要有中文）。</li>
</ol>
<p>去到我们刚才下载的标准外设库目录，找到我们需要的启动文件和其他核心文件copy到S tart目<br>录。</p>
<h6 id="启动文件选择标准："><a href="#启动文件选择标准：" class="headerlink" title="启动文件选择标准："></a>启动文件选择标准：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Copy完之后：</span><br></pre></td></tr></table></figure>
<h6 id="4-创建工程"><a href="#4-创建工程" class="headerlink" title="4. 创建工程"></a>4. 创建工程</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">打开KeilMDK创建工程。</span><br></pre></td></tr></table></figure>
<h4 id="2-工程配置"><a href="#2-工程配置" class="headerlink" title="2. 工程配置"></a>2. 工程配置</h4><ol>
<li><p>添加两个ProjectGroup方便管理代码文件。</p>
</li>
<li><p>先删除默认的SourceGroup1，再添加两个：Start（启动相关的文件），User（我们自己写的代<br>码）。</p>
</li>
<li><p>创建main.c文件</p>
</li>
</ol>
<p>User路径不存在，让它帮我们创建。</p>
<h4 id="3-编译配置"><a href="#3-编译配置" class="headerlink" title="3. 编译配置"></a>3. 编译配置</h4><h6 id="1-编译器版本改为-5"><a href="#1-编译器版本改为-5" class="headerlink" title="1. 编译器版本改为 5 "></a>1. 编译器版本改为 5 </h6><p>目前最新的KeilARM用的是Compilerversion6，与前面的core_cm3.c不兼容，所以需要提前准<br>备好Compilerversion5。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">下载地址： https://developer.arm.com/downloads/view/ACOMP5 </span><br><span class="line">解压之后，把解压的后文件夹放入到 KeilMDK的安装目录 下：</span><br></pre></td></tr></table></figure>
<h6 id="2-一些其他配置"><a href="#2-一些其他配置" class="headerlink" title="2. 一些其他配置"></a>2. 一些其他配置</h6><h3 id="4-软件设计"><a href="#4-软件设计" class="headerlink" title="4. 软件设计"></a>4. 软件设计</h3><h4 id="1-main-c"><a href="#1-main-c" class="headerlink" title="1. main.c"></a>1. main.c</h4><h6 id="根据前面硬件电路设计，我们只要让-GPIOA的-0-口输出低电平就行了-。代码需要按照下面的步骤来"><a href="#根据前面硬件电路设计，我们只要让-GPIOA的-0-口输出低电平就行了-。代码需要按照下面的步骤来" class="headerlink" title="根据前面硬件电路设计，我们只要让 GPIOA的 0 口输出低电平就行了 。代码需要按照下面的步骤来"></a>根据前面硬件电路设计，我们只要让 GPIOA的 0 口输出低电平就行了 。代码需要按照下面的步骤来</h6><h6 id="实现。"><a href="#实现。" class="headerlink" title="实现。"></a>实现。</h6><h6 id="1-开启时钟"><a href="#1-开启时钟" class="headerlink" title="1. 开启时钟"></a>1. 开启时钟</h6><h6 id="在STM32中，让IO口工作，必须先开启对应的时钟。所以需要先查找到开启时钟的寄存器，然后"><a href="#在STM32中，让IO口工作，必须先开启对应的时钟。所以需要先查找到开启时钟的寄存器，然后" class="headerlink" title="在STM32中，让IO口工作，必须先开启对应的时钟。所以需要先查找到开启时钟的寄存器，然后"></a>在STM32中，让IO口工作，必须先开启对应的时钟。所以需要先查找到开启时钟的寄存器，然后</h6><h6 id="通过该寄存器操作时钟的开启或关闭。我们要打开的是GPIOA的时钟。"><a href="#通过该寄存器操作时钟的开启或关闭。我们要打开的是GPIOA的时钟。" class="headerlink" title="通过该寄存器操作时钟的开启或关闭。我们要打开的是GPIOA的时钟。"></a>通过该寄存器操作时钟的开启或关闭。我们要打开的是GPIOA的时钟。</h6><h6 id="我们需要知道RCC-APB2ENR这个寄存器的地址。如何查找呢？先知道RCC这个外设的基地址，然"><a href="#我们需要知道RCC-APB2ENR这个寄存器的地址。如何查找呢？先知道RCC这个外设的基地址，然" class="headerlink" title="我们需要知道RCC_APB2ENR这个寄存器的地址。如何查找呢？先知道RCC这个外设的基地址，然"></a>我们需要知道RCC_APB2ENR这个寄存器的地址。如何查找呢？先知道RCC这个外设的基地址，然</h6><h6 id="后加上这个寄存器的偏移地址就行了。"><a href="#后加上这个寄存器的偏移地址就行了。" class="headerlink" title="后加上这个寄存器的偏移地址就行了。"></a>后加上这个寄存器的偏移地址就行了。</h6><p>从上面可以看出来，RCC的基地址是0x40021000，APB2ENR的偏移量是0x18，所以 <strong>APB2ENR的<br>地址值是0x40021000+0x18</strong> </p>
<p>有了地址，在这个地址写入一个数据，这个数据的二进制第 2 是 1 就行了。其他位暂时不管。我们<br>写入 4 。这样就开启了GPIOA的时钟。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在代码中，我们需要把地址强转成指针才能给这个地址赋值。</span><br><span class="line">1 *(uint32_t *)(0x40021000 + 0x18) = 4 ;</span><br></pre></td></tr></table></figure>
<h6 id="2-给IO口设置输出模式"><a href="#2-给IO口设置输出模式" class="headerlink" title="2. 给IO口设置输出模式"></a>2. 给IO口设置输出模式</h6><h6 id="在STM32中，如果要让IO口输出低电平或高电平，必须给要使用的IO设置为输出模式。"><a href="#在STM32中，如果要让IO口输出低电平或高电平，必须给要使用的IO设置为输出模式。" class="headerlink" title="在STM32中，如果要让IO口输出低电平或高电平，必须给要使用的IO设置为输出模式。"></a>在STM32中，如果要让IO口输出低电平或高电平，必须给要使用的IO设置为输出模式。</h6><h6 id="根据前面的思路，需要先找到GPIOA的基地址，再根据偏移地址找到要使用的寄存器的地址。"><a href="#根据前面的思路，需要先找到GPIOA的基地址，再根据偏移地址找到要使用的寄存器的地址。" class="headerlink" title="根据前面的思路，需要先找到GPIOA的基地址，再根据偏移地址找到要使用的寄存器的地址。"></a>根据前面的思路，需要先找到GPIOA的基地址，再根据偏移地址找到要使用的寄存器的地址。</h6><p>GPIOA的基地址是 <strong>0x40010800</strong> 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">配置PA0口的输出模式的寄存器是GPIOA_CRL。</span><br></pre></td></tr></table></figure>
<h6 id="只需要让这个寄存器的最后-4-位是0011，就是最大速度的推挽输出。"><a href="#只需要让这个寄存器的最后-4-位是0011，就是最大速度的推挽输出。" class="headerlink" title="只需要让这个寄存器的最后 4 位是0011，就是最大速度的推挽输出。"></a>只需要让这个寄存器的最后 4 位是0011，就是最大速度的推挽输出。</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 *(uint32_t *)(0x40010800 + 0x00) = 3 ;</span><br></pre></td></tr></table></figure>
<h6 id="3-给PA0口输出-0"><a href="#3-给PA0口输出-0" class="headerlink" title="3. 给PA0口输出 0 "></a>3. 给PA0口输出 0 </h6><h6 id="给指定PA0口输出-0-就可以点亮LED1了。用到的寄存器是ODR数据输出寄存器。"><a href="#给指定PA0口输出-0-就可以点亮LED1了。用到的寄存器是ODR数据输出寄存器。" class="headerlink" title="给指定PA0口输出 0 就可以点亮LED1了。用到的寄存器是ODR数据输出寄存器。"></a>给指定PA0口输出 0 就可以点亮LED1了。用到的寄存器是ODR数据输出寄存器。</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ODR寄存器的地址是 0x40010800+0x0c 。给这个地址的第 0 位写 0 ，其他位写 1 。</span><br><span class="line">1 *(uint32_t *)((0x40010800 + 0x0c)) = 0xfffe;</span><br><span class="line">main.c具体代码清单。 </span><br><span class="line">#include &quot;stdint.h&quot;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">/* 开启GPIOA的时钟 */</span><br><span class="line">*(uint32_t *)(0x40021000 + 0x18) = 4 ;</span><br><span class="line">/* 给PA0设置为通用推挽输出 */</span><br><span class="line">*(uint32_t *)(0x40010800 + 0x00) = 3 ;</span><br><span class="line">/* 给输出寄存器赋值 */</span><br><span class="line">*(uint32_t *)(0x40010800 + 0x0c) = 0xfffe;</span><br><span class="line">while ( 1 )</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure>
<p>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17</p>
<h4 id="2-编译工程"><a href="#2-编译工程" class="headerlink" title="2. 编译工程"></a>2. 编译工程</h4><h4 id="3-安装ST-LINK驱动"><a href="#3-安装ST-LINK驱动" class="headerlink" title="3. 安装ST-LINK驱动"></a>3. 安装ST-LINK驱动</h4><h6 id="1-我们使用ST-LINK仿真器下载程序。"><a href="#1-我们使用ST-LINK仿真器下载程序。" class="headerlink" title="1. 我们使用ST-LINK仿真器下载程序。"></a>1. 我们使用ST-LINK仿真器下载程序。</h6><ol>
<li><p>Keil的安装目录下自带了ST-LINK的USB驱动，双击安装即可。</p>
</li>
<li><p>升级STLink固件</p>
</li>
</ol>
<h4 id="4-Keil中配置ST-LINK"><a href="#4-Keil中配置ST-LINK" class="headerlink" title="4. Keil中配置ST-LINK"></a>4. Keil中配置ST-LINK</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">还需要在Keil软件中，对仿真器做一些必要的配置。</span><br></pre></td></tr></table></figure>
<h4 id="5-下载程序"><a href="#5-下载程序" class="headerlink" title="5. 下载程序"></a>5. 下载程序</h4><h4 id="6-操作寄存器方式的”进化”"><a href="#6-操作寄存器方式的”进化”" class="headerlink" title="6. 操作寄存器方式的”进化”"></a>6. 操作寄存器方式的”进化”</h4><h5 id="1-“进化1”"><a href="#1-“进化1”" class="headerlink" title="1. “进化1”"></a>1. “进化1”</h5><h6 id="在操作寄存器的时候，如果每次都查手册计算地址，是相当麻烦且无聊。ST公司早就考虑到了这"><a href="#在操作寄存器的时候，如果每次都查手册计算地址，是相当麻烦且无聊。ST公司早就考虑到了这" class="headerlink" title="在操作寄存器的时候，如果每次都查手册计算地址，是相当麻烦且无聊。ST公司早就考虑到了这"></a>在操作寄存器的时候，如果每次都查手册计算地址，是相当麻烦且无聊。ST公司早就考虑到了这</h6><h6 id="个问题，已经提前把每个外设寄存器的地址提前给我们用-宏定义-的方式给算好了，我只需要直接使用"><a href="#个问题，已经提前把每个外设寄存器的地址提前给我们用-宏定义-的方式给算好了，我只需要直接使用" class="headerlink" title="个问题，已经提前把每个外设寄存器的地址提前给我们用 宏定义 的方式给算好了，我只需要直接使用"></a>个问题，已经提前把每个外设寄存器的地址提前给我们用 宏定义 的方式给算好了，我只需要直接使用</h6><p>即可。比如下面是定义的RCC各个寄存器地址。（stm32f10x.h中定义）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">1 #define PERIPH_BASE ((uint32_t)0x40000000)</span><br><span class="line">#define AHBPERIPH_BASE (PERIPH_BASE + 0x20000)</span><br><span class="line">#define RCC_BASE (AHBPERIPH_BASE + 0x1000)</span><br><span class="line">#define RCC ((RCC_TypeDef *) RCC_BASE)</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">__IO uint32_t CR;</span><br><span class="line">__IO uint32_t CFGR;</span><br><span class="line">__IO uint32_t CIR;</span><br><span class="line">__IO uint32_t APB2RSTR;</span><br><span class="line">__IO uint32_t APB1RSTR;</span><br><span class="line">__IO uint32_t AHBENR;</span><br><span class="line">__IO uint32_t APB2ENR;</span><br><span class="line">__IO uint32_t APB1ENR;</span><br><span class="line">__IO uint32_t BDCR;</span><br><span class="line">__IO uint32_t CSR;</span><br><span class="line">&#125; RCC_TypeDef;</span><br><span class="line">2 3 4 5 6 7 8 9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td></tr></table></figure>
<h6 id="这里还巧妙的运用了-结构体中各个成员地址是连续的特征-。CR寄存器是RCC第-0-个-32-位寄存器，所"><a href="#这里还巧妙的运用了-结构体中各个成员地址是连续的特征-。CR寄存器是RCC第-0-个-32-位寄存器，所" class="headerlink" title="这里还巧妙的运用了 结构体中各个成员地址是连续的特征 。CR寄存器是RCC第 0 个 32 位寄存器，所"></a>这里还巧妙的运用了 结构体中各个成员地址是连续的特征 。CR寄存器是RCC第 0 个 32 位寄存器，所</h6><h6 id="以它相对于基地址的偏移是-0-。CFGR相对于基地址的偏移是-4-，…"><a href="#以它相对于基地址的偏移是-0-。CFGR相对于基地址的偏移是-4-，…" class="headerlink" title="以它相对于基地址的偏移是 0 。CFGR相对于基地址的偏移是 4 ，…"></a>以它相对于基地址的偏移是 0 。CFGR相对于基地址的偏移是 4 ，…</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">APB2ENR的相对于基地址的偏移是6*4=24=0x18，和我们前面查找手册的结果是一致的。</span><br><span class="line">#include &quot;stm32f10x.h&quot;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">RCC-&gt;APB2ENR = 4 ;</span><br><span class="line">GPIOA-&gt;CRL = 3 ;</span><br><span class="line">GPIOA-&gt;ODR = 0xfffe;</span><br><span class="line">while ( 1 )</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td></tr></table></figure>
<h6 id="这样写起来是不是可读性就好很多了，而且也简单了很多。"><a href="#这样写起来是不是可读性就好很多了，而且也简单了很多。" class="headerlink" title="这样写起来是不是可读性就好很多了，而且也简单了很多。"></a>这样写起来是不是可读性就好很多了，而且也简单了很多。</h6><h5 id="2-“进化2”"><a href="#2-“进化2”" class="headerlink" title="2. “进化2”"></a>2. “进化2”</h5><h6 id="其实在上面的代码中还有一些问题。在STM32中一个寄存器是-32-位的，我们在编写代码的时候只"><a href="#其实在上面的代码中还有一些问题。在STM32中一个寄存器是-32-位的，我们在编写代码的时候只" class="headerlink" title="其实在上面的代码中还有一些问题。在STM32中一个寄存器是 32 位的，我们在编写代码的时候只"></a>其实在上面的代码中还有一些问题。在STM32中一个寄存器是 32 位的，我们在编写代码的时候只</h6><h6 id="是需要给某位或某几位赋值。由于STM32不支持位寻址，所以在前面的操作中，我们其实是修改了所"><a href="#是需要给某位或某几位赋值。由于STM32不支持位寻址，所以在前面的操作中，我们其实是修改了所" class="headerlink" title="是需要给某位或某几位赋值。由于STM32不支持位寻址，所以在前面的操作中，我们其实是修改了所"></a>是需要给某位或某几位赋值。由于STM32不支持位寻址，所以在前面的操作中，我们其实是修改了所</h6><h6 id="有位。这是非常不合理的，也许其他位在其他地方有赋值，我们重新赋值势必会覆盖了其他值，带来"><a href="#有位。这是非常不合理的，也许其他位在其他地方有赋值，我们重新赋值势必会覆盖了其他值，带来" class="headerlink" title="有位。这是非常不合理的，也许其他位在其他地方有赋值，我们重新赋值势必会覆盖了其他值，带来"></a>有位。这是非常不合理的，也许其他位在其他地方有赋值，我们重新赋值势必会覆盖了其他值，带来</h6><h6 id="的后果也是很严重的。"><a href="#的后果也是很严重的。" class="headerlink" title="的后果也是很严重的。"></a>的后果也是很严重的。</h6><h6 id="如何只修改特定的位的值，而不影响其他位呢？我们需要先回顾下一些常⻅的位操作，再来继续"><a href="#如何只修改特定的位的值，而不影响其他位呢？我们需要先回顾下一些常⻅的位操作，再来继续" class="headerlink" title="如何只修改特定的位的值，而不影响其他位呢？我们需要先回顾下一些常⻅的位操作，再来继续"></a>如何只修改特定的位的值，而不影响其他位呢？我们需要先回顾下一些常⻅的位操作，再来继续</h6><h6 id="进化上面的代码。"><a href="#进化上面的代码。" class="headerlink" title="进化上面的代码。"></a>进化上面的代码。</h6><h6 id="1-常用的一些位操作回顾"><a href="#1-常用的一些位操作回顾" class="headerlink" title="1. 常用的一些位操作回顾"></a>1. 常用的一些位操作回顾</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;stdlib.h&quot;</span><br><span class="line">char buffer[ 100 ] = &#123; 0 &#125;;</span><br><span class="line">void printfBinary(unsigned char *op, unsigned char result)</span><br><span class="line">&#123;</span><br><span class="line">itoa(result, buffer, 2 ); // 把result转成 2 进制字符串</span><br><span class="line">printf(&quot;%s = %s\r\n&quot;, op, buffer);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">/* 左移 8&lt;&lt;1 = 1000&lt;&lt;1 = 10000*/</span><br><span class="line">printfBinary(&quot;8 &lt;&lt; 1&quot;, 8 &lt;&lt; 1 );</span><br><span class="line">/* 右移 8&gt;&gt;1 = 1000&gt;&gt;1 = 100*/</span><br><span class="line">printfBinary(&quot;8 &gt;&gt; 1&quot;, 8 &gt;&gt; 1 );</span><br><span class="line">/* 按位或 8|7 = 1000|0111 = 1111 */</span><br><span class="line">printfBinary(&quot;8 | 7&quot;, 8 | 7 );</span><br><span class="line">/* 按位或 8&amp;7 = 1000&amp;0111 = 0000 */</span><br><span class="line">printfBinary(&quot;8 &amp; 7&quot;, 8 &amp; 7 );</span><br><span class="line">/* 按位取反 ~8 = ~1000 = 0111 */</span><br><span class="line">printfBinary(&quot;~8&quot;, ~ 8 );</span><br><span class="line">/*</span><br><span class="line">把某位置 1  (0 位 1 位 ...)</span><br><span class="line">比如把 mum 的第 2 位置 1</span><br></pre></td></tr></table></figure>
<ol>
<li>得到一个数第 2 位是 1 其他都为 0<br>a = 0000 0100 是由 1&lt;&lt;2 得到</li>
<li>让 num | a<br>*/<br>printfBinary(“8置第 2 位为 1 “, 8 | ( 1 &lt;&lt; 2 ));</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">把连续的多位同时置 1  (0 位 1 位 ...)</span><br><span class="line">比如把 mum 的第 1 和 2 位置 1</span><br><span class="line">1  a =  3 &lt;&lt; 1</span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td></tr></table></figure>
<ol>
<li>num | a<br>*/<br>printfBinary(“8置第 1 和 2 位为 1 “, 8 | ( 3 &lt;&lt; 1 ));</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">把某位置 0  (0位 1 位 ...)</span><br><span class="line">比如把 mum 的第 2 位置 0</span><br></pre></td></tr></table></figure>
<ol>
<li>得到一个数第 2 位是 0 其他都为 1<br>a = 1111 0100 是由 ~(1&lt;&lt;2) 得到</li>
<li>让 num &amp; a<br>*/<br>printfBinary(“7置第 2 位为 0 “, 7 &amp; ~( 1 &lt;&lt; 2 ));</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">把连续多位同时置 0  (0位 1 位 ...)</span><br><span class="line">比如把 mum 的第 1 和 2 位置 0</span><br></pre></td></tr></table></figure>
<ol>
<li>a = ~(3&lt;&lt;1)</li>
<li>让 num &amp; a<br>*/<br>printfBinary(“7置第 1 和 2 位为 0 “, 7 &amp; ~( 3 &lt;&lt; 1 ));</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">把连续的多位同时置位  101 (二进制)</span><br><span class="line">比如把 mum 的第 1,2,3 位置为 101</span><br></pre></td></tr></table></figure>
<ol>
<li>num的 1,2,3位置为 0<br>num &amp;= ~(7&lt;&lt;1)</li>
<li>num |= (5 &lt;&lt; 1); (5 = 101)<br>*/</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">unsigned char num = 13 ;</span><br><span class="line">num &amp;= ~( 7 &lt;&lt; 1 );</span><br><span class="line">num |= 5 &lt;&lt; 1 ;</span><br><span class="line">printfBinary(&quot;13&quot;, 13 );</span><br><span class="line">printfBinary(&quot;10的 123 位置为101 &quot;, num);</span><br><span class="line">&#125;</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td></tr></table></figure>
<h6 id="2-继续进化"><a href="#2-继续进化" class="headerlink" title="2. 继续进化"></a>2. 继续进化</h6><h6 id="根据前面基本位操作的回顾，我们综合使用这些位操作，可以把代码进化为下面的形式。"><a href="#根据前面基本位操作的回顾，我们综合使用这些位操作，可以把代码进化为下面的形式。" class="headerlink" title="根据前面基本位操作的回顾，我们综合使用这些位操作，可以把代码进化为下面的形式。"></a>根据前面基本位操作的回顾，我们综合使用这些位操作，可以把代码进化为下面的形式。</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stm32f10x.h&quot;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">/* 开启GPIOA的时钟 第 2 位置1*/</span><br><span class="line">RCC-&gt;APB2ENR |= 0x1 &lt;&lt; 2 ;</span><br><span class="line">1 2 3 4 5 6</span><br><span class="line">/* GPIOA_CRL的最后 4 位置 0011 */</span><br><span class="line">GPIOA-&gt;CRL &amp;= ~(0x1 &lt;&lt; 3 );</span><br><span class="line">GPIOA-&gt;CRL &amp;= ~(0x1 &lt;&lt; 2 );</span><br><span class="line">GPIOA-&gt;CRL |= 0x1 &lt;&lt; 1 ;</span><br><span class="line">GPIOA-&gt;CRL |= 0x1 &lt;&lt; 0 ;</span><br><span class="line">/* GPIOA_ODR的第 0 位置0 */</span><br><span class="line">GPIOA-&gt;ODR &amp;= ~(0x1 &lt;&lt; 0 );</span><br><span class="line">while ( 1 )</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td></tr></table></figure>
<h5 id="3-“进化3”"><a href="#3-“进化3”" class="headerlink" title="3. “进化3”"></a>3. “进化3”</h5><h6 id="在上次的进化中，我们是给寄存器“或等”和“与等”了一些值，这些值都是通过相应的“移"><a href="#在上次的进化中，我们是给寄存器“或等”和“与等”了一些值，这些值都是通过相应的“移" class="headerlink" title="在上次的进化中，我们是给寄存器“或等”和“与等”了一些值，这些值都是通过相应的“移"></a>在上次的进化中，我们是给寄存器“或等”和“与等”了一些值，这些值都是通过相应的“移</h6><p>位”操作得到的。比如要操作第 2 位，就需要把0x1左移 2 位得到。我们需要查找手册才能知道要移位<br>几。也是很不方便。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">其实ST公司也把我们需要的 移位后的值给提前计算好 了，用宏定义的方式供我们使用。</span><br><span class="line">比如前面的开启时钟，已经定义了好了这个值。正好就是1&lt;&lt;2</span><br><span class="line">1 #define RCC_APB2ENR_IOPAEN ((uint32_t)0x00000004)</span><br></pre></td></tr></table></figure>
<h6 id="利用ST公司提前预定义的这些值，可以进一步进化代码为下面的形式。"><a href="#利用ST公司提前预定义的这些值，可以进一步进化代码为下面的形式。" class="headerlink" title="利用ST公司提前预定义的这些值，可以进一步进化代码为下面的形式。"></a>利用ST公司提前预定义的这些值，可以进一步进化代码为下面的形式。</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stm32f10x.h&quot;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">RCC-&gt;APB2ENR |= RCC_APB2ENR_IOPAEN;</span><br><span class="line">GPIOA-&gt;CRL &amp;= ~GPIO_CRL_CNF0_1;</span><br><span class="line">GPIOA-&gt;CRL &amp;= ~GPIO_CRL_CNF0_0;</span><br><span class="line">GPIOA-&gt;CRL |= GPIO_CRL_MODE0_1;</span><br><span class="line">GPIOA-&gt;CRL |= GPIO_CRL_MODE0_0;</span><br><span class="line">GPIOA-&gt;ODR &amp;= ~GPIO_ODR_ODR0;</span><br><span class="line">while ( 1 )</span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td></tr></table></figure>
<h6 id="这样可读性就好多了，等操作熟练之后，很多操作不查找寄存器手册也能直接操作了。"><a href="#这样可读性就好多了，等操作熟练之后，很多操作不查找寄存器手册也能直接操作了。" class="headerlink" title="这样可读性就好多了，等操作熟练之后，很多操作不查找寄存器手册也能直接操作了。"></a>这样可读性就好多了，等操作熟练之后，很多操作不查找寄存器手册也能直接操作了。</h6><h2 id="3-GPIO外设"><a href="#3-GPIO外设" class="headerlink" title="3. GPIO外设"></a>3. GPIO外设</h2><h3 id="1-GPIO概述"><a href="#1-GPIO概述" class="headerlink" title="1. GPIO概述"></a>1. GPIO概述</h3><p>GPIO <strong>（General-purposeinput/output）</strong> ，通用型输入输出。简单理解就是我们可以 <strong>控制输入<br>输出</strong> 的STM32引脚，统称为GPIO。</p>
<p>GPIO存在的意义就是 <strong>用程序控制或读取</strong> 他们的 <strong>输出或输入</strong> 。</p>
<h4 id="1-GPIO总体说明"><a href="#1-GPIO总体说明" class="headerlink" title="1. GPIO总体说明"></a>1. GPIO总体说明</h4><h6 id="STM32有多组GPIO，比如我们使用的芯片：STM32F103ZET6共有-7-组GPIO端口-，他们分别是"><a href="#STM32有多组GPIO，比如我们使用的芯片：STM32F103ZET6共有-7-组GPIO端口-，他们分别是" class="headerlink" title="STM32有多组GPIO，比如我们使用的芯片：STM32F103ZET6共有 7 组GPIO端口 ，他们分别是"></a>STM32有多组GPIO，比如我们使用的芯片：STM32F103ZET6共有 7 组GPIO端口 ，他们分别是</h6><p><strong>GPIOx（x从A-G）</strong> ， <strong>每组控制 16 个引脚，</strong> 共有 <strong>112</strong> 个GPIO引脚。具体一个其他STM32芯片有多少组<br>GPIO，可以去查看他们的对应的 <strong>数据手册</strong> 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每个引脚的电平是 0-3.3V ，部分引脚最高可以兼容到 5V 。</span><br></pre></td></tr></table></figure>
<h4 id="1-GPIO的主要特点"><a href="#1-GPIO的主要特点" class="headerlink" title="1. GPIO的主要特点"></a>1. GPIO的主要特点</h4><h6 id="1-不同型号，IO口的数量可能不一样。"><a href="#1-不同型号，IO口的数量可能不一样。" class="headerlink" title="1. 不同型号，IO口的数量可能不一样。"></a>1. 不同型号，IO口的数量可能不一样。</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2. 快速翻转。最快可以达到每 2 个时钟周期翻转一次。（STM32F1系列最快可以达到 5 0MHz的翻转速</span><br><span class="line">度）。</span><br><span class="line">3. 每个IO都可以作为外部中断。</span><br><span class="line">4. 支持 8 种工作模式。</span><br></pre></td></tr></table></figure>
<h4 id="2-GPIO的-8-种工作模式"><a href="#2-GPIO的-8-种工作模式" class="headerlink" title="2. GPIO的 8 种工作模式"></a>2. GPIO的 8 种工作模式</h4><h6 id="GPIO端口的每个位（引脚）可以由-软件-分别-配置-成-8-种模式，当然对同一个引脚同一时间只能处于某"><a href="#GPIO端口的每个位（引脚）可以由-软件-分别-配置-成-8-种模式，当然对同一个引脚同一时间只能处于某" class="headerlink" title="GPIO端口的每个位（引脚）可以由 软件 分别 配置 成 8 种模式，当然对同一个引脚同一时间只能处于某"></a>GPIO端口的每个位（引脚）可以由 软件 分别 配置 成 8 种模式，当然对同一个引脚同一时间只能处于某</h6><h6 id="一种模式中。"><a href="#一种模式中。" class="headerlink" title="一种模式中。"></a>一种模式中。</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 输入浮空（Inputfloating） </span><br></pre></td></tr></table></figure>
<ol>
<li><strong>输入上拉（Inputpull-up）信号默认高电平</strong> </li>
<li><strong>输入下拉（Input-pull-down）信号默认低电平</strong> </li>
<li><strong>模拟输入（Analog）</strong> </li>
<li><strong>通用开漏式输出（Outputopen-drain）</strong> </li>
<li><strong>通用推挽式输出（Outputpush-pull）</strong> </li>
<li><strong>复用推挽式功能（Alternatefunctionpush-pull）</strong> </li>
<li><strong>复用开漏式功能（Alternatefunctionopen-drain）</strong> <br>每个I/O端口位可以自由编程，然而I/0端口寄存器必须按 <strong>32 位字</strong> 被访问。<br><strong>输出模式</strong> 下可以 <strong>控制端口输出</strong> 高电平低电平，用于驱动LED，蜂鸣器等，如果是大功率器件（比如<br>电机），还需要加上驱动器（小电流控制大电流）。</li>
</ol>
<p><strong>输入模式</strong> 下可以 <strong>读取端口</strong> 的高低电平，用于读取外接按键，外接模拟信号的输入，ADC电压采<br>集，模拟通信协议接受数据等。</p>
<h3 id="2-GPIO工作模式"><a href="#2-GPIO工作模式" class="headerlink" title="2. GPIO工作模式"></a>2. GPIO工作模式</h3><h4 id="1-GPIO每位的具体电路结构"><a href="#1-GPIO每位的具体电路结构" class="headerlink" title="1. GPIO每位的具体电路结构"></a>1. GPIO每位的具体电路结构</h4><h4 id="2-每种模式详解"><a href="#2-每种模式详解" class="headerlink" title="2. 每种模式详解"></a>2. 每种模式详解</h4><h5 id="1-输出模式"><a href="#1-输出模式" class="headerlink" title="1. 输出模式"></a>1. 输出模式</h5><h6 id="1-输出缓冲器被激活。"><a href="#1-输出缓冲器被激活。" class="headerlink" title="1. 输出缓冲器被激活。"></a>1. 输出缓冲器被激活。</h6><h6 id="2-推挽模式：输出寄存器上的1将激活P-MOS，输出高电平。0将激活N-MOS，输出低电平。"><a href="#2-推挽模式：输出寄存器上的1将激活P-MOS，输出高电平。0将激活N-MOS，输出低电平。" class="headerlink" title="2. 推挽模式：输出寄存器上的1将激活P-MOS，输出高电平。0将激活N-MOS，输出低电平。 "></a>2. 推挽模式：输出寄存器上的1将激活P-MOS，输出高电平。0将激活N-MOS，输出低电平。 </h6><h6 id="3-开漏模式：P-MOS永远关闭。输出寄存器上的0激活N-MOS，而输出寄存器上的-1将端口置于高"><a href="#3-开漏模式：P-MOS永远关闭。输出寄存器上的0激活N-MOS，而输出寄存器上的-1将端口置于高" class="headerlink" title="3. 开漏模式：P-MOS永远关闭。输出寄存器上的0激活N-MOS，而输出寄存器上的 1将端口置于高"></a>3. 开漏模式：P-MOS永远关闭。输出寄存器上的0激活N-MOS，而输出寄存器上的 1将端口置于高</h6><h6 id="阻状态，所以外部必须要接上拉电阻。"><a href="#阻状态，所以外部必须要接上拉电阻。" class="headerlink" title="阻状态，所以外部必须要接上拉电阻。"></a>阻状态，所以外部必须要接上拉电阻。</h6><h6 id="4-施密特触发输入被激活。"><a href="#4-施密特触发输入被激活。" class="headerlink" title="4. 施密特触发输入被激活。"></a>4. 施密特触发输入被激活。</h6><h6 id="5-弱上拉和下拉电阻被禁止。"><a href="#5-弱上拉和下拉电阻被禁止。" class="headerlink" title="5. 弱上拉和下拉电阻被禁止。"></a>5. 弱上拉和下拉电阻被禁止。</h6><h6 id="6-出现在I-O脚上的数据在每个APB2时钟被采样到输入数据寄存器。"><a href="#6-出现在I-O脚上的数据在每个APB2时钟被采样到输入数据寄存器。" class="headerlink" title="6. 出现在I/O脚上的数据在每个APB2时钟被采样到输入数据寄存器。 "></a>6. 出现在I/O脚上的数据在每个APB2时钟被采样到输入数据寄存器。 </h6><h6 id="7-在开漏模式时，对输入数据寄存器的读访问可得到I-O状态。"><a href="#7-在开漏模式时，对输入数据寄存器的读访问可得到I-O状态。" class="headerlink" title="7. 在开漏模式时，对输入数据寄存器的读访问可得到I/O状态。 "></a>7. 在开漏模式时，对输入数据寄存器的读访问可得到I/O状态。 </h6><h6 id="8-在推挽模式时，对输出数据寄存器的读访问得到最后一次写的值。"><a href="#8-在推挽模式时，对输出数据寄存器的读访问得到最后一次写的值。" class="headerlink" title="8. 在推挽模式时，对输出数据寄存器的读访问得到最后一次写的值。"></a>8. 在推挽模式时，对输出数据寄存器的读访问得到最后一次写的值。</h6><h5 id="2-复用输出模式"><a href="#2-复用输出模式" class="headerlink" title="2. 复用输出模式"></a>2. 复用输出模式</h5><h6 id="1-在开漏或推挽式配置中，输出缓冲器被打开。"><a href="#1-在开漏或推挽式配置中，输出缓冲器被打开。" class="headerlink" title="1. 在开漏或推挽式配置中，输出缓冲器被打开。"></a>1. 在开漏或推挽式配置中，输出缓冲器被打开。</h6><h6 id="2-内置外设的信号驱动输出缓冲器（复用功能输出）。"><a href="#2-内置外设的信号驱动输出缓冲器（复用功能输出）。" class="headerlink" title="2. 内置外设的信号驱动输出缓冲器（复用功能输出）。"></a>2. 内置外设的信号驱动输出缓冲器（复用功能输出）。</h6><h6 id="3-施密特触发输入被激活。"><a href="#3-施密特触发输入被激活。" class="headerlink" title="3. 施密特触发输入被激活。"></a>3. 施密特触发输入被激活。</h6><h6 id="4-弱上拉和下拉电阻被禁止。"><a href="#4-弱上拉和下拉电阻被禁止。" class="headerlink" title="4. 弱上拉和下拉电阻被禁止。"></a>4. 弱上拉和下拉电阻被禁止。</h6><h6 id="5-在每个APB2时钟周期，出现在I-O脚上的数据被采样到输入数据寄存器。"><a href="#5-在每个APB2时钟周期，出现在I-O脚上的数据被采样到输入数据寄存器。" class="headerlink" title="5. 在每个APB2时钟周期，出现在I/O脚上的数据被采样到输入数据寄存器。 "></a>5. 在每个APB2时钟周期，出现在I/O脚上的数据被采样到输入数据寄存器。 </h6><h6 id="6-开漏模式时，读输入数据寄存器时可得到I-O口状态。"><a href="#6-开漏模式时，读输入数据寄存器时可得到I-O口状态。" class="headerlink" title="6. 开漏模式时，读输入数据寄存器时可得到I/O口状态。 "></a>6. 开漏模式时，读输入数据寄存器时可得到I/O口状态。 </h6><h6 id="7-在推挽模式时，读输出数据寄存器时可得到最后一次写的值。"><a href="#7-在推挽模式时，读输出数据寄存器时可得到最后一次写的值。" class="headerlink" title="7. 在推挽模式时，读输出数据寄存器时可得到最后一次写的值。"></a>7. 在推挽模式时，读输出数据寄存器时可得到最后一次写的值。</h6><h5 id="3-输入模式"><a href="#3-输入模式" class="headerlink" title="3. 输入模式"></a>3. 输入模式</h5><h6 id="1-2-个保护二极管的作用是保护我们的芯片不会由于电压过高或过低而烧毁。"><a href="#1-2-个保护二极管的作用是保护我们的芯片不会由于电压过高或过低而烧毁。" class="headerlink" title="1. 2 个保护二极管的作用是保护我们的芯片不会由于电压过高或过低而烧毁。 "></a>1. 2 个保护二极管的作用是保护我们的芯片不会由于电压过高或过低而烧毁。 </h6><h6 id="VDD是接电源（3-3V），VSS接地（0V）。如果IO引脚的输入电压高于VDD的值到一定程度，上方"><a href="#VDD是接电源（3-3V），VSS接地（0V）。如果IO引脚的输入电压高于VDD的值到一定程度，上方" class="headerlink" title="VDD是接电源（3.3V），VSS接地（0V）。如果IO引脚的输入电压高于VDD的值到一定程度，上方"></a>VDD是接电源（3.3V），VSS接地（0V）。如果IO引脚的输入电压高于VDD的值到一定程度，上方</h6><h6 id="保护二极管导通，则引脚电压被拉低到VDD。如果IO引脚的输入电压（负电压）低于VSS到一定程度，"><a href="#保护二极管导通，则引脚电压被拉低到VDD。如果IO引脚的输入电压（负电压）低于VSS到一定程度，" class="headerlink" title="保护二极管导通，则引脚电压被拉低到VDD。如果IO引脚的输入电压（负电压）低于VSS到一定程度，"></a>保护二极管导通，则引脚电压被拉低到VDD。如果IO引脚的输入电压（负电压）低于VSS到一定程度，</h6><h6 id="则下方保护二极管导通，电压被拉高到VSS。"><a href="#则下方保护二极管导通，电压被拉高到VSS。" class="headerlink" title="则下方保护二极管导通，电压被拉高到VSS。"></a>则下方保护二极管导通，电压被拉高到VSS。</h6><h6 id="2-2-个开关控制引脚没有输入的时候是上拉，下拉还是浮空。"><a href="#2-2-个开关控制引脚没有输入的时候是上拉，下拉还是浮空。" class="headerlink" title="2. 2 个开关控制引脚没有输入的时候是上拉，下拉还是浮空。"></a>2. 2 个开关控制引脚没有输入的时候是上拉，下拉还是浮空。</h6><h6 id="当上面的开关闭合的时候，输入被拉高到高电平。当下面的开关闭合的时候，入被拉低到低电"><a href="#当上面的开关闭合的时候，输入被拉高到高电平。当下面的开关闭合的时候，入被拉低到低电" class="headerlink" title="当上面的开关闭合的时候，输入被拉高到高电平。当下面的开关闭合的时候，入被拉低到低电"></a>当上面的开关闭合的时候，输入被拉高到高电平。当下面的开关闭合的时候，入被拉低到低电</h6><h6 id="平。如果两个都不闭合，输入就是悬空状态。-两个同时闭合，就是费电了，不会这么做的-。"><a href="#平。如果两个都不闭合，输入就是悬空状态。-两个同时闭合，就是费电了，不会这么做的-。" class="headerlink" title="平。如果两个都不闭合，输入就是悬空状态。 两个同时闭合，就是费电了，不会这么做的 。"></a>平。如果两个都不闭合，输入就是悬空状态。 两个同时闭合，就是费电了，不会这么做的 。</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3. 施密特（图中翻译成肖特基触发器应该是翻译错误，英文版手册是TTLSchmitttrigger）触发器是</span><br><span class="line">包含正反馈的比较器电路。可以对信号进行波形整形。</span><br></pre></td></tr></table></figure>
<h6 id="4-从施密特触发起出来的数据，进入到输入数据寄存器中，我们就可以从中读取数据了。"><a href="#4-从施密特触发起出来的数据，进入到输入数据寄存器中，我们就可以从中读取数据了。" class="headerlink" title="4. 从施密特触发起出来的数据，进入到输入数据寄存器中，我们就可以从中读取数据了。"></a>4. 从施密特触发起出来的数据，进入到输入数据寄存器中，我们就可以从中读取数据了。</h6><h5 id="4-模拟输入模式"><a href="#4-模拟输入模式" class="headerlink" title="4. 模拟输入模式"></a>4. 模拟输入模式</h5><h6 id="当配置为-模拟输入-时："><a href="#当配置为-模拟输入-时：" class="headerlink" title="当配置为 模拟输入 时："></a>当配置为 模拟输入 时：</h6><h6 id="1-输出部分被禁止。"><a href="#1-输出部分被禁止。" class="headerlink" title="1. 输出部分被禁止。"></a>1. 输出部分被禁止。</h6><h6 id="2-禁止施密特触发输入-，实现了每个模拟I-O引脚上的零消耗。施密特触发输出值被强置为-0-，此时也"><a href="#2-禁止施密特触发输入-，实现了每个模拟I-O引脚上的零消耗。施密特触发输出值被强置为-0-，此时也" class="headerlink" title="2. 禁止施密特触发输入 ，实现了每个模拟I/O引脚上的零消耗。施密特触发输出值被强置为 0 ，此时也"></a>2. 禁止施密特触发输入 ，实现了每个模拟I/O引脚上的零消耗。施密特触发输出值被强置为 0 ，此时也</h6><h6 id="可以不用开启对应GPIO的时钟。"><a href="#可以不用开启对应GPIO的时钟。" class="headerlink" title="可以不用开启对应GPIO的时钟。"></a>可以不用开启对应GPIO的时钟。</h6><h6 id="3-弱上拉和下拉电阻被禁止。"><a href="#3-弱上拉和下拉电阻被禁止。" class="headerlink" title="3. 弱上拉和下拉电阻被禁止。"></a>3. 弱上拉和下拉电阻被禁止。</h6><h6 id="4-读取输入数据寄存器时数值永远为-0-。"><a href="#4-读取输入数据寄存器时数值永远为-0-。" class="headerlink" title="4. 读取输入数据寄存器时数值永远为 0 。"></a>4. 读取输入数据寄存器时数值永远为 0 。</h6><h3 id="3-与GPIO相关的-7-个寄存器（重要）"><a href="#3-与GPIO相关的-7-个寄存器（重要）" class="headerlink" title="3. 与GPIO相关的 7 个寄存器（重要）"></a>3. 与GPIO相关的 7 个寄存器（重要）</h3><h6 id="每个GPI-O端口有-7-个相关的："><a href="#每个GPI-O端口有-7-个相关的：" class="headerlink" title="每个GPI/O端口有 7 个相关的："></a>每个GPI/O端口有 7 个相关的：</h6><p>-^2 个^32 位配置寄存器 <strong>（GPIOx_CRL，GPIOx_CRH）</strong> 。<br>-^2 个^32 位数据寄存器 <strong>（GPIOx_IDR和GPIOx_ODR）</strong> 。<br>-^1 个^32 位置位/复位寄存器 <strong>（GPIOx_BSRR）</strong> 。<br>-^1 个^16 位复位寄存器 <strong>（GPIOx_BRR）</strong> 。<br>-^1 个^32 位锁定寄存器 <strong>（GPIOx_LCKR）</strong> 。</p>
<h4 id="1-GPIOx-CRL（端口配置低寄存器）"><a href="#1-GPIOx-CRL（端口配置低寄存器）" class="headerlink" title="1. GPIOx_CRL（端口配置低寄存器）"></a>1. GPIOx_CRL（端口配置低寄存器）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GPIOx_CRL（Portconfigurationregisterlow） ， x 可以是 A-G 。</span><br></pre></td></tr></table></figure>
<h6 id="该寄存器配置的每个GPIO的0-7这个-8-个位，所以叫低寄存器。"><a href="#该寄存器配置的每个GPIO的0-7这个-8-个位，所以叫低寄存器。" class="headerlink" title="该寄存器配置的每个GPIO的0-7这个 8 个位，所以叫低寄存器。"></a>该寄存器配置的每个GPIO的0-7这个 8 个位，所以叫低寄存器。</h6><h6 id="1-MODE：每个端口有-2-个MODE位进行控制。"><a href="#1-MODE：每个端口有-2-个MODE位进行控制。" class="headerlink" title="1. MODE：每个端口有 2 个MODE位进行控制。"></a>1. MODE：每个端口有 2 个MODE位进行控制。</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a. 00 ：输入模式（复位后的状态）</span><br><span class="line">b. 01 ：输出模式，最大速度10MHz</span><br><span class="line">c. 10 ：输出模式，最大速度2MHz</span><br><span class="line">d. 11 ：输出模式，最大速度50MHz</span><br><span class="line">2. CNF：每个端口有 2 个CNF位进行控制。</span><br><span class="line">a. 当MODE是00（输入模式）</span><br></pre></td></tr></table></figure>
<h3 id="▪-00-：模拟输入模式"><a href="#▪-00-：模拟输入模式" class="headerlink" title="▪^00 ：模拟输入模式"></a>▪^00 ：模拟输入模式</h3><h3 id="▪-01-：浮空输入模式-复位后的状态"><a href="#▪-01-：浮空输入模式-复位后的状态" class="headerlink" title="▪^01 ：浮空输入模式(复位后的状态)"></a>▪^01 ：浮空输入模式(复位后的状态)</h3><h3 id="▪-10-：上拉-下拉输入模式"><a href="#▪-10-：上拉-下拉输入模式" class="headerlink" title="▪^10 ：上拉/下拉输入模式"></a>▪^10 ：上拉/下拉输入模式</h3><h3 id="▪-11-：保留"><a href="#▪-11-：保留" class="headerlink" title="▪^11 ：保留"></a>▪^11 ：保留</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b. 当MODE&gt;00（输出模式）</span><br></pre></td></tr></table></figure>
<h3 id="▪-00-：通用推挽输出模式"><a href="#▪-00-：通用推挽输出模式" class="headerlink" title="▪^00 ：通用推挽输出模式"></a>▪^00 ：通用推挽输出模式</h3><h3 id="▪-01-：通用开漏输出模式"><a href="#▪-01-：通用开漏输出模式" class="headerlink" title="▪^01 ：通用开漏输出模式"></a>▪^01 ：通用开漏输出模式</h3><h3 id="▪-10-：复用功能推挽输出模式"><a href="#▪-10-：复用功能推挽输出模式" class="headerlink" title="▪^10 ：复用功能推挽输出模式"></a>▪^10 ：复用功能推挽输出模式</h3><h3 id="▪-11-：复用功能开漏输出模式"><a href="#▪-11-：复用功能开漏输出模式" class="headerlink" title="▪^11 ：复用功能开漏输出模式"></a>▪^11 ：复用功能开漏输出模式</h3><h4 id="2-GPIOx-CRH（端口配置高寄存器）"><a href="#2-GPIOx-CRH（端口配置高寄存器）" class="headerlink" title="2. GPIOx_CRH（端口配置高寄存器）"></a>2. GPIOx_CRH（端口配置高寄存器）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GPIOx_CRH（Portconfigurationregisterhigh） 。</span><br><span class="line">该寄存器配置的是每个端口的8-15引脚，配置方式和低位寄存器完全一样。</span><br></pre></td></tr></table></figure>
<h4 id="3-GPIOx-IDR（端口输入数据寄存器）"><a href="#3-GPIOx-IDR（端口输入数据寄存器）" class="headerlink" title="3. GPIOx_IDR（端口输入数据寄存器）"></a>3. GPIOx_IDR（端口输入数据寄存器）</h4><p><strong>Portinputdataregister</strong> </p>
<h6 id="保留位始终读为-0-。剩下的分别对应每个引脚的输入值。"><a href="#保留位始终读为-0-。剩下的分别对应每个引脚的输入值。" class="headerlink" title="保留位始终读为 0 。剩下的分别对应每个引脚的输入值。"></a>保留位始终读为 0 。剩下的分别对应每个引脚的输入值。</h6><h4 id="4-GPIOx-ODR（端口输出数据寄存器）"><a href="#4-GPIOx-ODR（端口输出数据寄存器）" class="headerlink" title="4. GPIOx_ODR（端口输出数据寄存器）"></a>4. GPIOx_ODR（端口输出数据寄存器）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Portoutputdataregister </span><br></pre></td></tr></table></figure>
<h6 id="保留位始终读为-0-。剩下的分别对应每个引脚的输出值。"><a href="#保留位始终读为-0-。剩下的分别对应每个引脚的输出值。" class="headerlink" title="保留位始终读为 0 。剩下的分别对应每个引脚的输出值。"></a>保留位始终读为 0 。剩下的分别对应每个引脚的输出值。</h6><h4 id="5-GPIOx-BSRR（端口位设置-清除寄存器）"><a href="#5-GPIOx-BSRR（端口位设置-清除寄存器）" class="headerlink" title="5. GPIOx_BSRR（端口位设置/清除寄存器）"></a>5. GPIOx_BSRR（端口位设置/清除寄存器）</h4><p><strong>Portbitset/resetregister</strong> </p>
<h6 id="1-高-16-位是用清除对应的数据输出寄存器的位（0-15）的值：设置为-0-不影响，设置为-1-会清除ODR对"><a href="#1-高-16-位是用清除对应的数据输出寄存器的位（0-15）的值：设置为-0-不影响，设置为-1-会清除ODR对" class="headerlink" title="1. 高 16 位是用清除对应的数据输出寄存器的位（0-15）的值：设置为 0 不影响，设置为 1 会清除ODR对"></a>1. 高 16 位是用清除对应的数据输出寄存器的位（0-15）的值：设置为 0 不影响，设置为 1 会清除ODR对</h6><h6 id="应的位的值（置为-0-）。"><a href="#应的位的值（置为-0-）。" class="headerlink" title="应的位的值（置为 0 ）。"></a>应的位的值（置为 0 ）。</h6><h6 id="2-低-16-位是用设置对应的数据输出寄存器的位（0-15）的值：设置为-0-不影响，设置为-1-会设置ODR对"><a href="#2-低-16-位是用设置对应的数据输出寄存器的位（0-15）的值：设置为-0-不影响，设置为-1-会设置ODR对" class="headerlink" title="2. 低 16 位是用设置对应的数据输出寄存器的位（0-15）的值：设置为 0 不影响，设置为 1 会设置ODR对"></a>2. 低 16 位是用设置对应的数据输出寄存器的位（0-15）的值：设置为 0 不影响，设置为 1 会设置ODR对</h6><h6 id="应的位的值（置为-1-）。"><a href="#应的位的值（置为-1-）。" class="headerlink" title="应的位的值（置为 1 ）。"></a>应的位的值（置为 1 ）。</h6><h4 id="6-GPIOx-BRR（端口位清除寄存器）"><a href="#6-GPIOx-BRR（端口位清除寄存器）" class="headerlink" title="6. GPIOx_BRR（端口位清除寄存器）"></a>6. GPIOx_BRR（端口位清除寄存器）</h4><p>这个寄存器具有了 <strong>GPIOx_BSRR一半的功能：清除</strong> 。</p>
<h4 id="7-GPIOx-LCKR（端口配置锁定寄存器）"><a href="#7-GPIOx-LCKR（端口配置锁定寄存器）" class="headerlink" title="7. GPIOx_LCKR（端口配置锁定寄存器）"></a>7. GPIOx_LCKR（端口配置锁定寄存器）</h4><p><strong>Portconfigurationlockregister</strong> </p>
<h6 id="该寄存器用来锁定端口位的配置。位-15-0-用于锁定GPIO端口的配置。在规定的写入操作期间，"><a href="#该寄存器用来锁定端口位的配置。位-15-0-用于锁定GPIO端口的配置。在规定的写入操作期间，" class="headerlink" title="该寄存器用来锁定端口位的配置。位[15:0]用于锁定GPIO端口的配置。在规定的写入操作期间，"></a>该寄存器用来锁定端口位的配置。位[15:0]用于锁定GPIO端口的配置。在规定的写入操作期间，</h6><h6 id="不能改变LCKP-15-0-。当对相应的端口位执行了LOCK序列后，在下次系统复位之前将不能再更改端口"><a href="#不能改变LCKP-15-0-。当对相应的端口位执行了LOCK序列后，在下次系统复位之前将不能再更改端口" class="headerlink" title="不能改变LCKP[15:0]。当对相应的端口位执行了LOCK序列后，在下次系统复位之前将不能再更改端口"></a>不能改变LCKP[15:0]。当对相应的端口位执行了LOCK序列后，在下次系统复位之前将不能再更改端口</h6><h6 id="位的配置。"><a href="#位的配置。" class="headerlink" title="位的配置。"></a>位的配置。</h6><h6 id="每个锁定位锁定控制寄存器（CRL，CRH）中相应的-4-个位（CNF2位和MODE2位）。"><a href="#每个锁定位锁定控制寄存器（CRL，CRH）中相应的-4-个位（CNF2位和MODE2位）。" class="headerlink" title="每个锁定位锁定控制寄存器（CRL，CRH）中相应的 4 个位（CNF2位和MODE2位）。"></a>每个锁定位锁定控制寄存器（CRL，CRH）中相应的 4 个位（CNF2位和MODE2位）。</h6><h6 id="第-16-位用来激活锁定寄存器，必须按照规定的时序来操作才行-写1-gt-写0-gt-写1-gt-读0-gt-读-1-。"><a href="#第-16-位用来激活锁定寄存器，必须按照规定的时序来操作才行-写1-gt-写0-gt-写1-gt-读0-gt-读-1-。" class="headerlink" title="第 16 位用来激活锁定寄存器，必须按照规定的时序来操作才行:写1-&gt;写0-&gt;写1 -&gt;读0 -&gt;读 1 。"></a>第 16 位用来激活锁定寄存器，必须按照规定的时序来操作才行:写1-&gt;写0-&gt;写1 -&gt;读0 -&gt;读 1 。</h6><h6 id="对0-15位："><a href="#对0-15位：" class="headerlink" title="对0-15位："></a>对0-15位：</h6><h3 id="◦-0-：不锁定对应端口的配置。"><a href="#◦-0-：不锁定对应端口的配置。" class="headerlink" title="◦^0 ：不锁定对应端口的配置。"></a>◦^0 ：不锁定对应端口的配置。</h3><h3 id="◦-1-：锁定对应端口的配置。"><a href="#◦-1-：锁定对应端口的配置。" class="headerlink" title="◦^1 ：锁定对应端口的配置。"></a>◦^1 ：锁定对应端口的配置。</h3><h3 id="4-GPIO案例：流水灯"><a href="#4-GPIO案例：流水灯" class="headerlink" title="4. GPIO案例：流水灯"></a>4. GPIO案例：流水灯</h3><h4 id="1-需求描述-1"><a href="#1-需求描述-1" class="headerlink" title="1. 需求描述"></a>1. 需求描述</h4><h6 id="在-3-个LED上实现流水灯效果。"><a href="#在-3-个LED上实现流水灯效果。" class="headerlink" title="在 3 个LED上实现流水灯效果。"></a>在 3 个LED上实现流水灯效果。</h6><h4 id="2-硬件电路设计-1"><a href="#2-硬件电路设计-1" class="headerlink" title="2. 硬件电路设计"></a>2. 硬件电路设计</h4><h4 id="3-软件设计（寄存器）"><a href="#3-软件设计（寄存器）" class="headerlink" title="3. 软件设计（寄存器）"></a>3. 软件设计（寄存器）</h4><h5 id="1-配置"><a href="#1-配置" class="headerlink" title="1. 配置"></a>1. 配置</h5><ol>
<li>copy上一个项目</li>
<li><p>并做如下操作</p>
</li>
<li><p>创建一个目录：Hardware/Led存储我们的LED驱动文件。</p>
</li>
<li>在Hardware/Led下创建 2 个文件led.h和led.c。</li>
<li>使用keil打开项目，做下简单配置。</li>
</ol>
<h5 id="2-具体代码"><a href="#2-具体代码" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h5><p>2.1 main.c</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Driver_LED.h&quot;</span><br><span class="line">#include &quot;Delay.h&quot;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">uint32_t leds[] = &#123;LED_1, LED_2, LED_3&#125;;</span><br><span class="line">/* 1. 初始化LED */</span><br><span class="line">Driver_LED_Init();</span><br><span class="line">Driver_LED_OffAll(leds, 3 );</span><br><span class="line">while ( 1 )</span><br><span class="line">&#123;</span><br><span class="line">for (uint8_t i = 0 ; i &lt; 3 ; i++)</span><br><span class="line">&#123;</span><br><span class="line">Driver_LED_OffAll(leds, 3 );</span><br><span class="line">Driver_LED_On(leds[i]);</span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">Delay_ms( 500 );</span><br><span class="line">&#125;</span><br><span class="line">Driver_LED_OffAll(leds, 3 );</span><br><span class="line">Driver_LED_On(leds[ 1 ]);</span><br><span class="line">Delay_ms( 500 );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td></tr></table></figure>
<p>2.2 Delay.h</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#ifndef __delay_h</span><br><span class="line">#define __delay_h</span><br><span class="line">#include &quot;stm32f10x.h&quot; // Device header</span><br><span class="line">void Delay_us(uint16_t us);</span><br><span class="line">void Delay_ms(uint16_t ms);</span><br><span class="line">void Delay_s(uint16_t s);</span><br><span class="line">#endif</span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure>
<p>2.3 Delay.c</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">//延时函数使用到了系统定时器，大家先使用，到提高篇时再学习具体为什么这么写。</span><br><span class="line">#include &quot;delay.h&quot; // Device header</span><br><span class="line">void Delay_us(uint16_t us)</span><br><span class="line">&#123;</span><br><span class="line">/* 定时器重装值 */</span><br><span class="line">SysTick-&gt;LOAD = 72 * us;</span><br><span class="line">/* 清除当前计数值 */</span><br><span class="line">SysTick-&gt;VAL = 0 ;</span><br><span class="line">/*设置内部时钟源（ 2 位-&gt;1）,不需要中断（ 1 位-&gt;0），并启动定时器(0位-&gt;1)*/</span><br><span class="line">SysTick-&gt;CTRL = 0x5;</span><br><span class="line">/*等待计数到 0 ， 如果计数到 0 则 16 位会置为1*/</span><br><span class="line">while (!(SysTick-&gt;CTRL &amp; SysTick_CTRL_COUNTFLAG));</span><br><span class="line">/* 关闭定时器 */</span><br><span class="line">SysTick-&gt;CTRL &amp;= ~SysTick_CTRL_ENABLE;</span><br><span class="line">&#125;</span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">void Delay_ms(uint16_t ms)</span><br><span class="line">&#123;</span><br><span class="line">while (ms--)</span><br><span class="line">&#123;</span><br><span class="line">Delay_us( 1000 );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void Delay_s(uint16_t s)</span><br><span class="line">&#123;</span><br><span class="line">while (s--)</span><br><span class="line">&#123;</span><br><span class="line">Delay_ms( 1000 );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td></tr></table></figure>
<p>2.4 Driver_LED.h</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#ifndef __DRIVER_LED_H</span><br><span class="line">#define __DRIVER_LED_H</span><br><span class="line">#include &quot;stm32f10x.h&quot;</span><br><span class="line">#define LED_1 GPIO_ODR_ODR0</span><br><span class="line">#define LED_2 GPIO_ODR_ODR1</span><br><span class="line">#define LED_3 GPIO_ODR_ODR8</span><br><span class="line">void Driver_LED_Init(void);</span><br><span class="line">void Driver_LED_On(uint32_t led);</span><br><span class="line">void Driver_LED_Off(uint32_t led);</span><br><span class="line">void Driver_LED_Toggle(uint32_t led);</span><br><span class="line">void Driver_LED_OnAll(uint32_t leds[], uint8_t size);</span><br><span class="line">void Driver_LED_OffAll(uint32_t leds[], uint8_t size);</span><br><span class="line">#endif</span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td></tr></table></figure>
<p>2.5 Driver_LED.c</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Driver_LED.h&quot;</span><br><span class="line">/**</span><br><span class="line"> * @description: 对LED进行初始化</span><br><span class="line"> */</span><br><span class="line">void Driver_LED_Init(void)</span><br><span class="line">&#123;</span><br><span class="line">/* 1. 打开GPIOA的时钟 */</span><br><span class="line">RCC-&gt;APB2ENR |= RCC_APB2ENR_IOPAEN;</span><br><span class="line">/* 2. 给用到的端口的所有 PIN (PA0 PA1 PA8) 设置工作模式: 通用推挽输出 MODE:11</span><br><span class="line"> CNF:00 */</span><br><span class="line">GPIOA-&gt;CRL |= (GPIO_CRL_MODE0 | GPIO_CRL_MODE1);</span><br><span class="line">GPIOA-&gt;CRL &amp;= ~(GPIO_CRL_CNF0 | GPIO_CRL_CNF1);</span><br><span class="line">GPIOA-&gt;CRH |= GPIO_CRH_MODE8;</span><br><span class="line">GPIOA-&gt;CRH &amp;= ~GPIO_CRH_CNF8;</span><br><span class="line">/* 3. 关闭所有灯  */</span><br><span class="line">Driver_LED_Off(LED_1);</span><br><span class="line">Driver_LED_Off(LED_2);</span><br><span class="line">Driver_LED_Off(LED_3);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @description: 点亮指定的LED</span><br><span class="line"> * @param &#123;uint32_t&#125; led 要点亮的LED</span><br><span class="line"> */</span><br><span class="line">void Driver_LED_On(uint32_t led)</span><br><span class="line">&#123;</span><br><span class="line">GPIOA-&gt;ODR &amp;= ~led;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @description: 关闭指定的LED</span><br><span class="line"> * @param &#123;uint32_t&#125; led 要关闭的LED</span><br><span class="line"> */</span><br><span class="line">void Driver_LED_Off(uint32_t led)</span><br><span class="line">&#123;</span><br><span class="line">GPIOA-&gt;ODR |= led;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @description: 翻转LED的状态</span><br><span class="line"> * @param &#123;uint32_t&#125; led 要翻转的LED</span><br><span class="line"> */</span><br><span class="line">void Driver_LED_Toggle(uint32_t led)</span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure>
<p>10<br>11</p>
<p>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">/* 1. 读取引脚的电平,如果是1(目前是关闭), 打开, 否则就关闭 */</span><br><span class="line">if ((GPIOA-&gt;IDR &amp; led) == 0 )</span><br><span class="line">&#123;</span><br><span class="line">Driver_LED_Off(led);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">Driver_LED_On(led);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @description: 打开数组中所有的灯</span><br><span class="line"> * @param &#123;uint32_t&#125; leds 所有灯</span><br><span class="line"> * @param &#123;uint8_t&#125; size 灯的个数</span><br><span class="line"> */</span><br><span class="line">void Driver_LED_OnAll(uint32_t leds[], uint8_t size)</span><br><span class="line">&#123;</span><br><span class="line">for (uint8_t i = 0 ; i &lt; size; i++)</span><br><span class="line">&#123;</span><br><span class="line">Driver_LED_On(leds[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @description: 关闭数组中所有的灯</span><br><span class="line"> * @param &#123;uint32_t&#125; leds 所有灯</span><br><span class="line"> * @param &#123;uint8_t&#125; size 灯的个数</span><br><span class="line"> */</span><br><span class="line">void Driver_LED_OffAll(uint32_t leds[], uint8_t size)</span><br><span class="line">&#123;</span><br><span class="line">for (uint8_t i = 0 ; i &lt; size; i++)</span><br><span class="line">&#123;</span><br><span class="line">Driver_LED_Off(leds[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td></tr></table></figure>
<h2 id="4-总体架构和时钟系统"><a href="#4-总体架构和时钟系统" class="headerlink" title="4. 总体架构和时钟系统"></a>4. 总体架构和时钟系统</h2><h3 id="1-STM32总体架构"><a href="#1-STM32总体架构" class="headerlink" title="1. STM32总体架构"></a>1. STM32总体架构</h3><h6 id="经过一段时间的学习，我们需要从宏观上了解下它的系统架构，各个模块之间的层级关系以及相"><a href="#经过一段时间的学习，我们需要从宏观上了解下它的系统架构，各个模块之间的层级关系以及相" class="headerlink" title="经过一段时间的学习，我们需要从宏观上了解下它的系统架构，各个模块之间的层级关系以及相"></a>经过一段时间的学习，我们需要从宏观上了解下它的系统架构，各个模块之间的层级关系以及相</h6><h6 id="互的影响。"><a href="#互的影响。" class="headerlink" title="互的影响。"></a>互的影响。</h6><h3 id="2-时钟系统"><a href="#2-时钟系统" class="headerlink" title="2. 时钟系统"></a>2. 时钟系统</h3><h4 id="1-时钟树"><a href="#1-时钟树" class="headerlink" title="1. 时钟树"></a>1. 时钟树</h4><h6 id="在STM32中有-3-种不同的时钟源用来驱动系统时钟-SYSCLK-："><a href="#在STM32中有-3-种不同的时钟源用来驱动系统时钟-SYSCLK-：" class="headerlink" title="在STM32中有 3 种不同的时钟源用来驱动系统时钟(SYSCLK)："></a>在STM32中有 3 种不同的时钟源用来驱动系统时钟(SYSCLK)：</h6><ul>
<li>HSI振荡器时钟（HighSpeedInternaloscillator，高速内部时钟）</li>
<li>HSE振荡器时钟（HighSpeedExternal（Oscillator/Clock），高速外部时钟）</li>
<li>PLL时钟（PhaseLockedLoop锁相环/倍频器）</li>
</ul>
<p>还有 2 种 2 级时钟：</p>
<ul>
<li>LSI时钟（LowSpeedInternal，低速内部时钟）</li>
<li>LSE时钟（LowSpeedExternaloscillator，低速外部时钟）。</li>
</ul>
<p>为什么提供这么多的时钟？ <strong>节能！</strong> 高速设备接高速时钟，低速设备接低速时钟，可以最大程度的达到<br>节能效果。详⻅下图时钟树。</p>
<h6 id="可以看这个简图："><a href="#可以看这个简图：" class="headerlink" title="可以看这个简图："></a>可以看这个简图：</h6><h6 id="该时钟树目前不要求记住，等以后编程时，只需要时不时回头翻看即可。代码写多了，这些知识"><a href="#该时钟树目前不要求记住，等以后编程时，只需要时不时回头翻看即可。代码写多了，这些知识" class="headerlink" title="该时钟树目前不要求记住，等以后编程时，只需要时不时回头翻看即可。代码写多了，这些知识"></a>该时钟树目前不要求记住，等以后编程时，只需要时不时回头翻看即可。代码写多了，这些知识</h6><h6 id="自会烂熟于胸。"><a href="#自会烂熟于胸。" class="headerlink" title="自会烂熟于胸。"></a>自会烂熟于胸。</h6><h4 id="2-各个时钟介绍"><a href="#2-各个时钟介绍" class="headerlink" title="2. 各个时钟介绍"></a>2. 各个时钟介绍</h4><h6 id="1-HSE时钟"><a href="#1-HSE时钟" class="headerlink" title="1. HSE时钟"></a>1. HSE时钟</h6><p>高速外部时钟是由外部时钟源提供，目前几乎所有的STM32单片机的设计都是在外部接一个8MHz<br>的晶振，经过PLL倍频（ 9 倍频）后得到一个72MHz的系统时钟。我们系统默认就是这个时钟。这个在<br>启动文件可以看到。</p>
<h6 id="2-HSI时钟"><a href="#2-HSI时钟" class="headerlink" title="2. HSI时钟"></a>2. HSI时钟</h6><p>HSI时钟信号由内部8MHz的RC振荡器产生，可直接作为系统时钟或在 2 分频后作为PLL输入。HSI<br>RC振荡器能够在不需要任何外部器件的条件下提供系统时钟。它的启动时间比HSE晶体振荡器短。然<br>而，即使在校准之后它的时钟频率 <strong>精度仍较差</strong> 。</p>
<h6 id="3-PLL时钟"><a href="#3-PLL时钟" class="headerlink" title="3. PLL时钟"></a>3. PLL时钟</h6><h6 id="内部PLL用来倍频-HSIRC-的输出时钟或-HSE-晶体输出时钟。PLL的设置必须在其被激活前完成。-一"><a href="#内部PLL用来倍频-HSIRC-的输出时钟或-HSE-晶体输出时钟。PLL的设置必须在其被激活前完成。-一" class="headerlink" title="内部PLL用来倍频 HSIRC 的输出时钟或 HSE 晶体输出时钟。PLL的设置必须在其被激活前完成。 一"></a>内部PLL用来倍频 HSIRC 的输出时钟或 HSE 晶体输出时钟。PLL的设置必须在其被激活前完成。 一</h6><h6 id="旦PLL被激活，这些参数就不能被改动-。如果PLL中断在时钟中断寄存器里被允许，当PLL准备就绪"><a href="#旦PLL被激活，这些参数就不能被改动-。如果PLL中断在时钟中断寄存器里被允许，当PLL准备就绪" class="headerlink" title="旦PLL被激活，这些参数就不能被改动 。如果PLL中断在时钟中断寄存器里被允许，当PLL准备就绪"></a>旦PLL被激活，这些参数就不能被改动 。如果PLL中断在时钟中断寄存器里被允许，当PLL准备就绪</h6><h6 id="时，可产生中断申请。"><a href="#时，可产生中断申请。" class="headerlink" title="时，可产生中断申请。"></a>时，可产生中断申请。</h6><p>PLL时钟一般都是对外部的8MHz的时钟信号经过 9 倍频后，得到72MHz的时钟频率，这是<br>STM32F1系列允许的最高时钟频率。</p>
<h6 id="4-LSE时钟"><a href="#4-LSE时钟" class="headerlink" title="4. LSE时钟"></a>4. LSE时钟</h6><p>LSE晶体是一个32.768kHz的低速外部晶体或陶瓷谐振器。它为实时时钟或者其他定时功能提供一<br>个低功耗且精确的时钟源。</p>
<p>LSE是 <strong>不能驱动系统时钟</strong> 的。</p>
<h6 id="5-LSI时钟"><a href="#5-LSI时钟" class="headerlink" title="5. LSI时钟"></a>5. LSI时钟</h6><h6 id="LSIRC担当一个低功耗时钟源的⻆色，它可以在停机和待机模式下保持运行，为独立看⻔狗和自"><a href="#LSIRC担当一个低功耗时钟源的⻆色，它可以在停机和待机模式下保持运行，为独立看⻔狗和自" class="headerlink" title="LSIRC担当一个低功耗时钟源的⻆色，它可以在停机和待机模式下保持运行，为独立看⻔狗和自"></a>LSIRC担当一个低功耗时钟源的⻆色，它可以在停机和待机模式下保持运行，为独立看⻔狗和自</h6><p>动唤醒单元提供时钟。LSI时钟频率大约40kHz（在30kHz和60kHz之间）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LSI也是 不能驱动系统时钟 的。</span><br></pre></td></tr></table></figure>
<h2 id="5-HAL库开发入⻔"><a href="#5-HAL库开发入⻔" class="headerlink" title="5. HAL库开发入⻔"></a>5. HAL库开发入⻔</h2><h3 id="5-1-HAL介绍"><a href="#5-1-HAL介绍" class="headerlink" title="5.1 HAL介绍"></a>5.1 HAL介绍</h3><h6 id="1-为什么要学习HAL库开发"><a href="#1-为什么要学习HAL库开发" class="headerlink" title="1. 为什么要学习HAL库开发"></a>1. 为什么要学习HAL库开发</h6><h6 id="到目前我们已经学会-1-种开发SMT32程序的姿势：基于寄存器开发。"><a href="#到目前我们已经学会-1-种开发SMT32程序的姿势：基于寄存器开发。" class="headerlink" title="到目前我们已经学会 1 种开发SMT32程序的姿势：基于寄存器开发。"></a>到目前我们已经学会 1 种开发SMT32程序的姿势：基于寄存器开发。</h6><h6 id="寄存器开发效率比较低，在工作中如果想-快速开发-还是要会用到HAL库开发。"><a href="#寄存器开发效率比较低，在工作中如果想-快速开发-还是要会用到HAL库开发。" class="headerlink" title="寄存器开发效率比较低，在工作中如果想 快速开发 还是要会用到HAL库开发。"></a>寄存器开发效率比较低，在工作中如果想 快速开发 还是要会用到HAL库开发。</h6><h6 id="HAL库是目前ST主力推广的开发方式，所以你如果还-要用ST的芯片-，会使用HAL库开发是势在必"><a href="#HAL库是目前ST主力推广的开发方式，所以你如果还-要用ST的芯片-，会使用HAL库开发是势在必" class="headerlink" title="HAL库是目前ST主力推广的开发方式，所以你如果还 要用ST的芯片 ，会使用HAL库开发是势在必"></a>HAL库是目前ST主力推广的开发方式，所以你如果还 要用ST的芯片 ，会使用HAL库开发是势在必</h6><h6 id="行的。而且最最关键的是，使用HAL开发有诸多的好处。"><a href="#行的。而且最最关键的是，使用HAL开发有诸多的好处。" class="headerlink" title="行的。而且最最关键的是，使用HAL开发有诸多的好处。"></a>行的。而且最最关键的是，使用HAL开发有诸多的好处。</h6><h6 id="目前，HAL库已经支持STM32全线产品。"><a href="#目前，HAL库已经支持STM32全线产品。" class="headerlink" title="目前，HAL库已经支持STM32全线产品。"></a>目前，HAL库已经支持STM32全线产品。</h6><h6 id="2-什么是HAL库"><a href="#2-什么是HAL库" class="headerlink" title="2. 什么是HAL库"></a>2. 什么是HAL库</h6><p>HAL库的全称是HardwareAbstractionLayer，翻译成 <strong>硬件抽象层</strong> 。HAL库是ST为STM32最新推<br>出的抽象层嵌入式软件，可以更好的确保跨STM32产品的最大可移植性。该库提供了一整套一致的中<br>间件组件，如RTOS，USB，TCP/IP和图形等。</p>
<p>HAL库是基于一个非限制性的BSD许可协议（BerkeleySoftwareDistribution）而发布的开源代<br>码。ST制作的中间件堆栈（USB主机和设备库，STemWin）带有允许轻松重用的许可模式，只要是在<br>ST公司的MCU芯片上使用，库中的中间件(USB主机/设备库,STemWin)协议栈即被允许随便修改，并<br>可以反复使用。至于基于其它著名的开源解决方案商的中间件（FreeRTOS，F atFs，L wIP和<br>PolarSSL）也都具有友好的用戶许可条款。</p>
<ol>
<li>CMSIS和HAL库的关系<br><strong>CMSIS（CortexMicrocontrollerSoftwareInterfaceStandard）</strong> 是Cortex-M处理器系列的<br>与供应商无关的硬件抽象层。它是ARM公司制定的一个标准。它可以为处理器和外设实现一致且简单<br>的软件接口，从而简化软件的重用、缩短微控制器新开发人员的学习过程，并缩短新设备的上市时<br>间。简单来说，就是ARM公司制定标准，芯片厂商按照此标准编写相应的程序，实现统一的接口，方<br>便开发人员的使用。</li>
</ol>
<h3 id="5-2-HAL库开发环境搭建"><a href="#5-2-HAL库开发环境搭建" class="headerlink" title="5.2 HAL库开发环境搭建"></a>5.2 HAL库开发环境搭建</h3><h4 id="1-安装Java运行环境"><a href="#1-安装Java运行环境" class="headerlink" title="1. 安装Java运行环境"></a>1. 安装Java运行环境</h4><p>STM32CubeMX要求java8的运行环境。下载地址：<br><strong><a target="_blank" rel="noopener" href="https://www.oracle.com/java/technologies/javase/javase8u211-later-archive-">https://www.oracle.com/java/technologies/javase/javase8u211-later-archive-</a><br>downloads.html</strong> </p>
<h4 id="2-安装STM32CubeMX"><a href="#2-安装STM32CubeMX" class="headerlink" title="2. 安装STM32CubeMX"></a>2. 安装STM32CubeMX</h4><h6 id="ST公司提供的一个工具，非常方便的用图形化的方式帮我们创建工程，和完成各种配置。"><a href="#ST公司提供的一个工具，非常方便的用图形化的方式帮我们创建工程，和完成各种配置。" class="headerlink" title="ST公司提供的一个工具，非常方便的用图形化的方式帮我们创建工程，和完成各种配置。"></a>ST公司提供的一个工具，非常方便的用图形化的方式帮我们创建工程，和完成各种配置。</h6><p>下载地址： <strong><a target="_blank" rel="noopener" href="https://www.st.com/zh/development-tools/stm32cubemx.html#get-">https://www.st.com/zh/development-tools/stm32cubemx.html#get-</a><br>software</strong> </p>
<h6 id="双击安装即可。"><a href="#双击安装即可。" class="headerlink" title="双击安装即可。"></a>双击安装即可。</h6><h4 id="3-在线下载芯片支持包"><a href="#3-在线下载芯片支持包" class="headerlink" title="3. 在线下载芯片支持包"></a>3. 在线下载芯片支持包</h4><p>双击 <strong>CubeMX</strong> 进入如下界面。</p>
<h6 id="先安装下软件支持包："><a href="#先安装下软件支持包：" class="headerlink" title="先安装下软件支持包："></a>先安装下软件支持包：</h6><h6 id="点击安装之后，需要先登录你的ST账号，没有就先注册一个。"><a href="#点击安装之后，需要先登录你的ST账号，没有就先注册一个。" class="headerlink" title="点击安装之后，需要先登录你的ST账号，没有就先注册一个。"></a>点击安装之后，需要先登录你的ST账号，没有就先注册一个。</h6><h4 id="4-离线安装芯片支持包"><a href="#4-离线安装芯片支持包" class="headerlink" title="4. 离线安装芯片支持包"></a>4. 离线安装芯片支持包</h4><h6 id="如果网速不好，下载会比较慢。也可以选择离线安装。"><a href="#如果网速不好，下载会比较慢。也可以选择离线安装。" class="headerlink" title="如果网速不好，下载会比较慢。也可以选择离线安装。"></a>如果网速不好，下载会比较慢。也可以选择离线安装。</h6><h6 id="1-下载离线芯片支持包"><a href="#1-下载离线芯片支持包" class="headerlink" title="1. 下载离线芯片支持包"></a>1. 下载离线芯片支持包</h6><p>下载地址： <strong><a target="_blank" rel="noopener" href="https://www.st.com/zh/development-tools/stm32cubemx.html#tools-">https://www.st.com/zh/development-tools/stm32cubemx.html#tools-</a><br>software</strong> </p>
<h6 id="2-导入芯片支持包"><a href="#2-导入芯片支持包" class="headerlink" title="2. 导入芯片支持包"></a>2. 导入芯片支持包</h6><h6 id="注意"><a href="#注意" class="headerlink" title="注意: "></a>注意: </h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 上面的离线安装方式只能安装基础包(en.stm32cubef1.zip),升级包(en.stm32cubef1-v1-8-</span><br><span class="line">5.zip)无法安装. </span><br><span class="line">2. 把en.stm32cubef1-v1-8-5.zip拷⻉到stm32cube的仓库中,直接解压就行了.仓库位置:</span><br><span class="line">C:\Users\你的用戶名\STM32Cube\Repository.用解压的文件覆盖原来的基础包. </span><br></pre></td></tr></table></figure>
<h3 id="3-LED流水灯案例（HAL库）"><a href="#3-LED流水灯案例（HAL库）" class="headerlink" title="3. LED流水灯案例（HAL库）"></a>3. LED流水灯案例（HAL库）</h3><h4 id="3-1-需求描述"><a href="#3-1-需求描述" class="headerlink" title="3.1 需求描述"></a>3.1 需求描述</h4><h6 id="实现LED流水灯。用的GPIOA的0、-1-、-8-口。"><a href="#实现LED流水灯。用的GPIOA的0、-1-、-8-口。" class="headerlink" title="实现LED流水灯。用的GPIOA的0、 1 、 8 口。"></a>实现LED流水灯。用的GPIOA的0、 1 、 8 口。</h6><h4 id="3-2-硬件电路设计"><a href="#3-2-硬件电路设计" class="headerlink" title="3.2 硬件电路设计"></a>3.2 硬件电路设计</h4><h4 id="3-3-软件设计"><a href="#3-3-软件设计" class="headerlink" title="3.3 软件设计"></a>3.3 软件设计</h4><h5 id="1-创建HAL库工程"><a href="#1-创建HAL库工程" class="headerlink" title="1. 创建HAL库工程"></a>1. 创建HAL库工程</h5><h6 id="1-操作⻚面介绍"><a href="#1-操作⻚面介绍" class="headerlink" title="1. 操作⻚面介绍"></a>1. 操作⻚面介绍</h6><h6 id="2-根据需求设置参数"><a href="#2-根据需求设置参数" class="headerlink" title="2. 根据需求设置参数"></a>2. 根据需求设置参数</h6><ul>
<li>Debug参数选择</li>
</ul>
<p>默认debug选项没有设置，需要开启。 <strong>选择串口即可。这个地方务必设置好，否则只能下载一次程序<br>到MCU，以后就无法下载了。</strong> </p>
<ul>
<li>RCC时钟选择</li>
</ul>
<h6 id="3-GPIO配置"><a href="#3-GPIO配置" class="headerlink" title="3. GPIO配置"></a>3. GPIO配置</h6><h6 id="4-配置PA0引脚。"><a href="#4-配置PA0引脚。" class="headerlink" title="4. 配置PA0引脚。"></a>4. 配置PA0引脚。</h6><h6 id="5-同样的方式配置PA1和PA8，然后可以看到这-3-个引脚。"><a href="#5-同样的方式配置PA1和PA8，然后可以看到这-3-个引脚。" class="headerlink" title="5. 同样的方式配置PA1和PA8，然后可以看到这 3 个引脚。"></a>5. 同样的方式配置PA1和PA8，然后可以看到这 3 个引脚。</h6><h6 id="6-分别对他们进行设置。"><a href="#6-分别对他们进行设置。" class="headerlink" title="6. 分别对他们进行设置。"></a>6. 分别对他们进行设置。</h6><h6 id="7-工程配置"><a href="#7-工程配置" class="headerlink" title="7. 工程配置"></a>7. 工程配置</h6><h6 id="8-生成代码"><a href="#8-生成代码" class="headerlink" title="8. 生成代码"></a>8. 生成代码</h6><h6 id="3-生成的工程目录介绍"><a href="#3-生成的工程目录介绍" class="headerlink" title="3. 生成的工程目录介绍"></a>3. 生成的工程目录介绍</h6><h5 id="2-自动生成的代码解读"><a href="#2-自动生成的代码解读" class="headerlink" title="2. 自动生成的代码解读"></a>2. 自动生成的代码解读</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">main 函数中已经替我们调用了HAL的初始化，时钟的初始化，GPIO的初始化。</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">HAL_Init();</span><br><span class="line">SystemClock_Config();</span><br><span class="line">MX_GPIO_Init();</span><br><span class="line">while ( 1 )</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//下面是GPIO初始化的代码。</span><br><span class="line">void MX_GPIO_Init(void)</span><br><span class="line">&#123;</span><br><span class="line">GPIO_InitTypeDef GPIO_InitStruct = &#123; 0 &#125;;</span><br><span class="line">/* GPIO Ports Clock Enable */</span><br><span class="line">__HAL_RCC_GPIOC_CLK_ENABLE();</span><br><span class="line">__HAL_RCC_GPIOA_CLK_ENABLE();</span><br><span class="line">/*Configure GPIO pin Output Level */</span><br><span class="line">HAL_GPIO_WritePin(GPIOA, LED1_Pin | LED2_Pin | LED3_Pin, GPIO_PIN_SET);</span><br><span class="line">/*Configure GPIO pins : PAPin PAPin PAPin */</span><br><span class="line">GPIO_InitStruct.Pin = LED1_Pin | LED2_Pin | LED3_Pin;</span><br><span class="line">GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;</span><br><span class="line">GPIO_InitStruct.Pull = GPIO_NOPULL;</span><br><span class="line">GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;</span><br><span class="line">HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStruct);</span><br><span class="line">&#125;</span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td></tr></table></figure>
<h5 id="3-构建LED驱动"><a href="#3-构建LED驱动" class="headerlink" title="3. 构建LED驱动"></a>3. 构建LED驱动</h5><p>为了方便管理，我们把LED驱动放入单独的文件夹管理。在项目根目录下创建H ardware/led目<br>录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">然后在Hardware/led目录下创建 2 个文件led.h和led.c。</span><br></pre></td></tr></table></figure>
<p>并在Keil中添加如下配置。</p>
<p>3.1 led.h</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#ifndef __led_h</span><br><span class="line">#define __led_h</span><br><span class="line">#include &quot;gpio.h&quot;</span><br><span class="line">#define LED uint16_t</span><br><span class="line">void LED_Turn_On(LED led);</span><br><span class="line">void LED_Turn_Off(LED led);</span><br><span class="line">void LED_Toggle(LED led);</span><br><span class="line">void LED_Turn_Off_All(LED led[], uint8_t len);</span><br><span class="line">#endif</span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td></tr></table></figure>
<p>3.2 led.c</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;led.h&quot;</span><br><span class="line">/**</span><br><span class="line"> * @description: 点亮LED</span><br><span class="line"> * @param &#123;LED&#125; led</span><br><span class="line"> */</span><br><span class="line">void LED_Turn_On(LED led)</span><br><span class="line">&#123;</span><br><span class="line">HAL_GPIO_WritePin(GPIOA, led, GPIO_PIN_RESET);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @description: 熄灭LED</span><br><span class="line"> * @param &#123;LED&#125; led</span><br><span class="line"> */</span><br><span class="line">void LED_Turn_Off(LED led)</span><br><span class="line">&#123;</span><br><span class="line">HAL_GPIO_WritePin(GPIOA, led, GPIO_PIN_SET);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @description: 翻转LED的状态</span><br><span class="line"> * @param &#123;LED&#125; led</span><br><span class="line"> */</span><br><span class="line">void LED_Toggle(LED led)</span><br><span class="line">&#123;</span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">HAL_GPIO_TogglePin(GPIOA, led);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @description: 关闭所有LED</span><br><span class="line"> * @param &#123;LED&#125; led</span><br><span class="line"> * @param &#123;uint8_t&#125; len</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">void LED_Turn_Off_All(LED led[], uint8_t len)</span><br><span class="line">&#123;</span><br><span class="line">uint8_t i;</span><br><span class="line">for (i = 0 ; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">LED_Turn_Off(led[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td></tr></table></figure>
<p>3.3 main函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;LED.h&quot;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">HAL_Init();</span><br><span class="line">SystemClock_Config();</span><br><span class="line">MX_GPIO_Init();</span><br><span class="line">uint16_t leds[] = &#123;LED1_Pin, LED2_Pin, LED3_Pin&#125;;</span><br><span class="line">uint8_t i;</span><br><span class="line">while ( 1 )</span><br><span class="line">&#123;</span><br><span class="line">for (i = 0 ; i &lt; 3 ; i++)</span><br><span class="line">&#123;</span><br><span class="line">LED_Turn_Off_All(leds, 3 );</span><br><span class="line">LED_Turn_On(leds[i]);</span><br><span class="line">HAL_Delay( 200 );</span><br><span class="line">&#125;</span><br><span class="line">for (i = 0 ; i &lt; 3 ; i++)</span><br><span class="line">&#123;</span><br><span class="line">LED_Turn_Off_All(leds, 3 );</span><br><span class="line">LED_Turn_On(leds[ 2 - i]);</span><br><span class="line">HAL_Delay( 200 );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26 &#125;</span><br></pre></td></tr></table></figure>
<h5 id="4-注意"><a href="#4-注意" class="headerlink" title="4. 注意"></a>4. 注意</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每新建一个工程，都需要 重新配置IncludePath和Debug参数 。</span><br></pre></td></tr></table></figure>
<h2 id="6-STM32的中断系统"><a href="#6-STM32的中断系统" class="headerlink" title="6. STM32的中断系统"></a>6. STM32的中断系统</h2><h3 id="1-中断概述"><a href="#1-中断概述" class="headerlink" title="1. 中断概述"></a>1. 中断概述</h3><h4 id="1-中断的概念"><a href="#1-中断的概念" class="headerlink" title="1. 中断的概念"></a>1. 中断的概念</h4><h6 id="在主程序运行过程中，出现了特定事件，使得CPU暂停当前正在运行的程序，转而去处理这个事"><a href="#在主程序运行过程中，出现了特定事件，使得CPU暂停当前正在运行的程序，转而去处理这个事" class="headerlink" title="在主程序运行过程中，出现了特定事件，使得CPU暂停当前正在运行的程序，转而去处理这个事"></a>在主程序运行过程中，出现了特定事件，使得CPU暂停当前正在运行的程序，转而去处理这个事</h6><h6 id="件，等这个事件处理完成之后，CPU再回到刚才被打断的位置继续处理，这就是-中断-。"><a href="#件，等这个事件处理完成之后，CPU再回到刚才被打断的位置继续处理，这就是-中断-。" class="headerlink" title="件，等这个事件处理完成之后，CPU再回到刚才被打断的位置继续处理，这就是 中断 。"></a>件，等这个事件处理完成之后，CPU再回到刚才被打断的位置继续处理，这就是 中断 。</h6><h6 id="在ARM体系结构中，中断通常由外设或外部输入产生，有时也可以由软件触发。中断是单片机系"><a href="#在ARM体系结构中，中断通常由外设或外部输入产生，有时也可以由软件触发。中断是单片机系" class="headerlink" title="在ARM体系结构中，中断通常由外设或外部输入产生，有时也可以由软件触发。中断是单片机系"></a>在ARM体系结构中，中断通常由外设或外部输入产生，有时也可以由软件触发。中断是单片机系</h6><h6 id="统处理紧急或突发事件的重要方式，如定时器溢出、按键输入、串口数据到达等。"><a href="#统处理紧急或突发事件的重要方式，如定时器溢出、按键输入、串口数据到达等。" class="headerlink" title="统处理紧急或突发事件的重要方式，如定时器溢出、按键输入、串口数据到达等。"></a>统处理紧急或突发事件的重要方式，如定时器溢出、按键输入、串口数据到达等。</h6><h6 id="那个打断CPU执行的特定事件，我们一般称之为-中断源-。被中断源打断的位置我们称为-断点-。处"><a href="#那个打断CPU执行的特定事件，我们一般称之为-中断源-。被中断源打断的位置我们称为-断点-。处" class="headerlink" title="那个打断CPU执行的特定事件，我们一般称之为 中断源 。被中断源打断的位置我们称为 断点 。处"></a>那个打断CPU执行的特定事件，我们一般称之为 中断源 。被中断源打断的位置我们称为 断点 。处</h6><h6 id="理特定事件的过程，我们称为执行-中断处理程序-。"><a href="#理特定事件的过程，我们称为执行-中断处理程序-。" class="headerlink" title="理特定事件的过程，我们称为执行 中断处理程序 。"></a>理特定事件的过程，我们称为执行 中断处理程序 。</h6><h6 id="正在执行中断程序的时候，这个时候有可能被另外一个中断源给中断，CPU转而去执行另外一个"><a href="#正在执行中断程序的时候，这个时候有可能被另外一个中断源给中断，CPU转而去执行另外一个" class="headerlink" title="正在执行中断程序的时候，这个时候有可能被另外一个中断源给中断，CPU转而去执行另外一个"></a>正在执行中断程序的时候，这个时候有可能被另外一个中断源给中断，CPU转而去执行另外一个</h6><h6 id="中断源的中断处理程序，这叫-中断嵌套-。"><a href="#中断源的中断处理程序，这叫-中断嵌套-。" class="headerlink" title="中断源的中断处理程序，这叫 中断嵌套 。"></a>中断源的中断处理程序，这叫 中断嵌套 。</h6><h6 id="中断B能否打断中断A，要看他们的优先级，优先级高的可以打断优先级低的，优先级低的无法打断优"><a href="#中断B能否打断中断A，要看他们的优先级，优先级高的可以打断优先级低的，优先级低的无法打断优" class="headerlink" title="中断B能否打断中断A，要看他们的优先级，优先级高的可以打断优先级低的，优先级低的无法打断优"></a>中断B能否打断中断A，要看他们的优先级，优先级高的可以打断优先级低的，优先级低的无法打断优</h6><h6 id="先级高的。"><a href="#先级高的。" class="headerlink" title="先级高的。"></a>先级高的。</h6><h6 id="中断源可以是外部的，也可以是内部的。外部的叫-外部中断源-，内部的叫-内部中断源（有时候也"><a href="#中断源可以是外部的，也可以是内部的。外部的叫-外部中断源-，内部的叫-内部中断源（有时候也" class="headerlink" title="中断源可以是外部的，也可以是内部的。外部的叫 外部中断源 ，内部的叫 内部中断源（有时候也"></a>中断源可以是外部的，也可以是内部的。外部的叫 外部中断源 ，内部的叫 内部中断源（有时候也</h6><h6 id="叫异常）-。"><a href="#叫异常）-。" class="headerlink" title="叫异常） 。"></a>叫异常） 。</h6><h4 id="2-为什么需要中断"><a href="#2-为什么需要中断" class="headerlink" title="2. 为什么需要中断"></a>2. 为什么需要中断</h4><h6 id="对单片机系统来说，-中断至关重要-。"><a href="#对单片机系统来说，-中断至关重要-。" class="headerlink" title="对单片机系统来说， 中断至关重要 。"></a>对单片机系统来说， 中断至关重要 。</h6><h6 id="中断的主要意义在于提高CPU的效率，而不会一直占用CPU，实现对突发事件的实时处理，以及"><a href="#中断的主要意义在于提高CPU的效率，而不会一直占用CPU，实现对突发事件的实时处理，以及" class="headerlink" title="中断的主要意义在于提高CPU的效率，而不会一直占用CPU，实现对突发事件的实时处理，以及"></a>中断的主要意义在于提高CPU的效率，而不会一直占用CPU，实现对突发事件的实时处理，以及</h6><h6 id="实现程序的并行化和嵌入式系统进程之间的切换。相较于轮询方式（即按照一定的频率和周期不断地"><a href="#实现程序的并行化和嵌入式系统进程之间的切换。相较于轮询方式（即按照一定的频率和周期不断地" class="headerlink" title="实现程序的并行化和嵌入式系统进程之间的切换。相较于轮询方式（即按照一定的频率和周期不断地"></a>实现程序的并行化和嵌入式系统进程之间的切换。相较于轮询方式（即按照一定的频率和周期不断地</h6><h6 id="检测某些事件的发生），中断在处理一些偶然发生的事情时效率更高。"><a href="#检测某些事件的发生），中断在处理一些偶然发生的事情时效率更高。" class="headerlink" title="检测某些事件的发生），中断在处理一些偶然发生的事情时效率更高。"></a>检测某些事件的发生），中断在处理一些偶然发生的事情时效率更高。</h6><h6 id="假设我们要检测按键是否按下，如果没有中断，则需要用循环的方式（阻塞）不断的去检测按键"><a href="#假设我们要检测按键是否按下，如果没有中断，则需要用循环的方式（阻塞）不断的去检测按键" class="headerlink" title="假设我们要检测按键是否按下，如果没有中断，则需要用循环的方式（阻塞）不断的去检测按键"></a>假设我们要检测按键是否按下，如果没有中断，则需要用循环的方式（阻塞）不断的去检测按键</h6><h6 id="对应的IO口的电平，这是比较耗费CPU的时间的。如果要检测的更多的话，C-PU有可能会导致阻塞。"><a href="#对应的IO口的电平，这是比较耗费CPU的时间的。如果要检测的更多的话，C-PU有可能会导致阻塞。" class="headerlink" title="对应的IO口的电平，这是比较耗费CPU的时间的。如果要检测的更多的话，C PU有可能会导致阻塞。"></a>对应的IO口的电平，这是比较耗费CPU的时间的。如果要检测的更多的话，C PU有可能会导致阻塞。</h6><h6 id="中断则使这件事简单化-，主程序不需要循环不断的去检测按键，当有按键按下的时候，CPU执行被打"><a href="#中断则使这件事简单化-，主程序不需要循环不断的去检测按键，当有按键按下的时候，CPU执行被打" class="headerlink" title="中断则使这件事简单化 ，主程序不需要循环不断的去检测按键，当有按键按下的时候，CPU执行被打"></a>中断则使这件事简单化 ，主程序不需要循环不断的去检测按键，当有按键按下的时候，CPU执行被打</h6><h6 id="断，去执行按键处理程序就行了。当没有按键按下的时候，CPU完全可以正常执行代码，丝毫不受任"><a href="#断，去执行按键处理程序就行了。当没有按键按下的时候，CPU完全可以正常执行代码，丝毫不受任" class="headerlink" title="断，去执行按键处理程序就行了。当没有按键按下的时候，CPU完全可以正常执行代码，丝毫不受任"></a>断，去执行按键处理程序就行了。当没有按键按下的时候，CPU完全可以正常执行代码，丝毫不受任</h6><h6 id="何的影响。"><a href="#何的影响。" class="headerlink" title="何的影响。"></a>何的影响。</h6><h4 id="3-STM32的中断"><a href="#3-STM32的中断" class="headerlink" title="3. STM32的中断"></a>3. STM32的中断</h4><p>Cortext-M3内核支持 256 个中断，其中包含了 16 个内核中断和 240 个外部中断，并且具有 256 级的<br>可编程中断设置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一般情况下，芯片厂商会对Cortex-M3的中断进行裁剪。</span><br><span class="line">STM32有 84 个中断，包括 16 个内核中断和 68 个可屏蔽中断，具有 16 级可编程的中断优先级。</span><br><span class="line">STM32F103系列 70 个中断（咱们目前使用的芯片）有 10 个内核中断和 60 个可编程的外部中断。</span><br><span class="line">下面的列表中，灰色背景的是内部中断（或者异常），其他的为外部中断。</span><br></pre></td></tr></table></figure>
<h4 id="4-STM32的中断体系架构"><a href="#4-STM32的中断体系架构" class="headerlink" title="4. STM32的中断体系架构"></a>4. STM32的中断体系架构</h4><h6 id="这图已经无敌了！"><a href="#这图已经无敌了！" class="headerlink" title="这图已经无敌了！"></a>这图已经无敌了！</h6><h4 id="5-NVIC嵌套向量中断控制器"><a href="#5-NVIC嵌套向量中断控制器" class="headerlink" title="5. NVIC嵌套向量中断控制器"></a>5. NVIC嵌套向量中断控制器</h4><h5 id="1-NVIC的介绍"><a href="#1-NVIC的介绍" class="headerlink" title="1. NVIC的介绍"></a>1. NVIC的介绍</h5><p><strong>NVIC（Nestedvectoredinterruptcontroller嵌套向量中断控制器）和处理器核的接口紧密相<br>连，可以实现低延迟的中断处理和高效地处理中断。</strong> 嵌套向量中断控制器管理着包括内核异常，外部<br>中断等 <strong>所有中断</strong> 。 <strong>NVIC决定哪个中断的处理程序交给CPU来执行（秘书，大内总管）</strong> 。</p>
<p>每一个外部中断都可以被使能或者禁止，并且可以被设置为挂起状态或者清除状态。处理器的中<br>断可以电平的形式的，也可以是脉冲形式的，这样中断控制器就可以处理任何中断源。</p>
<p>16 个IO的中断与PVD(电源电压检测)，RTC(实时时钟)，USB，以太网检测这2 0个外部中断会通过<br>EXTI来控制，然后交给NVIC。其他中断都是直接交给NVIC来处理。</p>
<p>NVIC提供了灵活、高效、可扩展的中断处理机制，支持多级优先级、多向中断、嵌套向量中断等<br>特性。当一个中断请求到达时，NVIC会确定其优先级并决定是否应该中断当前执行的程序，以便及时<br>响应和处理该中断请求。这种设计有助于提高系统的响应速度和可靠性，特别是在需要处理大量中断<br>请求的实时应用程序中。</p>
<h5 id="2-NVIC原理"><a href="#2-NVIC原理" class="headerlink" title="2. NVIC原理"></a>2. NVIC原理</h5><h6 id="如图："><a href="#如图：" class="headerlink" title="如图："></a>如图：</h6><h5 id="3-中断优先级"><a href="#3-中断优先级" class="headerlink" title="3. 中断优先级"></a>3. 中断优先级</h5><h6 id="NVIC为了方便管理中断，可以通过软件给每个中断设置优先级。NVIC用-4-个位来控制优先级，值"><a href="#NVIC为了方便管理中断，可以通过软件给每个中断设置优先级。NVIC用-4-个位来控制优先级，值" class="headerlink" title="NVIC为了方便管理中断，可以通过软件给每个中断设置优先级。NVIC用 4 个位来控制优先级，值"></a>NVIC为了方便管理中断，可以通过软件给每个中断设置优先级。NVIC用 4 个位来控制优先级，值</h6><h6 id="小的优先级高。把优先级分为两种：抢占优先级和响应优先级。"><a href="#小的优先级高。把优先级分为两种：抢占优先级和响应优先级。" class="headerlink" title="小的优先级高。把优先级分为两种：抢占优先级和响应优先级。"></a>小的优先级高。把优先级分为两种：抢占优先级和响应优先级。</h6><h6 id="规则："><a href="#规则：" class="headerlink" title="规则："></a>规则：</h6><h3 id="◦-优先级值越小，优先级越高。"><a href="#◦-优先级值越小，优先级越高。" class="headerlink" title="◦ 优先级值越小，优先级越高。"></a>◦ 优先级值越小，优先级越高。</h3><h3 id="◦-如果不设置优先级，则默认优先级为-0-。"><a href="#◦-如果不设置优先级，则默认优先级为-0-。" class="headerlink" title="◦ 如果不设置优先级，则默认优先级为^0 。"></a>◦ 如果不设置优先级，则默认优先级为^0 。</h3><h3 id="◦-先比较抢占优先级。抢占优先级高的可以打断抢占优先级低的。"><a href="#◦-先比较抢占优先级。抢占优先级高的可以打断抢占优先级低的。" class="headerlink" title="◦ 先比较抢占优先级。抢占优先级高的可以打断抢占优先级低的。"></a>◦ 先比较抢占优先级。抢占优先级高的可以打断抢占优先级低的。</h3><h3 id="◦-若抢占优先级一样，再比较响应优先级。-但是响应优先级不会导致中断嵌套。"><a href="#◦-若抢占优先级一样，再比较响应优先级。-但是响应优先级不会导致中断嵌套。" class="headerlink" title="◦ 若抢占优先级一样，再比较响应优先级。 但是响应优先级不会导致中断嵌套。"></a>◦ 若抢占优先级一样，再比较响应优先级。 但是响应优先级不会导致中断嵌套。</h3><h3 id="◦-若-抢占优先级一样-的同时挂起，则优先处理-响应抢占优先级高-的。"><a href="#◦-若-抢占优先级一样-的同时挂起，则优先处理-响应抢占优先级高-的。" class="headerlink" title="◦ 若 抢占优先级一样 的同时挂起，则优先处理 响应抢占优先级高 的。"></a>◦ 若 抢占优先级一样 的同时挂起，则优先处理 响应抢占优先级高 的。</h3><h3 id="◦-若挂起的优先级（抢占和响应）都一样，则查找中断向量表，值小的先响应（看自然优先级优"><a href="#◦-若挂起的优先级（抢占和响应）都一样，则查找中断向量表，值小的先响应（看自然优先级优" class="headerlink" title="◦ 若挂起的优先级（抢占和响应）都一样，则查找中断向量表，值小的先响应（看自然优先级优"></a>◦ 若挂起的优先级（抢占和响应）都一样，则查找中断向量表，值小的先响应（看自然优先级优</h3><h6 id="先级）。"><a href="#先级）。" class="headerlink" title="先级）。"></a>先级）。</h6><h3 id="◦-NVIC对优先级分了-5-组，在程序中先对中断进行分组，优先级寄存器IPR有8位，但实际只使用"><a href="#◦-NVIC对优先级分了-5-组，在程序中先对中断进行分组，优先级寄存器IPR有8位，但实际只使用" class="headerlink" title="◦ NVIC对优先级分了^5 组，在程序中先对中断进行分组，优先级寄存器IPR有8位，但实际只使用"></a>◦ NVIC对优先级分了^5 组，在程序中先对中断进行分组，优先级寄存器IPR有8位，但实际只使用</h3><h6 id="到高4位，用于决定抢占优先级、响应优先级的等级。"><a href="#到高4位，用于决定抢占优先级、响应优先级的等级。" class="headerlink" title="到高4位，用于决定抢占优先级、响应优先级的等级。"></a>到高4位，用于决定抢占优先级、响应优先级的等级。</h6><h3 id="◦-具体这4位如何切割？由又由AIRCR寄存器控制，而且分组只能分一次，若多次分，只有最后"><a href="#◦-具体这4位如何切割？由又由AIRCR寄存器控制，而且分组只能分一次，若多次分，只有最后" class="headerlink" title="◦ 具体这4位如何切割？由又由AIRCR寄存器控制，而且分组只能分一次，若多次分，只有最后"></a>◦ 具体这4位如何切割？由又由AIRCR寄存器控制，而且分组只能分一次，若多次分，只有最后</h3><h6 id="一次生效。"><a href="#一次生效。" class="headerlink" title="一次生效。"></a>一次生效。</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">分组 抢占优先级 响应优先级</span><br><span class="line">0  0 位取值范围： 0  4 位取值范围：0-15</span><br><span class="line">1  1 位取值范围：0-1 3 位取值范围：0-7</span><br><span class="line">2  2 位取值范围：0-3 2 位取值范围：0-3</span><br><span class="line">3  3 位取值范围：0-7 1 位取值范围：0-1</span><br><span class="line">4  4 位取值范围：0-15 0 位取值范围： 0 </span><br><span class="line">抢占优先级和子优先级可通过CubeMX配置。</span><br></pre></td></tr></table></figure>
<h5 id="4-NVIC常用寄存器"><a href="#4-NVIC常用寄存器" class="headerlink" title="4. NVIC常用寄存器"></a>4. NVIC常用寄存器</h5><h6 id="如图：-1"><a href="#如图：-1" class="headerlink" title="如图："></a>如图：</h6><h5 id="5-NVIC配置思路"><a href="#5-NVIC配置思路" class="headerlink" title="5. NVIC配置思路"></a>5. NVIC配置思路</h5><h6 id="设置中断分组→设置中断优先级→使能中断"><a href="#设置中断分组→设置中断优先级→使能中断" class="headerlink" title="设置中断分组→设置中断优先级→使能中断 "></a>设置中断分组→设置中断优先级→使能中断 </h6><h4 id="6-中断向量表"><a href="#6-中断向量表" class="headerlink" title="6. 中断向量表"></a>6. 中断向量表</h4><p><strong>STM32的中断向量表是一个存储中断处理函数地址的数组，位于Flash区的起始位置。</strong> 每个数组<br>元素对应一个中断源，其地址指向相应的中断服务程序。当中断发生时，处理器会根据中断号查找向<br>量表，然后跳转到对应的中断服务程序执行。</p>
<p>中断向量表的主要作用是解决中断函数地址不固定与中断必须跳转到固定地方执行程序之间的矛<br>盾。由于编译器每次编译都会为中断函数随机分配地址，但硬件要求中断必须跳转到固定的位置。</p>
<p>因此，中断向量表就作为这样一个固定的地址列表，其中包含了中断函数的地址以及跳转到这些<br>地址的程序。当中断发生时，处理器会跳转到这个固定的中断向量表，然后根据其中的信息跳转到相<br>应的中断处理函数，从而执行中断。</p>
<h4 id="🎼-注意："><a href="#🎼-注意：" class="headerlink" title="🎼 注意："></a>🎼 注意：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NVIC（NestedVectoredInterruptController） 和 中断向量表 不是一回事。NVIC是处</span><br><span class="line">理器中的一个组件，负责管理和响应中断请求，包括优先级和中断的嵌套处理。中断向量表</span><br><span class="line">则是一个存储中断服务程序（ISR）地址的表格，当中断发生时，NVIC使用这个表来找到对</span><br><span class="line">应的ISR。它们配合工作，NVIC通过中断向量表来确定应执行哪个中断处理程序。</span><br></pre></td></tr></table></figure>
<h4 id="7-中断执行流程"><a href="#7-中断执行流程" class="headerlink" title="7. 中断执行流程"></a>7. 中断执行流程</h4><h6 id="中断发生时，STM32的执行流程如下："><a href="#中断发生时，STM32的执行流程如下：" class="headerlink" title="中断发生时，STM32的执行流程如下："></a>中断发生时，STM32的执行流程如下：</h6><h6 id="首先，由外设发出中断请求；然后，处理器暂停当前执行的任务，保护现场（如将当前位置的PC"><a href="#首先，由外设发出中断请求；然后，处理器暂停当前执行的任务，保护现场（如将当前位置的PC" class="headerlink" title="首先，由外设发出中断请求；然后，处理器暂停当前执行的任务，保护现场（如将当前位置的PC"></a>首先，由外设发出中断请求；然后，处理器暂停当前执行的任务，保护现场（如将当前位置的PC</h6><h6 id="地址压栈）；接着，程序跳转到对应的中断服务程序（ISR）并执行；中断服务程序执行完毕后，恢复"><a href="#地址压栈）；接着，程序跳转到对应的中断服务程序（ISR）并执行；中断服务程序执行完毕后，恢复" class="headerlink" title="地址压栈）；接着，程序跳转到对应的中断服务程序（ISR）并执行；中断服务程序执行完毕后，恢复"></a>地址压栈）；接着，程序跳转到对应的中断服务程序（ISR）并执行；中断服务程序执行完毕后，恢复</h6><h6 id="现场（如将栈顶的值送回PC）；最后，处理器返回到被中断的位置，继续执行下一个指令。"><a href="#现场（如将栈顶的值送回PC）；最后，处理器返回到被中断的位置，继续执行下一个指令。" class="headerlink" title="现场（如将栈顶的值送回PC）；最后，处理器返回到被中断的位置，继续执行下一个指令。"></a>现场（如将栈顶的值送回PC）；最后，处理器返回到被中断的位置，继续执行下一个指令。</h6><h3 id="2-中断案例：检测按键按下"><a href="#2-中断案例：检测按键按下" class="headerlink" title="2. 中断案例：检测按键按下"></a>2. 中断案例：检测按键按下</h3><h4 id="1-需求描述-2"><a href="#1-需求描述-2" class="headerlink" title="1. 需求描述"></a>1. 需求描述</h4><h6 id="利用外部中断检测按键KEY3，当按键按下，翻转LED1显示。"><a href="#利用外部中断检测按键KEY3，当按键按下，翻转LED1显示。" class="headerlink" title="利用外部中断检测按键KEY3，当按键按下，翻转LED1显示。"></a>利用外部中断检测按键KEY3，当按键按下，翻转LED1显示。</h6><h4 id="2-硬件电路设计-2"><a href="#2-硬件电路设计-2" class="headerlink" title="2. 硬件电路设计"></a>2. 硬件电路设计</h4><h5 id="1-LED1的硬件电路"><a href="#1-LED1的硬件电路" class="headerlink" title="1. LED1的硬件电路"></a>1. LED1的硬件电路</h5><h5 id="2-KEY的硬件电路"><a href="#2-KEY的硬件电路" class="headerlink" title="2. KEY的硬件电路"></a>2. KEY的硬件电路</h5><h6 id="说明：-1"><a href="#说明：-1" class="headerlink" title="说明："></a>说明：</h6><h6 id="1-PF10对应的是KEY-3-SW3-我们可以设置PF10的模式为-下拉输入-，则当按键没有按下的时候是低"><a href="#1-PF10对应的是KEY-3-SW3-我们可以设置PF10的模式为-下拉输入-，则当按键没有按下的时候是低" class="headerlink" title="1. PF10对应的是KEY_3(SW3),我们可以设置PF10的模式为 下拉输入 ，则当按键没有按下的时候是低"></a>1. PF10对应的是KEY_3(SW3),我们可以设置PF10的模式为 下拉输入 ，则当按键没有按下的时候是低</h6><h6 id="电平，当按键按下的时候是高电平。"><a href="#电平，当按键按下的时候是高电平。" class="headerlink" title="电平，当按键按下的时候是高电平。"></a>电平，当按键按下的时候是高电平。</h6><ol>
<li>由于按键没有设置硬件防抖，则我们需要软件设计防抖。一般延时10-15ms即可实现软件防抖。</li>
</ol>
<h4 id="3-软件设计（寄存器）-1"><a href="#3-软件设计（寄存器）-1" class="headerlink" title="3. 软件设计（寄存器）"></a>3. 软件设计（寄存器）</h4><h6 id="复制我们第一个项目，在第一个项目的基础上修改，可以省去一些配置步骤。"><a href="#复制我们第一个项目，在第一个项目的基础上修改，可以省去一些配置步骤。" class="headerlink" title="复制我们第一个项目，在第一个项目的基础上修改，可以省去一些配置步骤。"></a>复制我们第一个项目，在第一个项目的基础上修改，可以省去一些配置步骤。</h6><h6 id="另外文件如何创建以后不再说明。"><a href="#另外文件如何创建以后不再说明。" class="headerlink" title="另外文件如何创建以后不再说明。"></a>另外文件如何创建以后不再说明。</h6><h5 id="3-1-main-c"><a href="#3-1-main-c" class="headerlink" title="3.1 main.c"></a>3.1 main.c</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Driver_LED.h&quot;</span><br><span class="line">#include &quot;Delay.h&quot;</span><br><span class="line">#include &quot;Driver_Key.h&quot;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">/* 1. 初始化LED */</span><br><span class="line">Driver_LED_Init();</span><br><span class="line">/* 2. 初始化按键 */</span><br><span class="line">Driver_Key_Init();</span><br><span class="line">while ( 1 )</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td></tr></table></figure>
<h5 id="3-2-Delay-h"><a href="#3-2-Delay-h" class="headerlink" title="3.2 Delay.h"></a>3.2 Delay.h</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#ifndef __delay_h</span><br><span class="line">#define __delay_h</span><br><span class="line">#include &quot;stm32f10x.h&quot; // Device header</span><br><span class="line">void Delay_us(uint16_t us);</span><br><span class="line">void Delay_ms(uint16_t ms);</span><br><span class="line">void Delay_s(uint16_t s);</span><br><span class="line">#endif</span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure>
<h5 id="3-3-Delay-c"><a href="#3-3-Delay-c" class="headerlink" title="3.3 Delay.c"></a>3.3 Delay.c</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;delay.h&quot; // Device header</span><br><span class="line">void Delay_us(uint16_t us)</span><br><span class="line">&#123;</span><br><span class="line">/* 定时器重装值 */</span><br><span class="line">SysTick-&gt;LOAD = 72 * us;</span><br><span class="line">/* 清除当前计数值 */</span><br><span class="line">SysTick-&gt;VAL = 0 ;</span><br><span class="line">/*设置内部时钟源（ 2 位-&gt;1）,不需要中断（ 1 位-&gt;0），并启动定时器(0位-&gt;1)*/</span><br><span class="line">SysTick-&gt;CTRL = 0x5;</span><br><span class="line">/*等待计数到 0 ， 如果计数到 0 则 16 位会置为1*/</span><br><span class="line">while (!(SysTick-&gt;CTRL &amp; SysTick_CTRL_COUNTFLAG));</span><br><span class="line">/* 关闭定时器 */</span><br><span class="line">SysTick-&gt;CTRL &amp;= ~SysTick_CTRL_ENABLE;</span><br><span class="line">&#125;</span><br><span class="line">void Delay_ms(uint16_t ms)</span><br><span class="line">&#123;</span><br><span class="line">while (ms--)</span><br><span class="line">&#123;</span><br><span class="line">Delay_us( 1000 );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void Delay_s(uint16_t s)</span><br><span class="line">&#123;</span><br><span class="line">while (s--)</span><br><span class="line">&#123;</span><br><span class="line">Delay_ms( 1000 );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td></tr></table></figure>
<h5 id="3-4-Driver-LED-h"><a href="#3-4-Driver-LED-h" class="headerlink" title="3.4 Driver_LED.h"></a>3.4 Driver_LED.h</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#ifndef __DRIVER_LED_H</span><br><span class="line">#define __DRIVER_LED_H</span><br><span class="line">#include &quot;stm32f10x.h&quot;</span><br><span class="line">#define LED_1 GPIO_ODR_ODR0</span><br><span class="line">1 2 3 4 5 6</span><br><span class="line">#define LED_2 GPIO_ODR_ODR1</span><br><span class="line">#define LED_3 GPIO_ODR_ODR8</span><br><span class="line">void Driver_LED_Init(void);</span><br><span class="line">void Driver_LED_On(uint32_t led);</span><br><span class="line">void Driver_LED_Off(uint32_t led);</span><br><span class="line">void Driver_LED_Toggle(uint32_t led);</span><br><span class="line">void Driver_LED_OnAll(uint32_t leds[], uint8_t size);</span><br><span class="line">void Driver_LED_OffAll(uint32_t leds[], uint8_t size);</span><br><span class="line">#endif</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td></tr></table></figure>
<h5 id="3-5-Driver-LED-c"><a href="#3-5-Driver-LED-c" class="headerlink" title="3.5 Driver_LED.c"></a>3.5 Driver_LED.c</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Driver_LED.h&quot;</span><br><span class="line">/**</span><br><span class="line"> * @description: 对LED进行初始化</span><br><span class="line"> */</span><br><span class="line">void Driver_LED_Init(void)</span><br><span class="line">&#123;</span><br><span class="line">/* 1. 打开GPIOA的时钟 */</span><br><span class="line">RCC-&gt;APB2ENR |= RCC_APB2ENR_IOPAEN;</span><br><span class="line">/* 2. 给用到的端口的所有 PIN (PA0 PA1 PA8) 设置工作模式: 通用推挽输出 MODE:11</span><br><span class="line"> CNF:00 */</span><br><span class="line">GPIOA-&gt;CRL |= (GPIO_CRL_MODE0 | GPIO_CRL_MODE1);</span><br><span class="line">GPIOA-&gt;CRL &amp;= ~(GPIO_CRL_CNF0 | GPIO_CRL_CNF1);</span><br><span class="line">GPIOA-&gt;CRH |= GPIO_CRH_MODE8;</span><br><span class="line">GPIOA-&gt;CRH &amp;= ~GPIO_CRH_CNF8;</span><br><span class="line">/* 3. 关闭所有灯  */</span><br><span class="line">Driver_LED_Off(LED_1);</span><br><span class="line">Driver_LED_Off(LED_2);</span><br><span class="line">Driver_LED_Off(LED_3);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @description: 点亮指定的LED</span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line"> * @param &#123;uint32_t&#125; led 要点亮的LED</span><br><span class="line"> */</span><br><span class="line">void Driver_LED_On(uint32_t led)</span><br><span class="line">&#123;</span><br><span class="line">GPIOA-&gt;ODR &amp;= ~led;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @description: 关闭指定的LED</span><br><span class="line"> * @param &#123;uint32_t&#125; led 要关闭的LED</span><br><span class="line"> */</span><br><span class="line">void Driver_LED_Off(uint32_t led)</span><br><span class="line">&#123;</span><br><span class="line">GPIOA-&gt;ODR |= led;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @description: 翻转LED的状态</span><br><span class="line"> * @param &#123;uint32_t&#125; led 要翻转的LED</span><br><span class="line"> */</span><br><span class="line">void Driver_LED_Toggle(uint32_t led)</span><br><span class="line">&#123;</span><br><span class="line">/* 1. 读取引脚的电平,如果是1(目前是关闭), 打开, 否则就关闭 */</span><br><span class="line">if ((GPIOA-&gt;IDR &amp; led) == 0 )</span><br><span class="line">&#123;</span><br><span class="line">Driver_LED_Off(led);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">Driver_LED_On(led);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @description: 打开数组中所有的灯</span><br><span class="line"> * @param &#123;uint32_t&#125; leds 所有灯</span><br><span class="line"> * @param &#123;uint8_t&#125; size 灯的个数</span><br><span class="line"> */</span><br><span class="line">void Driver_LED_OnAll(uint32_t leds[], uint8_t size)</span><br><span class="line">&#123;</span><br><span class="line">for (uint8_t i = 0 ; i &lt; size; i++)</span><br><span class="line">&#123;</span><br><span class="line">Driver_LED_On(leds[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br></pre></td></tr></table></figure>
<p>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> * @description: 关闭数组中所有的灯</span><br><span class="line"> * @param &#123;uint32_t&#125; leds 所有灯</span><br><span class="line"> * @param &#123;uint8_t&#125; size 灯的个数</span><br><span class="line"> */</span><br><span class="line">void Driver_LED_OffAll(uint32_t leds[], uint8_t size)</span><br><span class="line">&#123;</span><br><span class="line">for (uint8_t i = 0 ; i &lt; size; i++)</span><br><span class="line">&#123;</span><br><span class="line">Driver_LED_Off(leds[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td></tr></table></figure>
<h5 id="3-6-Driver-Key-h"><a href="#3-6-Driver-Key-h" class="headerlink" title="3.6 Driver_Key.h"></a>3.6 Driver_Key.h</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#ifndef __DRIVER_KEY_H</span><br><span class="line">#define __DRIVER_KEY_H</span><br><span class="line">#include &quot;stm32f10x.h&quot;</span><br><span class="line">void Driver_Key_Init(void);</span><br><span class="line">#endif</span><br><span class="line">1 2 3 4 5 6 7</span><br></pre></td></tr></table></figure>
<h5 id="3-7-Driver-Key-c"><a href="#3-7-Driver-Key-c" class="headerlink" title="3.7 Driver_Key.c"></a>3.7 Driver_Key.c</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Driver_Key.&quot;</span><br><span class="line">#include &quot;Driver_LED.h&quot;</span><br><span class="line">#include &quot;Delay.h&quot;</span><br><span class="line">/**</span><br><span class="line"> * @description: 初始化按键.</span><br><span class="line"> *  1. 给按键对应的io口设置工作模式: 下拉输入</span><br><span class="line"> *  2. 配置复用为外部中断</span><br><span class="line"> *  3. 配置外部中断控制器 EXTI</span><br><span class="line"> *  4. 配置NVIC</span><br><span class="line"> */</span><br><span class="line">void Driver_Key_Init(void)</span><br><span class="line">&#123;</span><br><span class="line">/* 1. 开启时钟 */</span><br><span class="line">/* 1.1  GPIOF*/</span><br><span class="line">RCC-&gt;APB2ENR |= RCC_APB2ENR_IOPFEN;</span><br><span class="line">/* 1.2  AFIO*/</span><br><span class="line">RCC-&gt;APB2ENR |= RCC_APB2ENR_AFIOEN;</span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">/* 2. 配置 PF10为下拉输入: MODE=00 CNF=10  ODR=0 */</span><br><span class="line">GPIOF-&gt;CRH &amp;= ~GPIO_CRH_MODE10;</span><br><span class="line">GPIOF-&gt;CRH |= GPIO_CRH_CNF10_1;</span><br><span class="line">GPIOF-&gt;CRH &amp;= ~GPIO_CRH_CNF10_0;</span><br><span class="line">GPIOF-&gt;ODR &amp;= ~GPIO_ODR_ODR10;/* ODR为 0 下拉输入 ODR为 1 上拉输入 */</span><br><span class="line">/* 3. 配置AFIO 配置PF10引脚为外部中断  EXTICR3  0101 */</span><br><span class="line">AFIO-&gt;EXTICR[ 2 ] &amp;= ~AFIO_EXTICR3_EXTI10;</span><br><span class="line">AFIO-&gt;EXTICR[ 2 ] |= AFIO_EXTICR3_EXTI10_PF;</span><br><span class="line">/* 使用AFIO配置寄存器（AFIO-&gt;EXTICR[2]）将PF10引脚映射到外部中断线 10 （EXTI10）。</span><br><span class="line">*/</span><br><span class="line">/* 4. 配置EXTI */</span><br><span class="line">/* 4.1. 配置上升沿触发 RTSR TR10=1*/</span><br><span class="line">EXTI-&gt;RTSR |= EXTI_RTSR_TR10;</span><br><span class="line">/* 4.2 开启 LINE10, 配置的中断屏蔽寄存器 */</span><br><span class="line">EXTI-&gt;IMR |= EXTI_IMR_MR10;</span><br><span class="line">/* 5. 配置 NVIC */</span><br><span class="line">/* 5.1 配置优先级组 (3-7) 配置 3 表示 4 个二进制位全部用于表示抢占优先级*/</span><br><span class="line">NVIC_SetPriorityGrouping( 3 );</span><br><span class="line">/* 5.2 配置优先级 参数1:中断号*/</span><br><span class="line">NVIC_SetPriority(EXTI15_10_IRQn, 3 );</span><br><span class="line">/* 5.3 使能Line10 */</span><br><span class="line">NVIC_EnableIRQ(EXTI15_10_IRQn);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @description: line 15-10的中断服务函数.</span><br><span class="line"> *  一旦按键下按键1,则会执行一次这个函数</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">void EXTI15_10_IRQHandler(void)</span><br><span class="line">&#123;</span><br><span class="line">/* 务必一定必须要清除中断标志位 */</span><br><span class="line">EXTI-&gt;PR |= EXTI_PR_PR10;</span><br><span class="line">Delay_ms( 5 );/* 务必一定必须要清除中断标志位 */</span><br><span class="line">if ((GPIOF-&gt;IDR &amp; GPIO_IDR_IDR10) != 0 )</span><br><span class="line">&#123;</span><br><span class="line">Driver_LED_Toggle(LED_1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30</p>
<p>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65</p>
<h4 id="4-思考"><a href="#4-思考" class="headerlink" title="4. 思考"></a>4. 思考</h4><p>**为啥LED翻转电平这个函数的if条件判断必须要用if((GPIOA-&gt;IDR&amp;led)== 0 )，而不是if((GPIOA-</p>
<blockquote>
<p>IDR&amp;led)==1)？** </p>
</blockquote>
<p>举个例子：</p>
<p><strong>假设led是一个位掩码</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define LED1 (1 &lt;&lt; 0) // LED1对应GPIOA的第 0 位</span><br><span class="line">#define LED2 (1 &lt;&lt; 1) // LED2对应GPIOA的第 1 位</span><br><span class="line">// 可能还有其他LED定义...</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<h4 id="🎁"><a href="#🎁" class="headerlink" title="🎁"></a>🎁</h4><h6 id="而GPIOA-gt-IDR是一个输入数据寄存器，其中的每一位对应一个特定的输入引脚的状态（通"><a href="#而GPIOA-gt-IDR是一个输入数据寄存器，其中的每一位对应一个特定的输入引脚的状态（通" class="headerlink" title="而GPIOA-&gt;IDR是一个输入数据寄存器，其中的每一位对应一个特定的输入引脚的状态（通"></a>而GPIOA-&gt;IDR是一个输入数据寄存器，其中的每一位对应一个特定的输入引脚的状态（通</h6><h6 id="常是-0-或-1-）。"><a href="#常是-0-或-1-）。" class="headerlink" title="常是 0 或 1 ）。 "></a>常是 0 或 1 ）。 </h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">现在假设GPIOA-&gt;IDR的值是0b00000011，即第 0 位和第 1 位都为 1 。如果我们使用位掩码</span><br><span class="line">led=LED1|LED2，即led=(1&lt;&lt;0)|(1&lt;&lt;1)，那么led的值将是0b00000011。 </span><br><span class="line">现在来看(GPIOA-&gt;IDR&amp;led)的计算： </span><br><span class="line">因此，(GPIOA-&gt;IDR&amp;led)的结果将是0b00000011，而不是单纯的 1 。 </span><br><span class="line">如果条件语句是if((GPIOA-&gt;IDR&amp;led)==1)，那么(GPIOA-&gt;IDR&amp;led)的值是</span><br><span class="line">0b00000011，显然不等于 1 ，因此条件将不会成立，这可能与预期的逻辑相悖。 </span><br><span class="line">因此， if((GPIOA-&gt;IDR&amp;led)== 0 )是正解！ </span><br></pre></td></tr></table></figure>
<h4 id="5-软件设计（HAL库）"><a href="#5-软件设计（HAL库）" class="headerlink" title="5. 软件设计（HAL库）"></a>5. 软件设计（HAL库）</h4><h5 id="1-STM32CubeMX配置"><a href="#1-STM32CubeMX配置" class="headerlink" title="1. STM32CubeMX配置"></a>1. STM32CubeMX配置</h5><h6 id="配置LED1的PA0引脚。"><a href="#配置LED1的PA0引脚。" class="headerlink" title="配置LED1的PA0引脚。"></a>配置LED1的PA0引脚。</h6><h6 id="调整滴答定时器和外部中断的优先级。否则使用延时消抖会卡死。"><a href="#调整滴答定时器和外部中断的优先级。否则使用延时消抖会卡死。" class="headerlink" title="调整滴答定时器和外部中断的优先级。否则使用延时消抖会卡死。"></a>调整滴答定时器和外部中断的优先级。否则使用延时消抖会卡死。</h6><h5 id="2-GPIO初始化代码"><a href="#2-GPIO初始化代码" class="headerlink" title="2. GPIO初始化代码"></a>2. GPIO初始化代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">void MX_GPIO_Init(void)</span><br><span class="line">&#123;</span><br><span class="line">GPIO_InitTypeDef GPIO_InitStruct = &#123; 0 &#125;;</span><br><span class="line">/* GPIO Ports Clock Enable */</span><br><span class="line">__HAL_RCC_GPIOE_CLK_ENABLE();</span><br><span class="line">__HAL_RCC_GPIOC_CLK_ENABLE();</span><br><span class="line">__HAL_RCC_GPIOG_CLK_ENABLE();</span><br><span class="line">__HAL_RCC_GPIOA_CLK_ENABLE();</span><br><span class="line">/*Configure GPIO pin Output Level */</span><br><span class="line">HAL_GPIO_WritePin(GPIOE, GPIO_PIN_3, GPIO_PIN_SET);</span><br><span class="line">/*Configure GPIO pin : PE3 */</span><br><span class="line">GPIO_InitStruct.Pin = GPIO_PIN_3;</span><br><span class="line">GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;</span><br><span class="line">GPIO_InitStruct.Pull = GPIO_NOPULL;</span><br><span class="line">GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;</span><br><span class="line">HAL_GPIO_Init(GPIOE, &amp;GPIO_InitStruct);</span><br><span class="line">/*Configure GPIO pin : PG6 */</span><br><span class="line">GPIO_InitStruct.Pin = GPIO_PIN_6;</span><br><span class="line">GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;</span><br><span class="line">GPIO_InitStruct.Pull = GPIO_PULLDOWN;</span><br><span class="line">HAL_GPIO_Init(GPIOG, &amp;GPIO_InitStruct);</span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">/* EXTI interrupt init*/</span><br><span class="line">HAL_NVIC_SetPriority(EXTI9_5_IRQn, 0 , 0 );</span><br><span class="line">HAL_NVIC_EnableIRQ(EXTI9_5_IRQn);</span><br><span class="line">&#125;</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td></tr></table></figure>
<h5 id="3-添加中断处理函数"><a href="#3-添加中断处理函数" class="headerlink" title="3. 添加中断处理函数"></a>3. 添加中断处理函数</h5><p>当有按键按下的时候，检测到上升沿会执行中断服务函数：EXTI15_10_IRQHandler，内部又会调<br>用HAL库总的外部中断处理函数HAL_GPIO_EXTI_IRQHandler，然后会调用中断回调函数<br>HAL_GPIO_EXTI_Callback，它是一个 <strong>弱实现函数</strong> （用 <strong>__weak</strong> 修饰，如果有新的同名函数实现，则执<br>行时会自动调用新的实现函数），我们重新实现这个函数就可以了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">void EXTI15_10_IRQHandler(void)</span><br><span class="line">&#123;</span><br><span class="line">/* USER CODE BEGIN EXTI15_10_IRQn 0 */</span><br><span class="line">/* USER CODE END EXTI15_10_IRQn 0 */</span><br><span class="line">HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_10);</span><br><span class="line">/* USER CODE BEGIN EXTI15_10_IRQn 1 */</span><br><span class="line">/* USER CODE END EXTI15_10_IRQn 1 */</span><br><span class="line">&#125;</span><br><span class="line">void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)</span><br><span class="line">&#123;</span><br><span class="line">/* EXTI line interrupt detected */</span><br><span class="line">if (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != 0x00u)</span><br><span class="line">&#123;</span><br><span class="line">__HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);</span><br><span class="line">HAL_GPIO_EXTI_Callback(GPIO_Pin);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">__weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)</span><br><span class="line">&#123;</span><br><span class="line">/* Prevent unused argument(s) compilation warning */</span><br><span class="line">UNUSED(GPIO_Pin);</span><br><span class="line">/* NOTE: This function Should not be modified, when the callback is needed,</span><br><span class="line"> the HAL_GPIO_EXTI_Callback could be implemented in the user file</span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">*/</span><br><span class="line">&#125;</span><br><span class="line">//在gpio.c中实现中断回调函数即可。</span><br><span class="line">/* USER CODE BEGIN 2 */</span><br><span class="line">void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)</span><br><span class="line">&#123;</span><br><span class="line">if (GPIO_Pin == GPIO_PIN_10)</span><br><span class="line">&#123;</span><br><span class="line">HAL_Delay( 15 );//调整一下SYSTick的优先级，其默认是最低的！</span><br><span class="line">// 防抖： 延迟15ms之后再次检测是否仍然是高电平，</span><br><span class="line">if (HAL_GPIO_ReadPin(GPIOF, GPIO_Pin) == GPIO_PIN_SET)</span><br><span class="line">&#123;</span><br><span class="line">HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_0);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/* USER CODE END 2 */</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td></tr></table></figure>
<h2 id="7-USART串口通讯"><a href="#7-USART串口通讯" class="headerlink" title="7. USART串口通讯"></a>7. USART串口通讯</h2><h3 id="1-通讯基础知识"><a href="#1-通讯基础知识" class="headerlink" title="1. 通讯基础知识"></a>1. 通讯基础知识</h3><h4 id="1-串口介绍"><a href="#1-串口介绍" class="headerlink" title="1. 串口介绍"></a>1. 串口介绍</h4><p>串口通讯（SerialCommunication）是一种设备间非常常用的串行通讯方式，因为它简单便捷，<br>因此大部分电子设备都支持该通讯方式，电子工程师在调试设备时也经常使用该通讯方式输出调试信<br>息。</p>
<h4 id="2-串口通讯协议"><a href="#2-串口通讯协议" class="headerlink" title="2. 串口通讯协议"></a>2. 串口通讯协议</h4><h6 id="六个重点："><a href="#六个重点：" class="headerlink" title="六个重点："></a>六个重点：</h6><h6 id="1-波特率"><a href="#1-波特率" class="headerlink" title="1. 波特率"></a>1. 波特率</h6><p><strong>”波特“（Baudrate），它表示每秒钟传输了多少个码元。在二进制的世界码元和位是等价的。<br>用每秒传输的比特数表示波特率。</strong></p>
<p><strong>STM32提供的是串口异步通讯，异步通讯中由于没有时钟信号，所以两个通讯设备之间需要约定好波<br>特率，即每个码元的⻓度，以便对信号进行解码。常⻅的波特率为4800、 9600 、 115200 等。</strong> </p>
<ol>
<li><strong>通讯的起始位<br>每开始一次通信时发送方先发出一个逻辑” 0 ”的信号（低电平），表示传输字符的开始。因为总<br>线空闲时为高电平所以开始一次通信时先发送一个明显区别于空闲状态的信号即低电平。</strong></li>
<li><strong>通讯的停止位<br>停止信号可由0.5、 1 、1.5或2个逻辑 1 的数据位表示，只要双方约定一致即可。</strong> </li>
<li><strong>空闲位<br>串口协议规定，当总线处于空闲状态时信号线的状态为‘ 1 ’即高电平，表示当前线路上没有数<br>据。</strong></li>
<li><strong>有效数据位<br>在数据包的起始位之后紧接着的就是要传输的主体数据内容，也称为有效数据，有效数据的⻓度<br>常被约定为5、 6 、7或 8 位⻓。构成一个字符（一般都是 8 位）。先发送最低位，最后发送最高位<br>（LSB-&gt;MSB），使用低电平表示’0’高电平表示’1’完成数据位的传输。</strong> </li>
<li><strong>校验位<br>数据位加上这一位后，使得“ 1 ”的位数应为偶数（偶校验）或奇数（奇校验），以此来校验数据<br>传送的正确性。</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">串口校验分几种方式：</span><br><span class="line">a. 无校验（noparity）。 </span><br><span class="line">b. 奇校验（oddparity）：如果数据位中“ 1 ”的数目是偶数，则校验位为“ 1 ”，如果“ 1 ”的</span><br><span class="line">数目是奇数，校验位为“ 0 ”。 </span><br><span class="line">c. 偶校验（evenparity）：如果数据为中“ 1 ”的数目是偶数，则校验位为“ 0 ”，如果为奇数，</span><br><span class="line">校验位为“ 1 ”。 </span><br></pre></td></tr></table></figure>
<p><strong>现在的通讯效率非常高，一般也不用奇偶校验，还有更复杂的检验算法！</strong></p>
<h3 id="2-USART外设"><a href="#2-USART外设" class="headerlink" title="2. USART外设"></a>2. USART外设</h3><p>STM32提供了USART（UniversalSynchronousAsynchronousReceiverandTransmitter）通用<br>同步异步收发器。是一个串行通信设备，可以灵活地与外部设备进行全双工数据交换。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">还有UART相比USART去掉了同步通讯功能。</span><br><span class="line">一共提供 5 个串口供开发者选择。</span><br></pre></td></tr></table></figure>
<h6 id="STM32的USART功能框图如下："><a href="#STM32的USART功能框图如下：" class="headerlink" title="STM32的USART功能框图如下："></a>STM32的USART功能框图如下：</h6><h6 id="7-功能引脚说明"><a href="#7-功能引脚说明" class="headerlink" title="7. 功能引脚说明"></a>7. 功能引脚说明</h6><ul>
<li><strong>TX：发送数据输出引脚。</strong> </li>
<li><strong>RX：接收数据输入引脚。</strong> </li>
<li><strong>SW_RX：数据接收引脚，只用于单线和智能卡模式，属于内部引脚，没有具体外部引脚。</strong> </li>
<li><p><strong>nRTS：请求以发送（RequestToSend），n表示低电平有效。如果使能RTS流控制，当USART</strong><br><strong>接收器准备好接收新数据时就会将nRTS变成低电平；当接收寄存器已满时，n RTS将被设置为高电</strong><br><strong>平。该引脚只适用于硬件流控制。</strong></p>
</li>
<li><p><strong>nCTS：清除以发送（ClearToSend），n表示低电平有效。如果使能CTS流控制，发送器在发送</strong><br><strong>下一帧数据之前会检测nCTS引脚，如果为低电平，表示可以发送数据，如果为高电平则在发送完</strong><br><strong>当前数据帧之后停止发送。该引脚只适用于硬件流控制。</strong></p>
</li>
<li><strong>SCLK：发送器时钟输出引脚。这个引脚仅适用于同步模式。</strong> </li>
</ul>
<ol>
<li>波特率的产生<br>发送器和接收器的波特率是一致的，都是通过设置BRR寄存器来得到。</li>
</ol>
<p>这里的是给外设的时钟（usart1在APB2上一般是72MHz，usart2， 3 ， 4 ， 5 在A PB1上一般为<br>36MHz）。</p>
<h6 id="假设我们需要的波特率是-115200-，则对应的分频值应该是：-39-0625-，把这个值写入到BRR寄存"><a href="#假设我们需要的波特率是-115200-，则对应的分频值应该是：-39-0625-，把这个值写入到BRR寄存" class="headerlink" title="假设我们需要的波特率是 115200 ，则对应的分频值应该是： 39.0625 ，把这个值写入到BRR寄存"></a>假设我们需要的波特率是 115200 ，则对应的分频值应该是： 39.0625 ，把这个值写入到BRR寄存</h6><p>器中。 <strong>39.0625</strong> 的小数部分： <strong>0.0625*16=1</strong> ,整数部分是： <strong>39(0x27)</strong> 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">所以写入到BRR寄存器的值是： 0x0271 。</span><br><span class="line">9. 相关寄存器</span><br><span class="line">查阅参考手册 540 ⻚，这里就不一一列举了。</span><br></pre></td></tr></table></figure>
<h3 id="3-串口案例-1-：计算机和串口通讯"><a href="#3-串口案例-1-：计算机和串口通讯" class="headerlink" title="3. 串口案例 1 ：计算机和串口通讯"></a>3. 串口案例 1 ：计算机和串口通讯</h3><h4 id="1-需求描述-3"><a href="#1-需求描述-3" class="headerlink" title="1. 需求描述"></a>1. 需求描述</h4><h6 id="电脑通过串口向STM32发送数据，STM32原封不动的再发送过来。电脑可以借助串口助手来发送"><a href="#电脑通过串口向STM32发送数据，STM32原封不动的再发送过来。电脑可以借助串口助手来发送" class="headerlink" title="电脑通过串口向STM32发送数据，STM32原封不动的再发送过来。电脑可以借助串口助手来发送"></a>电脑通过串口向STM32发送数据，STM32原封不动的再发送过来。电脑可以借助串口助手来发送</h6><h6 id="或接受数据。"><a href="#或接受数据。" class="headerlink" title="或接受数据。"></a>或接受数据。</h6><h4 id="2-硬件电路设计-3"><a href="#2-硬件电路设计-3" class="headerlink" title="2. 硬件电路设计"></a>2. 硬件电路设计</h4><p>目前很多电脑已经没有串口接口了，为了使用串口，我们自制的下载器STLink2.1拥有U SB转串口<br>的功能。</p>
<h4 id="3-软件设计：轮询的方式接收（寄存器）"><a href="#3-软件设计：轮询的方式接收（寄存器）" class="headerlink" title="3. 软件设计：轮询的方式接收（寄存器）"></a>3. 软件设计：轮询的方式接收（寄存器）</h4><h5 id="3-1-main-c-1"><a href="#3-1-main-c-1" class="headerlink" title="3.1 main.c"></a>3.1 main.c</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Driver_USART.h&quot;</span><br><span class="line">#include &quot;Delay.h&quot;</span><br><span class="line">#include &quot;string.h&quot;</span><br><span class="line">uint8_t buff[ 100 ] = &#123; 0 &#125;;</span><br><span class="line">uint8_t len = 0 ;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Driver_USART1_Init();</span><br><span class="line">// Driver_USART1_SendChar(&#x27;a&#x27;);</span><br><span class="line">while ( 1 )</span><br><span class="line">&#123;</span><br><span class="line">// uint8_t *str = &quot;Hello atguigu!\r\n&quot;;</span><br><span class="line">// Driver_USART1_SendString(str, strlen((char *)str));</span><br><span class="line">/* uint8_t *str = &quot;尚硅谷\r\n&quot;;</span><br><span class="line">Driver_USART1_SendString(str, strlen((char *)str));</span><br><span class="line">Delay_s(1); */</span><br><span class="line">// uint8_t c =  Driver_USART1_ReceiveChar();</span><br><span class="line">// Driver_USART1_SendChar(c);</span><br><span class="line">Driver_USART1_ReceiveString(buff, &amp;len);</span><br><span class="line">Driver_USART1_SendString(buff, len);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td></tr></table></figure>
<h5 id="3-2-Driver-USART-h"><a href="#3-2-Driver-USART-h" class="headerlink" title="3.2 Driver_USART.h"></a>3.2 Driver_USART.h</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#ifndef __DRVIER_USART_H</span><br><span class="line">#define __DRVIER_USART_H</span><br><span class="line">#include &quot;stm32f10x.h&quot;</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">void Driver_USART1_Init(void);</span><br><span class="line">void Driver_USART1_SendChar(uint8_t byte);</span><br><span class="line">void Driver_USART1_SendString(uint8_t *str, uint16_t len);</span><br><span class="line">uint8_t Driver_USART1_ReceiveChar(void);</span><br><span class="line">void Driver_USART1_ReceiveString(uint8_t buff[], uint8_t *len);</span><br><span class="line">#endif</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td></tr></table></figure>
<h5 id="3-3-Driver-USART-c"><a href="#3-3-Driver-USART-c" class="headerlink" title="3.3 Driver_USART.c"></a>3.3 Driver_USART.c</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Driver_USART.h&quot;</span><br><span class="line">/**</span><br><span class="line"> * @description: 初始化串口 1</span><br><span class="line"> */</span><br><span class="line">void Driver_USART1_Init(void)</span><br><span class="line">&#123;</span><br><span class="line">/* 1. 开启时钟 */</span><br><span class="line">/* 1.1 串口 1 外设的时钟 */</span><br><span class="line">RCC-&gt;APB2ENR |= RCC_APB2ENR_USART1EN;</span><br><span class="line">/* 1.2 GPIO时钟 */</span><br><span class="line">RCC-&gt;APB2ENR |= RCC_APB2ENR_IOPAEN;</span><br><span class="line">/* 2. 配置GPIO引脚的工作模式  PA9=Tx(复用推挽 CNF=10 MODE=11)  PA10=Rx(浮空输入</span><br><span class="line">CNF=01 MODE=00)*/</span><br><span class="line">GPIOA-&gt;CRH |= GPIO_CRH_CNF9_1;</span><br><span class="line">GPIOA-&gt;CRH &amp;= ~GPIO_CRH_CNF9_0;</span><br><span class="line">GPIOA-&gt;CRH |= GPIO_CRH_MODE9;</span><br><span class="line">GPIOA-&gt;CRH &amp;= ~GPIO_CRH_CNF10_1;</span><br><span class="line">GPIOA-&gt;CRH |= GPIO_CRH_CNF10_0;</span><br><span class="line">GPIOA-&gt;CRH &amp;= ~GPIO_CRH_MODE10;</span><br><span class="line">/* 3. 串口的参数配置 */</span><br><span class="line">/* 3.1 配置波特率 115200 */</span><br><span class="line">USART1-&gt;BRR = 0x271;</span><br><span class="line">/* 3.2 配置一个字的⻓度 8 位 */</span><br><span class="line">USART1-&gt;CR1 &amp;= ~USART_CR1_M;</span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">/* 3.3 配置不需要校验位 */</span><br><span class="line">USART1-&gt;CR1 &amp;= ~USART_CR1_PCE;</span><br><span class="line">/* 3.4 配置停止位的⻓度 */</span><br><span class="line">USART1-&gt;CR2 &amp;= ~USART_CR2_STOP;</span><br><span class="line">/* 3.5 使能接收和发送 */</span><br><span class="line">USART1-&gt;CR1 |= USART_CR1_TE;</span><br><span class="line">USART1-&gt;CR1 |= USART_CR1_RE;</span><br><span class="line">/* 4. 使能串口 */</span><br><span class="line">USART1-&gt;CR1 |= USART_CR1_UE;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @description: 发送一个字节</span><br><span class="line"> * @param &#123;uint8_t&#125; byte 要发送的字节</span><br><span class="line"> */</span><br><span class="line">void Driver_USART1_SendChar(uint8_t byte)</span><br><span class="line">&#123;</span><br><span class="line">/* 1. 等待发送寄存器为空 */</span><br><span class="line">while ((USART1-&gt;SR &amp; USART_SR_TXE) == 0 );</span><br><span class="line">/* 2. 数据写出到数据寄存器 */</span><br><span class="line">USART1-&gt;DR = byte;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @description: 发送一个字符串</span><br><span class="line"> * @param &#123;uint8_t&#125; *str 要发送的字符串</span><br><span class="line"> * @param &#123;uint16_t&#125; len 字符串中字节的⻓度</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">void Driver_USART1_SendString(uint8_t *str, uint16_t len)</span><br><span class="line">&#123;</span><br><span class="line">for (uint16_t i = 0 ; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">Driver_USART1_SendChar(str[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @description: 接收一个字节的数据</span><br><span class="line"> * @return &#123;*&#125; 接收到的字节</span><br><span class="line"> */</span><br><span class="line">uint8_t Driver_USART1_ReceiveChar(void)</span><br></pre></td></tr></table></figure>
<p>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">/* 等待数据寄存器非空 */</span><br><span class="line">while ((USART1-&gt;SR &amp; USART_SR_RXNE) == 0 );</span><br><span class="line">return USART1-&gt;DR;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @description: 接收变⻓数据.接收到的数据存入到 buff中</span><br><span class="line"> * @param &#123;uint8_t&#125; buff 存放接收到的数据</span><br><span class="line"> * @param &#123;uint8_t&#125; *len 存放收到的数据的字节的⻓度</span><br><span class="line"> */</span><br><span class="line">void Driver_USART1_ReceiveString(uint8_t buff[], uint8_t *len)</span><br><span class="line">&#123;</span><br><span class="line">uint8_t i = 0 ;</span><br><span class="line">while ( 1 )</span><br><span class="line">&#123;</span><br><span class="line">// 等待接收非空</span><br><span class="line">while ((USART1-&gt;SR &amp; USART_SR_RXNE) == 0 )</span><br><span class="line">&#123;</span><br><span class="line">//在等待期间, 判断是否收到空闲帧</span><br><span class="line">if (USART1-&gt;SR &amp; USART_SR_IDLE)</span><br><span class="line">&#123;</span><br><span class="line">*len = i;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">buff[i] = USART1-&gt;DR;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td></tr></table></figure>
<h4 id="4-软件设计：中断的方式接收（寄存器）"><a href="#4-软件设计：中断的方式接收（寄存器）" class="headerlink" title="4. 软件设计：中断的方式接收（寄存器）"></a>4. 软件设计：中断的方式接收（寄存器）</h4><h6 id="USART提供了多个中断事件。"><a href="#USART提供了多个中断事件。" class="headerlink" title="USART提供了多个中断事件。"></a>USART提供了多个中断事件。</h6><h5 id="4-1-Driver-USART-c"><a href="#4-1-Driver-USART-c" class="headerlink" title="4.1 Driver_USART.c"></a>4.1 Driver_USART.c</h5><h6 id="添加中断相关代码"><a href="#添加中断相关代码" class="headerlink" title="添加中断相关代码"></a>添加中断相关代码</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Driver_USART.h&quot;</span><br><span class="line">/**</span><br><span class="line"> * @description: 初始化串口 1</span><br><span class="line"> */</span><br><span class="line">void Driver_USART1_Init(void)</span><br><span class="line">&#123;</span><br><span class="line">/* 1. 开启时钟 */</span><br><span class="line">/* 1.1 串口 1 外设的时钟 */</span><br><span class="line">RCC-&gt;APB2ENR |= RCC_APB2ENR_USART1EN;</span><br><span class="line">/* 1.2 GPIO时钟 */</span><br><span class="line">RCC-&gt;APB2ENR |= RCC_APB2ENR_IOPAEN;</span><br><span class="line">/* 2. 配置GPIO引脚的工作模式  PA9=Tx(复用推挽 CNF=10 MODE=11)  PA10=Rx(浮空输入</span><br><span class="line">CNF=01 MODE=00)*/</span><br><span class="line">GPIOA-&gt;CRH |= GPIO_CRH_CNF9_1;</span><br><span class="line">GPIOA-&gt;CRH &amp;= ~GPIO_CRH_CNF9_0;</span><br><span class="line">GPIOA-&gt;CRH |= GPIO_CRH_MODE9;</span><br><span class="line">GPIOA-&gt;CRH &amp;= ~GPIO_CRH_CNF10_1;</span><br><span class="line">GPIOA-&gt;CRH |= GPIO_CRH_CNF10_0;</span><br><span class="line">GPIOA-&gt;CRH &amp;= ~GPIO_CRH_MODE10;</span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">/* 3. 串口的参数配置 */</span><br><span class="line">/* 3.1 配置波特率 115200 */</span><br><span class="line">USART1-&gt;BRR = 0x271;</span><br><span class="line">/* 3.2 配置一个字的⻓度 8 位 */</span><br><span class="line">USART1-&gt;CR1 &amp;= ~USART_CR1_M;</span><br><span class="line">/* 3.3 配置不需要校验位 */</span><br><span class="line">USART1-&gt;CR1 &amp;= ~USART_CR1_PCE;</span><br><span class="line">/* 3.4 配置停止位的⻓度 */</span><br><span class="line">USART1-&gt;CR2 &amp;= ~USART_CR2_STOP;</span><br><span class="line">/* 3.5 使能接收和发送 */</span><br><span class="line">USART1-&gt;CR1 |= USART_CR1_TE;</span><br><span class="line">USART1-&gt;CR1 |= USART_CR1_RE;</span><br><span class="line">/* 4. 使能串口 */</span><br><span class="line">USART1-&gt;CR1 |= USART_CR1_UE;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @description: 发送一个字节</span><br><span class="line"> * @param &#123;uint8_t&#125; byte 要发送的字节</span><br><span class="line"> */</span><br><span class="line">void Driver_USART1_SendChar(uint8_t byte)</span><br><span class="line">&#123;</span><br><span class="line">/* 1. 等待发送寄存器为空 */</span><br><span class="line">while ((USART1-&gt;SR &amp; USART_SR_TXE) == 0 );</span><br><span class="line">/* 2. 数据写出到数据寄存器 */</span><br><span class="line">USART1-&gt;DR = byte;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @description: 发送一个字符串</span><br><span class="line"> * @param &#123;uint8_t&#125; *str 要发送的字符串</span><br><span class="line"> * @param &#123;uint16_t&#125; len 字符串中字节的⻓度</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">void Driver_USART1_SendString(uint8_t *str, uint16_t len)</span><br><span class="line">&#123;</span><br><span class="line">for (uint16_t i = 0 ; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">Driver_USART1_SendChar(str[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @description: 接收一个字节的数据</span><br><span class="line"> * @return &#123;*&#125; 接收到的字节</span><br><span class="line"> */</span><br><span class="line">uint8_t Driver_USART1_ReceiveChar(void)</span><br><span class="line">&#123;</span><br><span class="line">/* 等待数据寄存器非空 */</span><br><span class="line">while ((USART1-&gt;SR &amp; USART_SR_RXNE) == 0 );</span><br><span class="line">return USART1-&gt;DR;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @description: 接收变⻓数据.接收到的数据存入到buff中</span><br><span class="line"> * @param &#123;uint8_t&#125; buff 存放接收到的数据</span><br><span class="line"> * @param &#123;uint8_t&#125; *len 存放收到的数据的字节的⻓度</span><br><span class="line"> */</span><br><span class="line">void Driver_USART1_ReceiveString(uint8_t buff[], uint8_t *len)</span><br><span class="line">&#123;</span><br><span class="line">uint8_t i = 0 ;</span><br><span class="line">while ( 1 )</span><br><span class="line">&#123;</span><br><span class="line">// 等待接收非空</span><br><span class="line">while ((USART1-&gt;SR &amp; USART_SR_RXNE) == 0 )</span><br><span class="line">&#123;</span><br><span class="line">//在等待期间, 判断是否收到空闲帧</span><br><span class="line">if (USART1-&gt;SR &amp; USART_SR_IDLE)</span><br><span class="line">&#123;</span><br><span class="line">*len = i;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">buff[i] = USART1-&gt;DR;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/* 缓冲接收到的数据 */</span><br><span class="line">uint8_t buff[ 100 ] = &#123; 0 &#125;;</span><br><span class="line">/* 存储接收到的字节的⻓度 */</span><br><span class="line">uint8_t len = 0 ;</span><br><span class="line">uint8_t isToSend = 0 ;</span><br><span class="line">void USART1_IRQHandler(void)</span><br><span class="line">&#123;</span><br><span class="line">/* 数据接收寄存器非空 */</span><br><span class="line">if (USART1-&gt;SR &amp; USART_SR_RXNE)</span><br></pre></td></tr></table></figure>
<p>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>82<br>83<br>84<br>85<br>86<br>87<br>88<br>89<br>90<br>91<br>92<br>93<br>94<br>95<br>96<br>97<br>98<br>99<br>100<br>101<br>102<br>103<br>104<br>105<br>106<br>107<br>108<br>109<br>110<br>111<br>112<br>113<br>114<br>115<br>116</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">// 对USART_DR的读操作可以将接收非空的中断位清零。 所以不用单独清除了.</span><br><span class="line">//USART1-&gt;SR &amp;= ~USART_SR_RXNE;</span><br><span class="line">buff[len] = USART1-&gt;DR;</span><br><span class="line">len++;</span><br><span class="line">&#125;</span><br><span class="line">else if (USART1-&gt;SR &amp; USART_SR_IDLE)</span><br><span class="line">&#123;</span><br><span class="line">/* 清除空闲中断标志位: 先读sr,再读dr.就可以实现清除了 */</span><br><span class="line">USART1-&gt;SR;</span><br><span class="line">USART1-&gt;DR;</span><br><span class="line">/* 变⻓数据接收完毕 */</span><br><span class="line">//Driver_USART1_SendString(buff, len);</span><br><span class="line">isToSend = 1 ;</span><br><span class="line">/* 把接收字节的⻓度清0 */</span><br><span class="line">// len = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td></tr></table></figure>
<h5 id="4-2-main-c"><a href="#4-2-main-c" class="headerlink" title="4.2 main.c"></a>4.2 main.c</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Driver_USART.h&quot;</span><br><span class="line">/* 缓冲接收到的数据 */</span><br><span class="line">extern uint8_t buff[ 100 ];</span><br><span class="line">/* 存储接收到的字节的⻓度 */</span><br><span class="line">extern uint8_t len;</span><br><span class="line">extern uint8_t isToSend;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Driver_USART1_Init();</span><br><span class="line">Driver_USART1_SendString(&quot;abc&quot;, 3 );</span><br><span class="line">while ( 1 )</span><br><span class="line">&#123;</span><br><span class="line">if(isToSend)</span><br><span class="line">&#123;</span><br><span class="line">Driver_USART1_SendString(buff, len);</span><br><span class="line">isToSend = 0 ;</span><br><span class="line">len = 0 ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td></tr></table></figure>
<h4 id="5-软件设计（HAL库）-1"><a href="#5-软件设计（HAL库）-1" class="headerlink" title="5. 软件设计（HAL库）"></a>5. 软件设计（HAL库）</h4><h5 id="1-使用STM32CubeMx搭建工程"><a href="#1-使用STM32CubeMx搭建工程" class="headerlink" title="1. 使用STM32CubeMx搭建工程"></a>1. 使用STM32CubeMx搭建工程</h5><h6 id="1-基本配置"><a href="#1-基本配置" class="headerlink" title="1. 基本配置"></a>1. 基本配置</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">选择芯片，配置debug，配置时钟参考前面的内容。</span><br></pre></td></tr></table></figure>
<ol>
<li>配置串口</li>
</ol>
<h6 id="3-添加我们的代码"><a href="#3-添加我们的代码" class="headerlink" title="3. 添加我们的代码"></a>3. 添加我们的代码</h6><h6 id="时钟初始化，串口初始化工具已经帮我们完成了。我们可以轮询方式收发数据，也可以采用中断"><a href="#时钟初始化，串口初始化工具已经帮我们完成了。我们可以轮询方式收发数据，也可以采用中断" class="headerlink" title="时钟初始化，串口初始化工具已经帮我们完成了。我们可以轮询方式收发数据，也可以采用中断"></a>时钟初始化，串口初始化工具已经帮我们完成了。我们可以轮询方式收发数据，也可以采用中断</h6><h6 id="的方式收发数据。"><a href="#的方式收发数据。" class="headerlink" title="的方式收发数据。"></a>的方式收发数据。</h6><h5 id="2-轮询的方式收发"><a href="#2-轮询的方式收发" class="headerlink" title="2. 轮询的方式收发"></a>2. 轮询的方式收发</h5><h6 id="轮询的方式就是在循环中一直检测串口，是否有数据进来，如果有就读进来，然后再原封不动的"><a href="#轮询的方式就是在循环中一直检测串口，是否有数据进来，如果有就读进来，然后再原封不动的" class="headerlink" title="轮询的方式就是在循环中一直检测串口，是否有数据进来，如果有就读进来，然后再原封不动的"></a>轮询的方式就是在循环中一直检测串口，是否有数据进来，如果有就读进来，然后再原封不动的</h6><h6 id="发出。"><a href="#发出。" class="headerlink" title="发出。"></a>发出。</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">uint8_t buff[ 10 ];</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">HAL_Init();</span><br><span class="line">SystemClock_Config();</span><br><span class="line">MX_GPIO_Init();</span><br><span class="line">MX_USART1_UART_Init();</span><br><span class="line">while ( 1 )</span><br><span class="line">&#123;</span><br><span class="line">/* 从串口读取数据：参数 1 指定的串口 参数 2 ：存储读取到的数据 参数 3 ：一接收多少条</span><br><span class="line">数据 */</span><br><span class="line">if (HAL_UART_Receive(&amp;huart1, buff, 10 , HAL_MAX_DELAY) == HAL_OK)</span><br><span class="line">&#123;</span><br><span class="line">// 把收到的数据原封不动的发出去</span><br><span class="line">HAL_UART_Transmit(&amp;huart1, buff, 10 , HAL_MAX_DELAY);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td></tr></table></figure>
<h6 id="轮询方式的一些问题：轮询模式使用起来最简单，但是会占用大量的CPU时间，在等待接收和等"><a href="#轮询方式的一些问题：轮询模式使用起来最简单，但是会占用大量的CPU时间，在等待接收和等" class="headerlink" title="轮询方式的一些问题：轮询模式使用起来最简单，但是会占用大量的CPU时间，在等待接收和等"></a>轮询方式的一些问题：轮询模式使用起来最简单，但是会占用大量的CPU时间，在等待接收和等</h6><h6 id="待发送完毕时，CPU不能去做别的运算，只能在这里空等，运行的效率很低。"><a href="#待发送完毕时，CPU不能去做别的运算，只能在这里空等，运行的效率很低。" class="headerlink" title="待发送完毕时，CPU不能去做别的运算，只能在这里空等，运行的效率很低。"></a>待发送完毕时，CPU不能去做别的运算，只能在这里空等，运行的效率很低。</h6><h5 id="3-中断的方式接收：定⻓数据"><a href="#3-中断的方式接收：定⻓数据" class="headerlink" title="3. 中断的方式接收：定⻓数据"></a>3. 中断的方式接收：定⻓数据</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stm32f1xx_hal_uart.c 中关于中断回调函数的描述。</span><br></pre></td></tr></table></figure>
<p>这里函数用了__weak修饰，当有其他实现的时候，编译器会忽略这里的。我们只要在这个函数中<br>写收发逻辑就行了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">uint8_t buff[ 1 ]; // 接收缓冲， 一次接受一个字节的数据</span><br><span class="line">void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)</span><br><span class="line">&#123;</span><br><span class="line">if (huart1.Instance == USART1)</span><br><span class="line">&#123;</span><br><span class="line">HAL_UART_Transmit(&amp;huart1, buff, 1 ，HAL_MAX_DELAY);</span><br><span class="line">HAL_UART_Receive_IT(&amp;huart1, buff, 1 ); // 继续接收</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">HAL_Init();</span><br><span class="line">MX_GPIO_Init();</span><br><span class="line">MX_USART1_UART_Init();</span><br><span class="line">/* 用中断的方式接收一个字节的数据 */</span><br><span class="line">HAL_UART_Receive_IT(&amp;huart1, buff, 1 );</span><br><span class="line">while ( 1 )</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td></tr></table></figure>
<h5 id="4-中断的方式接收：变⻓数据"><a href="#4-中断的方式接收：变⻓数据" class="headerlink" title="4. 中断的方式接收：变⻓数据"></a>4. 中断的方式接收：变⻓数据</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">1 uint8_t rxBuff[ 1000 ]; // 接收缓冲区</span><br><span class="line">2</span><br><span class="line">// size 实际接收的数据的⻓度</span><br><span class="line">void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)</span><br><span class="line">&#123;</span><br><span class="line">if (huart1.Instance == USART1)</span><br><span class="line">&#123;</span><br><span class="line">HAL_UART_Transmit(&amp;huart1, rxBuff, Size, 100 );</span><br><span class="line">HAL_UARTEx_ReceiveToIdle_IT(&amp;huart1, rxBuff, 1000 );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">HAL_Init();</span><br><span class="line">SystemClock_Config();</span><br><span class="line">MX_GPIO_Init();</span><br><span class="line">MX_USART1_UART_Init();</span><br><span class="line">/* 当接收到 1000 个字符或者碰到空闲帧, 则接收结束 */</span><br><span class="line">HAL_UARTEx_ReceiveToIdle_IT(&amp;huart1, rxBuff, 1000 );</span><br><span class="line">while ( 1 )</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">3 4 5 6 7 8 9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td></tr></table></figure>
<h3 id="4-串口案例-2-：重定向printf"><a href="#4-串口案例-2-：重定向printf" class="headerlink" title="4. 串口案例 2 ：重定向printf"></a>4. 串口案例 2 ：重定向printf</h3><h4 id="1-需求描述-4"><a href="#1-需求描述-4" class="headerlink" title="1. 需求描述"></a>1. 需求描述</h4><p>C语言中经常使用printf来输出调试信息，打印到屏幕（控制台）。由于在单片机中没有屏幕，但<br>是我们可以重定向printf，把数据 <strong>打印到串口</strong> ，从而在电脑端接收调试信息。这是除了debug外，另外<br>一个非常有效的调试手段。</p>
<h4 id="2-软件设计（寄存器）"><a href="#2-软件设计（寄存器）" class="headerlink" title="2. 软件设计（寄存器）"></a>2. 软件设计（寄存器）</h4><h5 id="2-1-Driver-USART-c"><a href="#2-1-Driver-USART-c" class="headerlink" title="2.1 Driver_USART.c"></a>2.1 Driver_USART.c</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">添加 fputc 函数。</span><br><span class="line">int fputc(int c, FILE *file)</span><br><span class="line">&#123;</span><br><span class="line">Driver_USART1_SendChar(c);</span><br><span class="line">return c;</span><br><span class="line">&#125;</span><br><span class="line">// 当调用printf的时候,会自动调用这个方法来执行,只需要调用一个通过串口发送字符的函数</span><br><span class="line">1 2 3 4 5 6</span><br></pre></td></tr></table></figure>
<h5 id="2-2-main-c"><a href="#2-2-main-c" class="headerlink" title="2.2 main.c"></a>2.2 main.c</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Driver_USART.h&quot;</span><br><span class="line">#include &quot;Delay.h&quot;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Driver_USART1_Init();</span><br><span class="line">while ( 1 )</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;hello world\r\n&quot;);</span><br><span class="line">Delay_ms( 500 );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td></tr></table></figure>
<h5 id="2-3-Keil设置"><a href="#2-3-Keil设置" class="headerlink" title="2.3 Keil设置"></a>2.3 Keil设置</h5><h4 id="3-软件设计（HAL库）"><a href="#3-软件设计（HAL库）" class="headerlink" title="3. 软件设计（HAL库）"></a>3. 软件设计（HAL库）</h4><h5 id="3-1-usart-h代码清单"><a href="#3-1-usart-h代码清单" class="headerlink" title="3.1 usart.h代码清单"></a>3.1 usart.h代码清单</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;main.h&quot;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">extern UART_HandleTypeDef huart1;</span><br><span class="line">void MX_USART1_UART_Init(void);</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<h5 id="3-2-usart-c代码清单"><a href="#3-2-usart-c代码清单" class="headerlink" title="3.2 usart.c代码清单"></a>3.2 usart.c代码清单</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int fputc(int ch, FILE *f)</span><br><span class="line">&#123;</span><br><span class="line">/* 发送一个字节数据到串口DEBUG_USART */</span><br><span class="line">HAL_UART_Transmit(&amp;huart1, (uint8_t *)&amp;ch, 1 , 1000 );</span><br><span class="line">return (ch);</span><br><span class="line">&#125;</span><br><span class="line">1 2 3 4 5 6 7</span><br></pre></td></tr></table></figure>
<h2 id="8-I2C通讯"><a href="#8-I2C通讯" class="headerlink" title="8. I2C通讯"></a>8. I2C通讯</h2><h3 id="1-I2C基础知识"><a href="#1-I2C基础知识" class="headerlink" title="1. I2C基础知识"></a>1. I2C基础知识</h3><p>I2C通讯协议（Inter-IntegratedCircuit）是由Phiilps公司开发的，由于它引脚少，硬件实现简<br>单，可扩展性强，不需要USART、CAN等通讯协议的外部收发设备，现在被广泛地使用在系统内多个<br>集成电路（IC）间的通讯。</p>
<p>I2C（Inter-IntegratedCircuit）集成电路总线，是一种同步串行半双工通信总线。通信协议中，<br>SDA（串行数据线）和SCL（串行时钟线）是两个主要的信号线。因为有SCL时钟线所以当然是同步<br>的，只有一根SDA线且不可同时收发，I2C总线是一个多主设备、多从设备的总线，通常由主设备（比<br>如微控制器）发起通信，而从设备（比如EEPROM芯片）响应。</p>
<p>I2C总线采用开漏（open-drain）或开集电极（open-collector）驱动方式，这意味着设备只能将<br>信号线拉低，而不能主动拉高。相反，电平被拉高是通过上拉电阻实现的，是一种简单的双向两线制<br>总线协议标准，支持 <strong>同步串行半双工</strong> 通讯。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I2C通讯设备之间的常用连接方式：</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://xiza3i1x6q4.feishu.cn/sync/J3r7d3lz1s5Mqjb5aGDcqo5pnFd">https://xiza3i1x6q4.feishu.cn/sync/J3r7d3lz1s5Mqjb5aGDcqo5pnFd</a></p>
<h4 id="🌅-在I²C通信协议中，SDA（SerialDataLine）的电平状态确实用来表示通信的控制权归"><a href="#🌅-在I²C通信协议中，SDA（SerialDataLine）的电平状态确实用来表示通信的控制权归" class="headerlink" title="🌅 在I²C通信协议中，SDA（SerialDataLine）的电平状态确实用来表示通信的控制权归"></a>🌅 在I²C通信协议中，SDA（SerialDataLine）的电平状态确实用来表示通信的控制权归</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">属。拉高（置高电平）SDA通常表示的是主设备（Master）释放了总线的控制权，让从设备</span><br><span class="line">（Slave）有机会在总线上发送数据或者响应主设备的请求。</span><br><span class="line">1.开漏结构： I²C总线通常是开漏结构 ，这意味着在不同的设备之间，SDA和SCL都会被</span><br><span class="line">外部上拉电阻拉高，而设备在通信时通过拉低SDA和SCL来进行通信。因此， 释放控制权通常</span><br><span class="line">是通过主设备放弃拉低SDA线实现的，SDA线由上拉电阻拉到高电平 。</span><br><span class="line">2.从设备响应：当主设备完成其通信操作后，它将SDA线拉高，这样从设备便能够知道主</span><br><span class="line">设备已经完成了其发送的数据或者请求。从设备此时可以在总线上发送数据回复或者等待下</span><br><span class="line">一次主设备的指令。</span><br><span class="line">3.协议规定：根据I²C协议， SDA的高电平表示空闲状态或者主设备释放总线的意图 。从</span><br><span class="line">设备检测到SDA被拉高后，会知道主设备当前没有在总线上发送数据或者请求，因此从设备</span><br><span class="line">有机会接管总线并发送数据或响应。</span><br><span class="line">总之，SDA被拉高表示主设备不再活跃地发送数据或命令，从而让从设备可以在总线上</span><br><span class="line">接管，发送数据或者响应主设备。</span><br></pre></td></tr></table></figure>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><h6 id="1-总线空闲状态："><a href="#1-总线空闲状态：" class="headerlink" title="1. 总线空闲状态："></a>1. 总线空闲状态：</h6><h3 id="◦-当总线空闲时，SDA和SCL都被上拉电阻拉高，表示没有设备在使用总线。这是总线的"><a href="#◦-当总线空闲时，SDA和SCL都被上拉电阻拉高，表示没有设备在使用总线。这是总线的" class="headerlink" title="◦ 当总线空闲时，SDA和SCL都被上拉电阻拉高，表示没有设备在使用总线。这是总线的"></a>◦ 当总线空闲时，SDA和SCL都被上拉电阻拉高，表示没有设备在使用总线。这是总线的</h3><h6 id="默认状态。"><a href="#默认状态。" class="headerlink" title="默认状态。"></a>默认状态。</h6><h6 id="2-启动和停止条件："><a href="#2-启动和停止条件：" class="headerlink" title="2. 启动和停止条件："></a>2. 启动和停止条件：</h6><h3 id="◦-I2C通信开始时，主设备会发出一个启动条件（StartCondition），这表现为S-DA从高"><a href="#◦-I2C通信开始时，主设备会发出一个启动条件（StartCondition），这表现为S-DA从高" class="headerlink" title="◦ I2C通信开始时，主设备会发出一个启动条件（StartCondition），这表现为S DA从高"></a>◦ I2C通信开始时，主设备会发出一个启动条件（StartCondition），这表现为S DA从高</h3><h6 id="到低的跳变，而SCL保持高电平。"><a href="#到低的跳变，而SCL保持高电平。" class="headerlink" title="到低的跳变，而SCL保持高电平。"></a>到低的跳变，而SCL保持高电平。</h6><h3 id="◦-通信结束时，主设备会发出一个停止条件（StopCondition），这表现为SDA从低到"><a href="#◦-通信结束时，主设备会发出一个停止条件（StopCondition），这表现为SDA从低到" class="headerlink" title="◦ 通信结束时，主设备会发出一个停止条件（StopCondition），这表现为SDA从低到"></a>◦ 通信结束时，主设备会发出一个停止条件（StopCondition），这表现为SDA从低到</h3><h6 id="高的跳变，而SCL保持高电平。"><a href="#高的跳变，而SCL保持高电平。" class="headerlink" title="高的跳变，而SCL保持高电平。"></a>高的跳变，而SCL保持高电平。</h6><h6 id="3-数据传输："><a href="#3-数据传输：" class="headerlink" title="3. 数据传输："></a>3. 数据传输：</h6><h3 id="◦-在数据传输过程中，无论是主设备还是从设备，都在SCL时钟周期内驱动SDA线进行数"><a href="#◦-在数据传输过程中，无论是主设备还是从设备，都在SCL时钟周期内驱动SDA线进行数" class="headerlink" title="◦ 在数据传输过程中，无论是主设备还是从设备，都在SCL时钟周期内驱动SDA线进行数"></a>◦ 在数据传输过程中，无论是主设备还是从设备，都在SCL时钟周期内驱动SDA线进行数</h3><h6 id="据传输。当某个设备需要发送数据时，它会控制SDA线，在SCL的上升沿之前设置好数"><a href="#据传输。当某个设备需要发送数据时，它会控制SDA线，在SCL的上升沿之前设置好数" class="headerlink" title="据传输。当某个设备需要发送数据时，它会控制SDA线，在SCL的上升沿之前设置好数"></a>据传输。当某个设备需要发送数据时，它会控制SDA线，在SCL的上升沿之前设置好数</h6><h6 id="据。"><a href="#据。" class="headerlink" title="据。"></a>据。</h6><h3 id="◦-主设备在发送完地址后，根据LSB的值（LSB是用来指示数据传输的读写方向的）继续"><a href="#◦-主设备在发送完地址后，根据LSB的值（LSB是用来指示数据传输的读写方向的）继续" class="headerlink" title="◦ 主设备在发送完地址后，根据LSB的值（LSB是用来指示数据传输的读写方向的）继续"></a>◦ 主设备在发送完地址后，根据LSB的值（LSB是用来指示数据传输的读写方向的）继续</h3><h6 id="进行数据传输。"><a href="#进行数据传输。" class="headerlink" title="进行数据传输。"></a>进行数据传输。</h6><h3 id="◦-如果是写操作，主设备会发送数据字节到从设备，然后等待从设备的确认信号。"><a href="#◦-如果是写操作，主设备会发送数据字节到从设备，然后等待从设备的确认信号。" class="headerlink" title="◦ 如果是写操作，主设备会发送数据字节到从设备，然后等待从设备的确认信号。"></a>◦ 如果是写操作，主设备会发送数据字节到从设备，然后等待从设备的确认信号。</h3><h3 id="◦-如果是读操作，从设备要响应数据。在这种情况下，主设备释放SDA线，让S-DA通过"><a href="#◦-如果是读操作，从设备要响应数据。在这种情况下，主设备释放SDA线，让S-DA通过" class="headerlink" title="◦ 如果是读操作，从设备要响应数据。在这种情况下，主设备释放SDA线，让S DA通过"></a>◦ 如果是读操作，从设备要响应数据。在这种情况下，主设备释放SDA线，让S DA通过</h3><h6 id="上拉电阻恢复到高电平，然后从设备在接下来的时钟周期内驱动SDA线，以发送数"><a href="#上拉电阻恢复到高电平，然后从设备在接下来的时钟周期内驱动SDA线，以发送数" class="headerlink" title="上拉电阻恢复到高电平，然后从设备在接下来的时钟周期内驱动SDA线，以发送数"></a>上拉电阻恢复到高电平，然后从设备在接下来的时钟周期内驱动SDA线，以发送数</h6><h6 id="据。主设备会接收从设备发送的数据，并发送确认（ACK）或非确认（NACK）信号以"><a href="#据。主设备会接收从设备发送的数据，并发送确认（ACK）或非确认（NACK）信号以" class="headerlink" title="据。主设备会接收从设备发送的数据，并发送确认（ACK）或非确认（NACK）信号以"></a>据。主设备会接收从设备发送的数据，并发送确认（ACK）或非确认（NACK）信号以</h6><h6 id="告知从设备是否需要继续发送数据。"><a href="#告知从设备是否需要继续发送数据。" class="headerlink" title="告知从设备是否需要继续发送数据。"></a>告知从设备是否需要继续发送数据。</h6><h6 id="因为SDA被设计成开漏驱动，任何设备都只能拉低SDA，而不能直接拉高，这样也避免"><a href="#因为SDA被设计成开漏驱动，任何设备都只能拉低SDA，而不能直接拉高，这样也避免" class="headerlink" title="因为SDA被设计成开漏驱动，任何设备都只能拉低SDA，而不能直接拉高，这样也避免"></a>因为SDA被设计成开漏驱动，任何设备都只能拉低SDA，而不能直接拉高，这样也避免</h6><h6 id="了多个设备同时驱动SDA线时的电平冲突，这样的一种机制保证了I2C总线上设备之间的协调"><a href="#了多个设备同时驱动SDA线时的电平冲突，这样的一种机制保证了I2C总线上设备之间的协调" class="headerlink" title="了多个设备同时驱动SDA线时的电平冲突，这样的一种机制保证了I2C总线上设备之间的协调"></a>了多个设备同时驱动SDA线时的电平冲突，这样的一种机制保证了I2C总线上设备之间的协调</h6><h6 id="和无冲突通信。"><a href="#和无冲突通信。" class="headerlink" title="和无冲突通信。"></a>和无冲突通信。</h6><h3 id="通信方向"><a href="#通信方向" class="headerlink" title="通信方向"></a>通信方向</h3><ul>
<li>LSB为^0 时，表示主设备要向从设备写入数据。</li>
<li>LSB为^1 时，表示主设备要从从设备读取数据。<br>主设备发送数据给从设备（写操作）</li>
<li>SDA控制：主设备控制SDA线发送地址和数据字节。</li>
<li>SCL控制：主设备控制SCL线产生时钟信号，确定数据传输的时序。<br>从设备发送数据给主设备（读操作）</li>
<li>SDA控制：从设备控制SDA线发送数据字节。</li>
<li>SCL控制：主设备控制SCL线产生时钟信号，确定数据传输的时序。<br>总的来说，主设备负责控制总线的时钟和发送地址/数据，而从设备负责在主设备的控制下发<br>送数据。</li>
</ul>
<h3 id="2-I2C案例-1-：软件模拟I2C"><a href="#2-I2C案例-1-：软件模拟I2C" class="headerlink" title="2. I2C案例 1 ：软件模拟I2C"></a>2. I2C案例 1 ：软件模拟I2C</h3><h6 id="EEPROM芯片最常用的通讯方式就是I2C协议。我们使用的芯片是M24C02。"><a href="#EEPROM芯片最常用的通讯方式就是I2C协议。我们使用的芯片是M24C02。" class="headerlink" title="EEPROM芯片最常用的通讯方式就是I2C协议。我们使用的芯片是M24C02。"></a>EEPROM芯片最常用的通讯方式就是I2C协议。我们使用的芯片是M24C02。</h6><h4 id="1-需求描述-5"><a href="#1-需求描述-5" class="headerlink" title="1. 需求描述"></a>1. 需求描述</h4><h6 id="我们向E2PROM写入一段数据，再读取出来，最后发送到串口，核对是否读写正确。"><a href="#我们向E2PROM写入一段数据，再读取出来，最后发送到串口，核对是否读写正确。" class="headerlink" title="我们向E2PROM写入一段数据，再读取出来，最后发送到串口，核对是否读写正确。"></a>我们向E2PROM写入一段数据，再读取出来，最后发送到串口，核对是否读写正确。</h6><h4 id="2-硬件电路设计-4"><a href="#2-硬件电路设计-4" class="headerlink" title="2. 硬件电路设计"></a>2. 硬件电路设计</h4><h5 id="1-硬件原理图"><a href="#1-硬件原理图" class="headerlink" title="1. 硬件原理图"></a>1. 硬件原理图</h5><h5 id="2-M24C02简介"><a href="#2-M24C02简介" class="headerlink" title="2. M24C02简介"></a>2. M24C02简介</h5><h6 id="1-M24C02的SCL及SDA引脚连接到了STM32对应的I2C引脚中，结合上拉电阻，构成了I2C通讯总"><a href="#1-M24C02的SCL及SDA引脚连接到了STM32对应的I2C引脚中，结合上拉电阻，构成了I2C通讯总" class="headerlink" title="1. M24C02的SCL及SDA引脚连接到了STM32对应的I2C引脚中，结合上拉电阻，构成了I2C通讯总"></a>1. M24C02的SCL及SDA引脚连接到了STM32对应的I2C引脚中，结合上拉电阻，构成了I2C通讯总</h6><h6 id="线，它们通过I2C总线交互。"><a href="#线，它们通过I2C总线交互。" class="headerlink" title="线，它们通过I2C总线交互。"></a>线，它们通过I2C总线交互。</h6><h6 id="2-E2PROM芯片的设备地址一共有-7-位，其中高-4-位固定为：-1010-，低-3-位则由E-3-E2-E1信号线的电平"><a href="#2-E2PROM芯片的设备地址一共有-7-位，其中高-4-位固定为：-1010-，低-3-位则由E-3-E2-E1信号线的电平" class="headerlink" title="2. E2PROM芯片的设备地址一共有 7 位，其中高 4 位固定为： 1010 ，低 3 位则由E 3/E2/E1信号线的电平"></a>2. E2PROM芯片的设备地址一共有 7 位，其中高 4 位固定为： 1010 ，低 3 位则由E 3/E2/E1信号线的电平</h6><h6 id="决定E2PROM设备地址。"><a href="#决定E2PROM设备地址。" class="headerlink" title="决定E2PROM设备地址。"></a>决定E2PROM设备地址。</h6><h6 id="3-R-W是读写方向控制位，与地址无关。"><a href="#3-R-W是读写方向控制位，与地址无关。" class="headerlink" title="3. R/W是读写方向控制位，与地址无关。"></a>3. R/W是读写方向控制位，与地址无关。</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在我们电路图中由于E1/E2/E3均是接的低电平，所以它的地址是 1010000 即0x50。</span><br></pre></td></tr></table></figure>
<h6 id="由于I2C通讯时常常是地址跟读写方向连在一起构成一个-8-位数，且当R-W位为-0-时，表示写方向，"><a href="#由于I2C通讯时常常是地址跟读写方向连在一起构成一个-8-位数，且当R-W位为-0-时，表示写方向，" class="headerlink" title="由于I2C通讯时常常是地址跟读写方向连在一起构成一个 8 位数，且当R/W位为 0 时，表示写方向，"></a>由于I2C通讯时常常是地址跟读写方向连在一起构成一个 8 位数，且当R/W位为 0 时，表示写方向，</h6><p>所以加上 7 位地址，其值为“0xA0”，常称该值为I2C设备的“写地址”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当R/W位为 1 时，表示读方向，加上 7 位地址，其值为“0xA1”，常称该值为“读地址”。</span><br></pre></td></tr></table></figure>
<h4 id="3-操作时序图整理"><a href="#3-操作时序图整理" class="headerlink" title="3. 操作时序图整理"></a>3. 操作时序图整理</h4><h5 id="1-起始和停止信号"><a href="#1-起始和停止信号" class="headerlink" title="1. 起始和停止信号"></a>1. 起始和停止信号</h5><h5 id="2-数据有效性"><a href="#2-数据有效性" class="headerlink" title="2. 数据有效性"></a>2. 数据有效性</h5><h5 id="3-响应和非响应"><a href="#3-响应和非响应" class="headerlink" title="3. 响应和非响应"></a>3. 响应和非响应</h5><h5 id="4-写入一个字节时序"><a href="#4-写入一个字节时序" class="headerlink" title="4. 写入一个字节时序"></a>4. 写入一个字节时序</h5><h5 id="5-读出一个字节时序"><a href="#5-读出一个字节时序" class="headerlink" title="5. 读出一个字节时序"></a>5. 读出一个字节时序</h5><h5 id="6-单次写入多个字节时序"><a href="#6-单次写入多个字节时序" class="headerlink" title="6. 单次写入多个字节时序"></a>6. 单次写入多个字节时序</h5><p>一次性写入多个字节，也叫⻚写入（PageWrite）。AT24C02每⻚只有 16 个字节，每次只能写入<br>单独的一个⻚中，所以一次性最多只能写入 16 个字节。当一次性写入超过 16 个字节的时候，则超过的<br>部分会重新从这⻚的首地址重新写入。</p>
<h5 id="7-单次读出多个字节时序"><a href="#7-单次读出多个字节时序" class="headerlink" title="7. 单次读出多个字节时序"></a>7. 单次读出多个字节时序</h5><h6 id="读出多个字节的时候没有限制，可以读出任意多个。"><a href="#读出多个字节的时候没有限制，可以读出任意多个。" class="headerlink" title="读出多个字节的时候没有限制，可以读出任意多个。"></a>读出多个字节的时候没有限制，可以读出任意多个。</h6><h4 id="4-软件设计（寄存器）"><a href="#4-软件设计（寄存器）" class="headerlink" title="4. 软件设计（寄存器）"></a>4. 软件设计（寄存器）</h4><h5 id="4-1-main-c"><a href="#4-1-main-c" class="headerlink" title="4.1 main.c"></a>4.1 main.c</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Driver_USART.h&quot;</span><br><span class="line">#include &quot;Inf_W24C02.h&quot;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Driver_USART1_Init();</span><br><span class="line">printf(&quot;尚硅谷 I2C 软件模式实验开始....\r\n&quot;);</span><br><span class="line">//初始化</span><br><span class="line">Inf_W24C02_Init();</span><br><span class="line">//写数据</span><br><span class="line">Inf_W24C02_WriteByte(0x00, &#x27;a&#x27;);</span><br><span class="line">Inf_W24C02_WriteByte(0x01, &#x27;b&#x27;);</span><br><span class="line">Inf_W24C02_WriteByte(0x02, &#x27;c&#x27;);</span><br><span class="line">//读数据</span><br><span class="line">uint8_t byte1 = Inf_W24C02_ReadByte(0x00);</span><br><span class="line">uint8_t byte2 = Inf_W24C02_ReadByte(0x01);</span><br><span class="line">uint8_t byte3 = Inf_W24C02_ReadByte(0x02);</span><br><span class="line">printf(&quot;%c\r\n&quot;, byte1);</span><br><span class="line">printf(&quot;%c\r\n&quot;, byte2);</span><br><span class="line">printf(&quot;%c\r\n&quot;, byte3);</span><br><span class="line">Inf_W24C02_WriteBytes(0x00, &quot;123456&quot;, 6 );</span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">uint8_t buff[ 100 ] = &#123; 0 &#125;;</span><br><span class="line">Inf_W24C02_ReadBytes(0x00, buff, 6 );</span><br><span class="line">printf(&quot;%s\r\n&quot;, buff);</span><br><span class="line">// 清零缓冲区</span><br><span class="line">memset(buff, 0 , sizeof(buff));</span><br><span class="line">Inf_W24C02_WriteBytes(0x00, &quot;0123456789abcdefghijk&quot;, 21 );</span><br><span class="line">Inf_W24C02_ReadBytes(0x00, buff, 21 );</span><br><span class="line">printf(&quot;%s\r\n&quot;, buff);</span><br><span class="line">while ( 1 )</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td></tr></table></figure>
<h5 id="4-2-Driver-I2C2-h"><a href="#4-2-Driver-I2C2-h" class="headerlink" title="4.2 Driver_I2C2.h"></a>4.2 Driver_I2C2.h</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#ifndef __DRIVER_I2C2_H</span><br><span class="line">#define __DRIVER_I2C2_H</span><br><span class="line">#include &quot;Delay.h&quot;</span><br><span class="line">#include &quot;stm32f10x.h&quot;</span><br><span class="line">#include &quot;Driver_USART.h&quot;</span><br><span class="line">#define ACK 0</span><br><span class="line">#define NACK 1</span><br><span class="line">#define SCL_HIGH  (GPIOB-&gt;ODR |= GPIO_ODR_ODR10)</span><br><span class="line">#define SCL_LOW  (GPIOB-&gt;ODR &amp;= ~GPIO_ODR_ODR10)</span><br><span class="line">#define SDA_HIGH  (GPIOB-&gt;ODR |= GPIO_ODR_ODR11)</span><br><span class="line">#define SDA_LOW  (GPIOB-&gt;ODR &amp;= ~GPIO_ODR_ODR11)</span><br><span class="line">#define READ_SDA (GPIOB-&gt;IDR &amp; GPIO_IDR_IDR11)</span><br><span class="line">void Driver_I2C2_Init(void);</span><br><span class="line">void Driver_I2C2_Start(void);</span><br><span class="line">void Driver_I2C2_Stop(void);</span><br><span class="line">void Driver_I2C2_Ack(void);</span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">void Driver_I2C2_NAck(void);</span><br><span class="line">uint8_t Driver_I2C2_WaitAck(void);</span><br><span class="line">void Driver_I2C_SendByte(uint8_t byte);</span><br><span class="line">uint8_t Driver_I2C_ReadByte(void);</span><br><span class="line">#endif</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td></tr></table></figure>
<h5 id="4-3-Driver-I2C2-c"><a href="#4-3-Driver-I2C2-c" class="headerlink" title="4.3 Driver_I2C2.c"></a>4.3 Driver_I2C2.c</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Driver_I2C2.h&quot;</span><br><span class="line">#include &quot;Delay.h&quot;</span><br><span class="line">#define I2C_DELAY Delay_us( 10 )</span><br><span class="line">/**</span><br><span class="line"> * @description: 初始化</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">void Driver_I2C2_Init(void)</span><br><span class="line">&#123;</span><br><span class="line">/* PB10-&gt;SCL</span><br><span class="line">PB11-&gt;SDA</span><br><span class="line">开漏输出: 既可以用于输出也可以输入. 外界要有上拉电阻.</span><br><span class="line">用于输入的时候,最好先输出一个1,把线的控制权交给外界.</span><br><span class="line">MODE=11 CNF=01 */</span><br><span class="line">RCC-&gt;APB2ENR |= RCC_APB2ENR_IOPBEN;</span><br><span class="line">GPIOB-&gt;CRH |= (GPIO_CRH_MODE10 | GPIO_CRH_MODE11 | GPIO_CRH_CNF10_0 |</span><br><span class="line">GPIO_CRH_CNF11_0);</span><br><span class="line">GPIOB-&gt;CRH &amp;= ~(GPIO_CRH_CNF10_1 | GPIO_CRH_CNF11_1);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @description: 起始信号</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">void Driver_I2C2_Start(void)</span><br><span class="line">&#123;</span><br><span class="line">/* 1. 拉高sda和scl */</span><br><span class="line">SDA_HIGH;</span><br><span class="line">SCL_HIGH;</span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">/* 2. 延时 */</span><br><span class="line">I2C_DELAY;</span><br><span class="line">/* 3. 拉低sda */</span><br><span class="line">SDA_LOW;</span><br><span class="line">/* 4. 延时 */</span><br><span class="line">I2C_DELAY;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @description: 停止信号</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">void Driver_I2C2_Stop(void)</span><br><span class="line">&#123;</span><br><span class="line">/* 1. scl 拉高 sda拉低 */</span><br><span class="line">SCL_HIGH;</span><br><span class="line">SDA_LOW;</span><br><span class="line">/* 2. 延时 */</span><br><span class="line">I2C_DELAY;</span><br><span class="line">/* 3. 拉高sda */</span><br><span class="line">SDA_HIGH;</span><br><span class="line">/* 4.  延时 */</span><br><span class="line">I2C_DELAY;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @description: 接收方产生应答信号</span><br><span class="line"> */</span><br><span class="line">void Driver_I2C2_Ack(void)</span><br><span class="line">&#123;</span><br><span class="line">/* 1. 拉高sda和拉低scl */</span><br><span class="line">SDA_HIGH;</span><br><span class="line">SCL_LOW;</span><br><span class="line">/* 2. 延时 */</span><br><span class="line">I2C_DELAY;</span><br><span class="line">/* 3. sda拉低 */</span><br><span class="line">SDA_LOW;</span><br><span class="line">/* 4. 延时 */</span><br><span class="line">I2C_DELAY;</span><br></pre></td></tr></table></figure>
<p>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/* 5. scl拉高 */</span><br><span class="line">SCL_HIGH;</span><br><span class="line">/* 6. 延时 */</span><br><span class="line">I2C_DELAY;</span><br><span class="line">/* 7. scl拉低 */</span><br><span class="line">SCL_LOW;</span><br><span class="line">/* 8. 延时 */</span><br><span class="line">I2C_DELAY;</span><br><span class="line">/* 9. sda 拉高 */</span><br><span class="line">SDA_HIGH;</span><br><span class="line">/* 10. 延时 */</span><br><span class="line">I2C_DELAY;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @description: 接收方产生非应答信号</span><br><span class="line"> */</span><br><span class="line">void Driver_I2C2_NAck(void)</span><br><span class="line">&#123;</span><br><span class="line">/* 1. 拉高sda和拉低scl */</span><br><span class="line">SDA_HIGH;</span><br><span class="line">SCL_LOW;</span><br><span class="line">/* 2. 延时 */</span><br><span class="line">I2C_DELAY;</span><br><span class="line">/* 3. scl拉高 */</span><br><span class="line">SCL_HIGH;</span><br><span class="line">/* 4. 延时 */</span><br><span class="line">I2C_DELAY;</span><br><span class="line">/* 5. scl拉低*/</span><br><span class="line">SCL_LOW;</span><br><span class="line">/* 6. 延时 */</span><br><span class="line">I2C_DELAY;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @description: 等待接收方法的应答</span><br></pre></td></tr></table></figure>
<p>80<br>81<br>82<br>83<br>84<br>85<br>86<br>87<br>88<br>89<br>90<br>91<br>92<br>93<br>94<br>95<br>96<br>97<br>98<br>99<br>100<br>101<br>102<br>103<br>104<br>105<br>106<br>107<br>108<br>109<br>110<br>111<br>112<br>113<br>114<br>115<br>116<br>117<br>118<br>119<br>120<br>121<br>122<br>123<br>124<br>125<br>126</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> * @return &#123;*&#125; 应答或非应答</span><br><span class="line"> */</span><br><span class="line">uint8_t Driver_I2C2_WaitAck(void)</span><br><span class="line">&#123;</span><br><span class="line">/* 1. 把sda拉高, sda的主动权交给对方(e2prom芯片)</span><br><span class="line">等待应答的过程是主机操作时钟线scl，因此之后就读sda</span><br><span class="line">对应引脚的ODR寄存器 获得高低电平来判断应答非应答 */</span><br><span class="line">SDA_HIGH;</span><br><span class="line">/* 2. scl拉低  */</span><br><span class="line">SCL_LOW;</span><br><span class="line">/* 3. 延时 */</span><br><span class="line">I2C_DELAY;</span><br><span class="line">/* 4. 拉高scl */</span><br><span class="line">SCL_HIGH;</span><br><span class="line">/* 5. 延时 */</span><br><span class="line">I2C_DELAY;</span><br><span class="line">/* 6. 读取sda的电平 */</span><br><span class="line">uint8_t ack = ACK;</span><br><span class="line">if (READ_SDA)</span><br><span class="line">&#123;</span><br><span class="line">ack = NACK;</span><br><span class="line">&#125;</span><br><span class="line">/* 7. 拉低scl */</span><br><span class="line">SCL_LOW;</span><br><span class="line">/* 8. 延时 */</span><br><span class="line">I2C_DELAY;</span><br><span class="line">return ack;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @description: 发送一个字节的数据</span><br><span class="line"> * @param &#123;uint8_t&#125; byte 要发送的字节</span><br><span class="line"> */</span><br><span class="line">void Driver_I2C_SendByte(uint8_t byte)</span><br><span class="line">&#123;</span><br><span class="line">for (uint8_t i = 0 ; i &lt; 8 ; i++)</span><br><span class="line">&#123;</span><br><span class="line">/* 1. sda和scl 拉低 */</span><br><span class="line">SDA_LOW;</span><br><span class="line">SCL_LOW;</span><br></pre></td></tr></table></figure>
<p>127<br>128<br>129<br>130<br>131<br>132<br>133<br>134<br>135<br>136<br>137<br>138<br>139<br>140<br>141<br>142<br>143<br>144<br>145<br>146<br>147<br>148<br>149<br>150<br>151<br>152<br>153<br>154<br>155<br>156<br>157<br>158<br>159<br>160<br>161<br>162<br>163<br>164<br>165<br>166<br>167<br>168<br>169<br>170<br>171<br>172<br>173</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">I2C_DELAY;</span><br><span class="line">/* 2. 向sda写数据 */</span><br><span class="line">if (byte &amp; 0x80)</span><br><span class="line">&#123;</span><br><span class="line">SDA_HIGH;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">SDA_LOW;</span><br><span class="line">&#125;</span><br><span class="line">I2C_DELAY;</span><br><span class="line">/* 3. 时钟拉高 */</span><br><span class="line">SCL_HIGH;</span><br><span class="line">I2C_DELAY;</span><br><span class="line">/* 4. 时钟拉低 */</span><br><span class="line">SCL_LOW;</span><br><span class="line">I2C_DELAY;</span><br><span class="line">/* 5. 左移 1 位, 为下一次发送做准备 */</span><br><span class="line">byte &lt;&lt;= 1 ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @description: 读一个字节的数据</span><br><span class="line"> * @param &#123;uint8_t&#125; byte 要发送的字节</span><br><span class="line"> */</span><br><span class="line">uint8_t Driver_I2C_ReadByte(void)</span><br><span class="line">&#123;</span><br><span class="line">uint8_t data = 0 ;</span><br><span class="line">for (uint8_t i = 0 ; i &lt; 8 ; i++)</span><br><span class="line">&#123;</span><br><span class="line">SDA_HIGH;/* 也可不加 */</span><br><span class="line">/* 1. 拉低scl */</span><br><span class="line">SCL_LOW;</span><br><span class="line">/* 2. 延时 */</span><br><span class="line">I2C_DELAY;</span><br></pre></td></tr></table></figure>
<p>174<br>175<br>176<br>177<br>178<br>179<br>180<br>181<br>182<br>183<br>184<br>185<br>186<br>187<br>188<br>189<br>190<br>191<br>192<br>193<br>194<br>195<br>196<br>197<br>198<br>199<br>200<br>201<br>202<br>203<br>204<br>205<br>206<br>207<br>208<br>209<br>210<br>211<br>212<br>213<br>214<br>215<br>216<br>217<br>218<br>219<br>220</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/* 3. 拉高scl */</span><br><span class="line">SCL_HIGH;</span><br><span class="line">/* 4. 延时 */</span><br><span class="line">I2C_DELAY;</span><br><span class="line">/* 5. 读取sda */</span><br><span class="line">data &lt;&lt;= 1 ; /* 一定要放前面才能实现读一个字节(八位)，最低位移位 7 次 */</span><br><span class="line">if (READ_SDA)</span><br><span class="line">&#123;</span><br><span class="line">data |= 0x01;</span><br><span class="line">&#125;</span><br><span class="line">/* 6. 拉低scl */</span><br><span class="line">SCL_LOW;</span><br><span class="line">/* 7. 延时 */</span><br><span class="line">I2C_DELAY;</span><br><span class="line">&#125;</span><br><span class="line">return data;</span><br><span class="line">&#125;</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br></pre></td></tr></table></figure>
<h5 id="4-4-Inf-W24C02-h"><a href="#4-4-Inf-W24C02-h" class="headerlink" title="4.4 Inf_W24C02.h"></a>4.4 Inf_W24C02.h</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#ifndef __INF_W24C02_H</span><br><span class="line">#define __INF_W24C02_H</span><br><span class="line">#include &quot;Driver_I2C2.h&quot;</span><br><span class="line">#include &quot;string.h&quot;</span><br><span class="line">#define ADDR 0xA0</span><br><span class="line">void Inf_W24C02_Init(void);</span><br><span class="line">void Inf_W24C02_WriteByte(uint8_t innerAddr, uint8_t byte);</span><br><span class="line">uint8_t Inf_W24C02_ReadByte(uint8_t innerAddr);</span><br><span class="line">void Inf_W24C02_WriteBytes(uint8_t innerAddr, uint8_t *bytes, uint8_t len);</span><br><span class="line">void Inf_W24C02_ReadBytes(uint8_t innerAddr, uint8_t *bytes, uint8_t len);</span><br><span class="line">#endif</span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td></tr></table></figure>
<h5 id="4-5-Inf-W24C02-c"><a href="#4-5-Inf-W24C02-c" class="headerlink" title="4.5 Inf_W24C02.c"></a>4.5 Inf_W24C02.c</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Inf_W24C02.h&quot;</span><br><span class="line">void Inf_W24C02_Init(void)</span><br><span class="line">&#123;</span><br><span class="line">Driver_I2C2_Init();</span><br><span class="line">&#125;</span><br><span class="line">void Inf_W24C02_WriteByte(uint8_t innerAddr, uint8_t byte)</span><br><span class="line">&#123;</span><br><span class="line">/* 1. 开始信号 */</span><br><span class="line">Driver_I2C2_Start();</span><br><span class="line">/* 2. 发送写地址 */</span><br><span class="line">Driver_I2C_SendByte(ADDR);</span><br><span class="line">/* 3. 等待响应 */</span><br><span class="line">uint8_t ack = Driver_I2C2_WaitAck();</span><br><span class="line">if (ack == ACK)</span><br><span class="line">&#123;</span><br><span class="line">/* 4. 发送内部地址 */</span><br><span class="line">Driver_I2C_SendByte(innerAddr);</span><br><span class="line">/* 5. 等待响应 */</span><br><span class="line">Driver_I2C2_WaitAck();</span><br><span class="line">/* 6. 发送具体数据 */</span><br><span class="line">Driver_I2C_SendByte(byte);</span><br><span class="line">/* 7. 等待响应 */</span><br><span class="line">Driver_I2C2_WaitAck();</span><br><span class="line">/* 8. 停止信号 */</span><br><span class="line">Driver_I2C2_Stop();</span><br><span class="line">&#125;</span><br><span class="line">Delay_ms( 5 );</span><br><span class="line">&#125;</span><br><span class="line">uint8_t Inf_W24C02_ReadByte(uint8_t innerAddr)</span><br><span class="line">&#123;</span><br><span class="line">/* 1. 起始信号 */</span><br><span class="line">Driver_I2C2_Start();</span><br><span class="line">/* 2. 发送一个写地址 假写 */</span><br><span class="line">Driver_I2C_SendByte(ADDR);</span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure>
<p>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/* 3. 等待响应 */</span><br><span class="line">Driver_I2C2_WaitAck();</span><br><span class="line">/* 4. 发送内部地址 */</span><br><span class="line">Driver_I2C_SendByte(innerAddr);</span><br><span class="line">/* 5. 等待响应 */</span><br><span class="line">Driver_I2C2_WaitAck();</span><br><span class="line">/* 6. 起始信号 */</span><br><span class="line">Driver_I2C2_Start();</span><br><span class="line">/* 7. 发送读地址 真读 */</span><br><span class="line">Driver_I2C_SendByte(ADDR + 1 );</span><br><span class="line">/* 8. 等待响应 */</span><br><span class="line">Driver_I2C2_WaitAck();</span><br><span class="line">/* 9. 读取一个字节 */</span><br><span class="line">uint8_t byte = Driver_I2C_ReadByte();</span><br><span class="line">/* 10. 给对方一个非应答 */</span><br><span class="line">Driver_I2C2_NAck();</span><br><span class="line">/* 11. 停止信号 */</span><br><span class="line">Driver_I2C2_Stop();</span><br><span class="line">return byte;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @description: ⻚写入.一次写入多个字节</span><br><span class="line"> * @param &#123;uint8_t&#125; innerAddr</span><br><span class="line"> * @param &#123;uint8_t&#125; *bytes</span><br><span class="line"> * @param &#123;uint8_t&#125; len</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">void Inf_W24C02_WriteBytes(uint8_t innerAddr, uint8_t *bytes, uint8_t len)</span><br><span class="line">&#123;</span><br><span class="line">/* 1. 开始信号 */</span><br><span class="line">Driver_I2C2_Start();</span><br><span class="line">/* 2. 发送写地址 */</span><br><span class="line">Driver_I2C_SendByte(ADDR);</span><br><span class="line">/* 3. 等待响应 */</span><br><span class="line">uint8_t ack = Driver_I2C2_WaitAck();</span><br><span class="line">if (ack == ACK)</span><br></pre></td></tr></table></figure>
<p>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>82<br>83<br>84<br>85<br>86<br>87<br>88<br>89<br>90<br>91<br>92<br>93</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">/* 4. 发送内部地址 */</span><br><span class="line">Driver_I2C_SendByte(innerAddr);</span><br><span class="line">/* 5. 等待响应 */</span><br><span class="line">Driver_I2C2_WaitAck();</span><br><span class="line">for (uint8_t i = 0 ; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">/* 6. 发送具体数据 */</span><br><span class="line">Driver_I2C_SendByte(bytes[i]);</span><br><span class="line">/* 7. 等待响应 */</span><br><span class="line">Driver_I2C2_WaitAck();</span><br><span class="line">&#125;</span><br><span class="line">/* 8. 停止信号 */</span><br><span class="line">Driver_I2C2_Stop();</span><br><span class="line">&#125;</span><br><span class="line">Delay_ms( 5 );</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @description: 一次性读取多个字节的数据</span><br><span class="line"> * @param &#123;uint8_t&#125; innerAddr 起始位置</span><br><span class="line"> * @param &#123;uint8_t&#125; *bytes 存储读到的数据</span><br><span class="line"> * @param &#123;uint8_t&#125; len 读取的字节数</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">void Inf_W24C02_ReadBytes(uint8_t innerAddr, uint8_t *bytes, uint8_t len)</span><br><span class="line">&#123;</span><br><span class="line">/* 1. 起始信号 */</span><br><span class="line">Driver_I2C2_Start();</span><br><span class="line">/* 2. 发送一个写地址 假写 */</span><br><span class="line">Driver_I2C_SendByte(ADDR);</span><br><span class="line">/* 3. 等待响应 */</span><br><span class="line">Driver_I2C2_WaitAck();</span><br><span class="line">/* 4. 发送内部地址 */</span><br><span class="line">Driver_I2C_SendByte(innerAddr);</span><br><span class="line">/* 5. 等待响应 */</span><br><span class="line">Driver_I2C2_WaitAck();</span><br><span class="line">/* 6. 起始信号 */</span><br><span class="line">Driver_I2C2_Start();</span><br></pre></td></tr></table></figure>
<p>94<br>95<br>96<br>97<br>98<br>99<br>100<br>101<br>102<br>103<br>104<br>105<br>106<br>107<br>108<br>109<br>110<br>111<br>112<br>113<br>114<br>115<br>116<br>117<br>118<br>119<br>120<br>121<br>122<br>123<br>124<br>125<br>126<br>127<br>128<br>129<br>130<br>131<br>132<br>133<br>134<br>135<br>136<br>137<br>138<br>139<br>140</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">/* 7. 发送读地址 真读 */</span><br><span class="line">Driver_I2C_SendByte(ADDR + 1 );</span><br><span class="line">/* 8. 等待响应 */</span><br><span class="line">Driver_I2C2_WaitAck();</span><br><span class="line">for (uint8_t i = 0 ; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">/* 9. 读取一个字节 */</span><br><span class="line">bytes[i] = Driver_I2C_ReadByte();</span><br><span class="line">if (i &lt; len - 1 )</span><br><span class="line">&#123;</span><br><span class="line">Driver_I2C2_Ack();</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">Driver_I2C2_NAck();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/* 11. 停止信号 */</span><br><span class="line">Driver_I2C2_Stop();</span><br><span class="line">&#125;</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td></tr></table></figure>
<h3 id="3-I2C案例-2-：硬件实现I2C"><a href="#3-I2C案例-2-：硬件实现I2C" class="headerlink" title="3. I2C案例 2 ：硬件实现I2C"></a>3. I2C案例 2 ：硬件实现I2C</h3><h4 id="1-需求描述-6"><a href="#1-需求描述-6" class="headerlink" title="1. 需求描述"></a>1. 需求描述</h4><h6 id="使用STM32的I2C外设读写E2PROM，基于寄存器操作。不需要手动控制引脚电平的输入输出，只"><a href="#使用STM32的I2C外设读写E2PROM，基于寄存器操作。不需要手动控制引脚电平的输入输出，只" class="headerlink" title="使用STM32的I2C外设读写E2PROM，基于寄存器操作。不需要手动控制引脚电平的输入输出，只"></a>使用STM32的I2C外设读写E2PROM，基于寄存器操作。不需要手动控制引脚电平的输入输出，只</h6><h6 id="需要操作I2C外设对应的寄存器即可。"><a href="#需要操作I2C外设对应的寄存器即可。" class="headerlink" title="需要操作I2C外设对应的寄存器即可。"></a>需要操作I2C外设对应的寄存器即可。</h6><h4 id="2-硬件电路设计-5"><a href="#2-硬件电路设计-5" class="headerlink" title="2. 硬件电路设计"></a>2. 硬件电路设计</h4><h5 id="2-1-I2C外设简介"><a href="#2-1-I2C外设简介" class="headerlink" title="2.1 I2C外设简介"></a>2.1 I2C外设简介</h5><h6 id="前面我们用软件模拟I2C协议实现了通讯，代码写起来比较复杂。"><a href="#前面我们用软件模拟I2C协议实现了通讯，代码写起来比较复杂。" class="headerlink" title="前面我们用软件模拟I2C协议实现了通讯，代码写起来比较复杂。"></a>前面我们用软件模拟I2C协议实现了通讯，代码写起来比较复杂。</h6><h6 id="起始STM32有专⻔负责协议的I2C外设，只要配置好该外设，它就会自动根据协议要求产生通讯信"><a href="#起始STM32有专⻔负责协议的I2C外设，只要配置好该外设，它就会自动根据协议要求产生通讯信" class="headerlink" title="起始STM32有专⻔负责协议的I2C外设，只要配置好该外设，它就会自动根据协议要求产生通讯信"></a>起始STM32有专⻔负责协议的I2C外设，只要配置好该外设，它就会自动根据协议要求产生通讯信</h6><h6 id="号，收发数据并缓存起来，CPU只要检测该外设的状态和访问数据寄存器，就能完成数据收发。"><a href="#号，收发数据并缓存起来，CPU只要检测该外设的状态和访问数据寄存器，就能完成数据收发。" class="headerlink" title="号，收发数据并缓存起来，CPU只要检测该外设的状态和访问数据寄存器，就能完成数据收发。"></a>号，收发数据并缓存起来，CPU只要检测该外设的状态和访问数据寄存器，就能完成数据收发。</h6><h6 id="这种由硬件外设处理I2C协议的方式减轻了CPU的工作，且使软件设计更加简单。"><a href="#这种由硬件外设处理I2C协议的方式减轻了CPU的工作，且使软件设计更加简单。" class="headerlink" title="这种由硬件外设处理I2C协议的方式减轻了CPU的工作，且使软件设计更加简单。"></a>这种由硬件外设处理I2C协议的方式减轻了CPU的工作，且使软件设计更加简单。</h6><p>STM32的I2C外设可用作通讯的主机及从机，支持100Kbit/s和400Kbit/s的速率，支持 7 位、 10 位<br>设备地址，支持DMA数据传输，并具有数据校验功能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">它的I2C外设还支持SMBus2.0协议，SMBus协议与I2C类似。</span><br></pre></td></tr></table></figure>
<h5 id="2-2-STM32的I2C外设的功能框图"><a href="#2-2-STM32的I2C外设的功能框图" class="headerlink" title="2.2 STM32的I2C外设的功能框图"></a>2.2 STM32的I2C外设的功能框图</h5><h6 id="I2C的所有硬件架构都是根据图中左侧SCL线和SDA线展开的（其中的SMBA线用于SMBUS的警告信"><a href="#I2C的所有硬件架构都是根据图中左侧SCL线和SDA线展开的（其中的SMBA线用于SMBUS的警告信" class="headerlink" title="I2C的所有硬件架构都是根据图中左侧SCL线和SDA线展开的（其中的SMBA线用于SMBUS的警告信"></a>I2C的所有硬件架构都是根据图中左侧SCL线和SDA线展开的（其中的SMBA线用于SMBUS的警告信</h6><h6 id="号，I2C通讯没有使用）。STM32芯片有多个I2C外设，咱们现在用的这款有-2-个I-2C外设，它们的I2C通"><a href="#号，I2C通讯没有使用）。STM32芯片有多个I2C外设，咱们现在用的这款有-2-个I-2C外设，它们的I2C通" class="headerlink" title="号，I2C通讯没有使用）。STM32芯片有多个I2C外设，咱们现在用的这款有 2 个I 2C外设，它们的I2C通"></a>号，I2C通讯没有使用）。STM32芯片有多个I2C外设，咱们现在用的这款有 2 个I 2C外设，它们的I2C通</h6><h6 id="讯信号引出到不同的GPIO引脚上，使用时必须配置到这些指定的引脚。"><a href="#讯信号引出到不同的GPIO引脚上，使用时必须配置到这些指定的引脚。" class="headerlink" title="讯信号引出到不同的GPIO引脚上，使用时必须配置到这些指定的引脚。"></a>讯信号引出到不同的GPIO引脚上，使用时必须配置到这些指定的引脚。</h6><h4 id="3-软件设计（寄存器）-2"><a href="#3-软件设计（寄存器）-2" class="headerlink" title="3. 软件设计（寄存器）"></a>3. 软件设计（寄存器）</h4><h5 id="3-1-main-c-2"><a href="#3-1-main-c-2" class="headerlink" title="3.1 main.c"></a>3.1 main.c</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Driver_USART.h&quot;</span><br><span class="line">#include &quot;Inf_W24C02.h&quot;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">Driver_USART1_Init();</span><br><span class="line">printf(&quot;I2C 硬件 实验开始....\r\n&quot;);</span><br><span class="line">Inf_W24C02_Init();</span><br><span class="line">Inf_W24C02_WriteByte(0x00, &#x27;x&#x27;);</span><br><span class="line">Inf_W24C02_WriteByte(0x01, &#x27;y&#x27;);</span><br><span class="line">Inf_W24C02_WriteByte(0x02, &#x27;z&#x27;);</span><br><span class="line">uint8_t byte1 = Inf_W24C02_ReadByte(0x00);</span><br><span class="line">uint8_t byte2 = Inf_W24C02_ReadByte(0x01);</span><br><span class="line">uint8_t byte3 = Inf_W24C02_ReadByte(0x02);</span><br><span class="line">printf(&quot;%c\r\n&quot;, byte1);</span><br><span class="line">printf(&quot;%c\r\n&quot;, byte2);</span><br><span class="line">printf(&quot;%c\r\n&quot;, byte3);</span><br><span class="line">Inf_W24C02_WriteBytes(0x00, &quot;123456&quot;, 6 );</span><br><span class="line">uint8_t buff[ 100 ] = &#123; 0 &#125;;</span><br><span class="line">Inf_W24C02_ReadBytes(0x00, buff, 6 );</span><br><span class="line">printf(&quot;%s\r\n&quot;, buff);</span><br><span class="line">// 清零缓冲区</span><br><span class="line">memset(buff, 0 , sizeof(buff));</span><br><span class="line">Inf_W24C02_WriteBytes(0x00, &quot;0123456789abcdefghijk&quot;, 21 );</span><br><span class="line">Inf_W24C02_ReadBytes(0x00, buff, 21 );</span><br><span class="line">printf(&quot;%s\r\n&quot;, buff);</span><br><span class="line">while ( 1 )</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td></tr></table></figure>
<h5 id="3-2-Driver-I2C2-h"><a href="#3-2-Driver-I2C2-h" class="headerlink" title="3.2 Driver_I2C2.h"></a>3.2 Driver_I2C2.h</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#ifndef __DRIVER_I2C2_H</span><br><span class="line">#define __DRIVER_I2C2_H</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">#include &quot;Delay.h&quot;</span><br><span class="line">#include &quot;stm32f10x.h&quot;</span><br><span class="line">#include &quot;Driver_USART.h&quot;</span><br><span class="line">#define ACK 0</span><br><span class="line">#define NACK 1</span><br><span class="line">#define OK 1</span><br><span class="line">#define FAIL 0</span><br><span class="line">void Driver_I2C2_Init(void);</span><br><span class="line">uint8_t Driver_I2C2_Start(void);</span><br><span class="line">void Driver_I2C2_Stop(void);</span><br><span class="line">void Driver_I2C2_Ack(void);</span><br><span class="line">void Driver_I2C2_NAck(void);</span><br><span class="line">uint8_t Driver_I2C_SendAddr(uint8_t addr);</span><br><span class="line">uint8_t Driver_I2C_SendByte(uint8_t byte);</span><br><span class="line">uint8_t Driver_I2C_ReadByte(void);</span><br><span class="line">#endif</span><br><span class="line">3 4 5 6 7 8 9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td></tr></table></figure>
<h5 id="3-3-Driver-I2C2-c"><a href="#3-3-Driver-I2C2-c" class="headerlink" title="3.3 Driver_I2C2.c"></a>3.3 Driver_I2C2.c</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Driver_I2C2.h&quot;</span><br><span class="line">#include &quot;Delay.h&quot;</span><br><span class="line">#define I2C_DELAY Delay_us( 10 )</span><br><span class="line">/**</span><br><span class="line"> * @description: 初始化</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">void Driver_I2C2_Init(void)</span><br><span class="line">&#123;</span><br><span class="line">/* 1. 开启时钟 */</span><br><span class="line">/* 1.1 i2c硬件的时钟 */</span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">RCC-&gt;APB1ENR |= RCC_APB1ENR_I2C2EN;</span><br><span class="line">/* 1.2 GPIO时钟 */</span><br><span class="line">RCC-&gt;APB2ENR |= RCC_APB2ENR_IOPBEN;</span><br><span class="line">/* 2. 设置gpio的引脚的工作模式 */</span><br><span class="line">/*</span><br><span class="line">PB10-&gt;SCL</span><br><span class="line">PB11-&gt;SDA</span><br><span class="line">复用开漏输出: 既可以用于输出也可以输入. 外界要有上拉电阻.</span><br><span class="line">用于输入的时候,最好先输出一个1,把线的控制权交给外界.</span><br><span class="line">MODE=11 CNF=11</span><br><span class="line"> */</span><br><span class="line">/* 9.3.4.1 */</span><br><span class="line">GPIOB-&gt;CRH |= (GPIO_CRH_MODE10 | GPIO_CRH_MODE11 | GPIO_CRH_CNF10 |</span><br><span class="line">GPIO_CRH_CNF11);</span><br><span class="line">/* 3. 设置I2C2 */</span><br><span class="line">/* 3.1 配置硬件的工作模式  I2C  */</span><br><span class="line">I2C2-&gt;CR1 &amp;= ~I2C_CR1_SMBUS;</span><br><span class="line">/* 3.2 配置给I2C设备提供的时钟的频率 36MHz*/</span><br><span class="line">I2C2-&gt;CR2 |= 36 &lt;&lt; 0 ;</span><br><span class="line">/* 万一前面CR2低五位并不全是 0 咋办，应该还要现清 0 再写入吧，为啥这里不用呢？*/</span><br><span class="line">/* 因为数据手册清楚地写了CR2的复位值为0X0000 */</span><br><span class="line">/* 3.3 设置标准模式=0 or 快速模式=1 */</span><br><span class="line">I2C2-&gt;CCR &amp;= ~I2C_CCR_FS;</span><br><span class="line">/* 3.3 配置I2C产生时钟的频率 100K or 400K</span><br><span class="line">Thigh=CCR * Tcplk1</span><br><span class="line">ccr = Thigh/=Tcplk1 = 5us / (1/36)us = 180</span><br><span class="line">*/</span><br><span class="line">I2C2-&gt;CCR |= 180 &lt;&lt; 0 ;</span><br><span class="line">/* 3.4 时钟信号的上升沿</span><br><span class="line">100KHz的时候要求最大上升沿不超过1us(手册)。</span><br><span class="line">时钟频率是36MHz则 写入：1 /（1/36） + 1 = 37</span><br><span class="line">其实就是计算的 最大上升沿时间/时钟周期 + 1</span><br><span class="line">*/</span><br><span class="line">I2C2-&gt;TRISE |= 37 ;</span><br></pre></td></tr></table></figure>
<p>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31</p>
<p>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/* 3.4 使能I2C */</span><br><span class="line">I2C2-&gt;CR1 |= I2C_CR1_PE;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @description: 起始信号</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">uint8_t Driver_I2C2_Start(void)</span><br><span class="line">&#123;</span><br><span class="line">I2C2-&gt;CR1 |= I2C_CR1_START;</span><br><span class="line">uint16_t timeout = 0xffff;</span><br><span class="line">while (((I2C2-&gt;SR1 &amp; I2C_SR1_SB) == 0 ) &amp;&amp; timeout)</span><br><span class="line">&#123;</span><br><span class="line">timeout--;</span><br><span class="line">&#125;</span><br><span class="line">return timeout? OK : FAIL;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @description: 停止信号</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">void Driver_I2C2_Stop(void)</span><br><span class="line">&#123;</span><br><span class="line">/* 产生终止条件 */</span><br><span class="line">I2C2-&gt;CR1 |= I2C_CR1_STOP;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @description: 接收方产生应答信号</span><br><span class="line"> */</span><br><span class="line">void Driver_I2C2_Ack(void)</span><br><span class="line">&#123;</span><br><span class="line">/* 产生应答信号 */</span><br><span class="line">I2C2-&gt;CR1 |= I2C_CR1_ACK;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @description: 接收方产生非应答信号</span><br><span class="line"> */</span><br><span class="line">void Driver_I2C2_NAck(void)</span><br><span class="line">&#123;</span><br><span class="line">I2C2-&gt;CR1 &amp;= ~I2C_CR1_ACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>82<br>83<br>84<br>85<br>86<br>87<br>88<br>89<br>90<br>91<br>92<br>93<br>94<br>95<br>96<br>97<br>98<br>99<br>100<br>101<br>102<br>103<br>104<br>105<br>106<br>107</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @description: 发送一个设备地址</span><br><span class="line"> * @param &#123;uint8_t&#125; byte</span><br><span class="line"> */</span><br><span class="line">uint8_t Driver_I2C_SendAddr(uint8_t addr)</span><br><span class="line">&#123;</span><br><span class="line">// 把要发送的数据写入到数据寄存器，其实可以加上判断DR寄存器的TXE位，查看一下是否为空</span><br><span class="line">I2C2-&gt;DR = addr;</span><br><span class="line">timeout = 0xffff;</span><br><span class="line">// 将设备地址发送给数据寄存器后再判断SR1的ADDR位</span><br><span class="line">while (((I2C2-&gt;SR1 &amp; I2C_SR1_ADDR) == 0 ) &amp;&amp; timeout)</span><br><span class="line">&#123;</span><br><span class="line">timeout--;</span><br><span class="line">&#125;</span><br><span class="line">/* 9.3.4.2 */</span><br><span class="line">if (timeout)</span><br><span class="line">&#123;</span><br><span class="line">I2C2-&gt;SR2;/* 读取SR1寄存器后，对SR2寄存器的读操作将清除ADDR位 */</span><br><span class="line">&#125;</span><br><span class="line">return timeout? OK : FAIL;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @description: 发送一个字节的数据（数据和内部地址适用）</span><br><span class="line"> * @param &#123;uint8_t&#125; byte 要发送的字节</span><br><span class="line"> */</span><br><span class="line">uint8_t Driver_I2C_SendByte(uint8_t byte)</span><br><span class="line">&#123;</span><br><span class="line">uint16_t timeout = 0xffff;</span><br><span class="line">//1 先判断寄存器，假如寄存器不空就要等待至空状态（在超时时间内）后写入数据</span><br><span class="line">while (((I2C2-&gt;SR1 &amp; I2C_SR1_TXE) == 0 ) &amp;&amp; timeout)</span><br><span class="line">&#123;</span><br><span class="line">timeout--;</span><br><span class="line">&#125;</span><br><span class="line">// 把要发送的数据写入到数据寄存器，由于上一次执行已经读取SR寄存器，这行代码执行完后便</span><br><span class="line">将BTF置 0</span><br><span class="line">I2C2-&gt;DR = byte;</span><br><span class="line">timeout = 0xffff;</span><br><span class="line">//2 判断寄存器，假如数据没发送完成就要等待数据发送完成</span><br></pre></td></tr></table></figure>
<p>108<br>109<br>110<br>111<br>112<br>113<br>114<br>115<br>116<br>117<br>118<br>119<br>120<br>121<br>122<br>123<br>124<br>125<br>126<br>127<br>128<br>129<br>130<br>131<br>132<br>133<br>134<br>135<br>136<br>137<br>138<br>139<br>140<br>141<br>142<br>143<br>144<br>145<br>146<br>147<br>148</p>
<p>149<br>150<br>151<br>152<br>153</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">while (((I2C2-&gt;SR1 &amp; I2C_SR1_BTF) == 0 ) &amp;&amp; timeout)</span><br><span class="line">&#123;</span><br><span class="line">timeout--;</span><br><span class="line">&#125;</span><br><span class="line">return timeout? OK : FAIL;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @description: 读一个字节的数据</span><br><span class="line"> * @param &#123;uint8_t&#125; byte 要发送的字节</span><br><span class="line"> */</span><br><span class="line">uint8_t Driver_I2C_ReadByte(void)</span><br><span class="line">&#123;</span><br><span class="line">uint16_t timeout = 0xffff;</span><br><span class="line">// 等待SR1寄存器RXNE位，一旦非空表示收到数据（在超时时间内），可以读取数据</span><br><span class="line">while (((I2C2-&gt;SR1 &amp; I2C_SR1_RXNE) == 0 ) &amp;&amp; timeout)</span><br><span class="line">&#123;</span><br><span class="line">timeout--;</span><br><span class="line">&#125;</span><br><span class="line">// 把数据寄存器的值返回</span><br><span class="line">uint8_t data = timeout? I2C2-&gt;DR : 0 ;</span><br><span class="line">return data;</span><br><span class="line">&#125;</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td></tr></table></figure>
<p>你可能很好奇为啥要加个超时时间？万一有多个主机同时操作，在while循环里就要一直等待，所<br>以最好加个超时时间表示等待成功或失败！</p>
<h5 id="3-4-Inf-W24C02-h"><a href="#3-4-Inf-W24C02-h" class="headerlink" title="3.4 Inf_W24C02.h"></a>3.4 Inf_W24C02.h</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#ifndef __INF_W24C02_H</span><br><span class="line">#define __INF_W24C02_H</span><br><span class="line">#include &quot;Driver_I2C2.h&quot;</span><br><span class="line">#include &quot;string.h&quot;</span><br><span class="line">#define ADDR 0xA0</span><br><span class="line">void Inf_W24C02_Init(void);</span><br><span class="line">void Inf_W24C02_WriteByte(uint8_t innerAddr, uint8_t byte);</span><br><span class="line">uint8_t Inf_W24C02_ReadByte(uint8_t innerAddr);</span><br><span class="line">void Inf_W24C02_WriteBytes(uint8_t innerAddr, uint8_t *bytes, uint8_t len);</span><br><span class="line">void Inf_W24C02_ReadBytes(uint8_t innerAddr, uint8_t *bytes, uint8_t len);</span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17 #endif</span><br></pre></td></tr></table></figure>
<h5 id="3-5-Inf-W24C02-c"><a href="#3-5-Inf-W24C02-c" class="headerlink" title="3.5 Inf_W24C02.c"></a>3.5 Inf_W24C02.c</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Inf_W24C02.h&quot;</span><br><span class="line">void Inf_W24C02_Init(void)</span><br><span class="line">&#123;</span><br><span class="line">Driver_I2C2_Init();</span><br><span class="line">&#125;</span><br><span class="line">void Inf_W24C02_WriteByte(uint8_t innerAddr, uint8_t byte)</span><br><span class="line">&#123;</span><br><span class="line">uint8_t ack;/* 用来测试写字节是否成功的变量，测完就注释掉要不然影响时序 */</span><br><span class="line">/* 1. 开始信号 */</span><br><span class="line">ack = Driver_I2C2_Start();</span><br><span class="line">// printf(&quot;start_ack=%d\r\n&quot;, ack);</span><br><span class="line">/* 2. 发送写地址 */</span><br><span class="line">ack = Driver_I2C_SendAddr(ADDR);</span><br><span class="line">// printf(&quot;addr_ack=%d\r\n&quot;, ack);</span><br><span class="line">/* 4. 发送内部地址 */</span><br><span class="line">ack = Driver_I2C_SendByte(innerAddr);</span><br><span class="line">// printf(&quot;inner_ack=%d\r\n&quot;, ack);</span><br><span class="line">/* 6. 发送具体数据 */</span><br><span class="line">ack = Driver_I2C_SendByte(byte);</span><br><span class="line">// printf(&quot;byte_ack=%d\r\n&quot;, ack);</span><br><span class="line">/* 8. 停止信号 */</span><br><span class="line">Driver_I2C2_Stop();</span><br><span class="line">/* 9.3.4.3 */</span><br><span class="line">Delay_ms( 5 );</span><br><span class="line">&#125;</span><br><span class="line">uint8_t Inf_W24C02_ReadByte(uint8_t innerAddr)</span><br><span class="line">&#123;</span><br><span class="line">/* 1. 起始信号 */</span><br><span class="line">Driver_I2C2_Start();</span><br><span class="line">/* 2. 发送一个写地址 假写 */</span><br><span class="line">Driver_I2C_SendAddr(ADDR);</span><br><span class="line">/* 4. 发送内部地址 */</span><br><span class="line">Driver_I2C_SendByte(innerAddr);</span><br><span class="line">/* 6. 起始信号 */</span><br><span class="line">Driver_I2C2_Start();</span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">/* 7. 发送读地址 真读 */</span><br><span class="line">Driver_I2C_SendAddr(ADDR + 1 );</span><br><span class="line">/* 10. 产生一个非应答信号 */</span><br><span class="line">Driver_I2C2_NAck();</span><br><span class="line">/* 11. 停止信号 */</span><br><span class="line">Driver_I2C2_Stop();</span><br><span class="line">/* 9. 读取一个字节 */</span><br><span class="line">uint8_t byte = Driver_I2C_ReadByte();</span><br><span class="line">return byte;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @description: ⻚写入.一次写入多个字节</span><br><span class="line"> * @param &#123;uint8_t&#125; innerAddr</span><br><span class="line"> * @param &#123;uint8_t&#125; *bytes</span><br><span class="line"> * @param &#123;uint8_t&#125; len</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">void Inf_W24C02_WriteBytes(uint8_t innerAddr, uint8_t *bytes, uint8_t len)</span><br><span class="line">&#123;</span><br><span class="line">/* 1. 开始信号 */</span><br><span class="line">Driver_I2C2_Start();</span><br><span class="line">/* 2. 发送写地址 */</span><br><span class="line">Driver_I2C_SendAddr(ADDR);</span><br><span class="line">/* 4. 发送内部地址 */</span><br><span class="line">Driver_I2C_SendByte(innerAddr);</span><br><span class="line">for (uint8_t i = 0 ; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">/* 6. 发送具体数据 */</span><br><span class="line">Driver_I2C_SendByte(bytes[i]);</span><br><span class="line">&#125;</span><br><span class="line">/* 8. 停止信号 */</span><br><span class="line">Driver_I2C2_Stop();</span><br><span class="line">Delay_ms( 5 );</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @description: 一次性读取多个字节的数据</span><br><span class="line"> * @param &#123;uint8_t&#125; innerAddr 起始位置</span><br></pre></td></tr></table></figure>
<p>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>82<br>83<br>84<br>85<br>86<br>87<br>88</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"> * @param &#123;uint8_t&#125; *bytes 存储读到的数据</span><br><span class="line"> * @param &#123;uint8_t&#125; len 读取的字节数</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">void Inf_W24C02_ReadBytes(uint8_t innerAddr, uint8_t *bytes, uint8_t len)</span><br><span class="line">&#123;</span><br><span class="line">/* 1. 起始信号 */</span><br><span class="line">Driver_I2C2_Start();</span><br><span class="line">/* 2. 发送一个写地址 假写 */</span><br><span class="line">Driver_I2C_SendAddr(ADDR);</span><br><span class="line">/* 4. 发送内部地址 */</span><br><span class="line">Driver_I2C_SendByte(innerAddr);</span><br><span class="line">/* 6. 起始信号 */</span><br><span class="line">Driver_I2C2_Start();</span><br><span class="line">/* 9.3.4.3 */</span><br><span class="line">/* 7. 发送读地址 真读 */</span><br><span class="line">Driver_I2C_SendAddr(ADDR + 1 );</span><br><span class="line">for (uint8_t i = 0 ; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">/* 9. 读取一个字节 都要产生一个应答信号*/</span><br><span class="line">if (i &lt; len - 1 )</span><br><span class="line">&#123;</span><br><span class="line">Driver_I2C2_Ack();</span><br><span class="line">&#125;</span><br><span class="line">else /* EV7_1 */</span><br><span class="line">&#123;</span><br><span class="line">Driver_I2C2_NAck();</span><br><span class="line">/* 11. 停止信号 */</span><br><span class="line">Driver_I2C2_Stop();</span><br><span class="line">&#125;</span><br><span class="line">bytes[i] = Driver_I2C_ReadByte();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td></tr></table></figure>
<h4 id="4-注意-1"><a href="#4-注意-1" class="headerlink" title="4. 注意"></a>4. 注意</h4><h6 id="1-GPIO为复用功能"><a href="#1-GPIO为复用功能" class="headerlink" title="1. GPIO为复用功能 "></a>1. GPIO为复用功能 </h6><h6 id="涉及到寄存器的配置！注意：我们的PB10、PB11此时并不是两个普通的GPIO而是复用作IIC的"><a href="#涉及到寄存器的配置！注意：我们的PB10、PB11此时并不是两个普通的GPIO而是复用作IIC的" class="headerlink" title="涉及到寄存器的配置！注意：我们的PB10、PB11此时并不是两个普通的GPIO而是复用作IIC的"></a>涉及到寄存器的配置！注意：我们的PB10、PB11此时并不是两个普通的GPIO而是复用作IIC的</h6><h6 id="IO输出。"><a href="#IO输出。" class="headerlink" title="IO输出。 "></a>IO输出。 </h6><h6 id="2-在I²C通信中，发送完设备地址后需要清除ADDR寄存器？"><a href="#2-在I²C通信中，发送完设备地址后需要清除ADDR寄存器？" class="headerlink" title="2. 在I²C通信中，发送完设备地址后需要清除ADDR寄存器？ "></a>2. 在I²C通信中，发送完设备地址后需要清除ADDR寄存器？ </h6><h6 id="清除ADDR寄存器的目的是为了确保下一次的I²C传输或操作不会受到上一次的地址信息的干扰。"><a href="#清除ADDR寄存器的目的是为了确保下一次的I²C传输或操作不会受到上一次的地址信息的干扰。" class="headerlink" title="清除ADDR寄存器的目的是为了确保下一次的I²C传输或操作不会受到上一次的地址信息的干扰。"></a>清除ADDR寄存器的目的是为了确保下一次的I²C传输或操作不会受到上一次的地址信息的干扰。</h6><h6 id="如果不清除ADDR寄存器，可能会导致通信错误或设备不正确响应。"><a href="#如果不清除ADDR寄存器，可能会导致通信错误或设备不正确响应。" class="headerlink" title="如果不清除ADDR寄存器，可能会导致通信错误或设备不正确响应。 "></a>如果不清除ADDR寄存器，可能会导致通信错误或设备不正确响应。 </h6><h4 id="🥖-1-I²C地址传输阶段-："><a href="#🥖-1-I²C地址传输阶段-：" class="headerlink" title="🥖^1. I²C地址传输阶段 ："></a>🥖^1. I²C地址传输阶段 ：</h4><h3 id="◦-在I²C通信中，主设备（通常是微控制器）需要向从设备发送数据或者请求数据。通信"><a href="#◦-在I²C通信中，主设备（通常是微控制器）需要向从设备发送数据或者请求数据。通信" class="headerlink" title="◦ 在I²C通信中，主设备（通常是微控制器）需要向从设备发送数据或者请求数据。通信"></a>◦ 在I²C通信中，主设备（通常是微控制器）需要向从设备发送数据或者请求数据。通信</h3><h6 id="开始时，主设备首先发送一个设备地址和读写位（R-W位）给总线上的所有设备。"><a href="#开始时，主设备首先发送一个设备地址和读写位（R-W位）给总线上的所有设备。" class="headerlink" title="开始时，主设备首先发送一个设备地址和读写位（R/W位）给总线上的所有设备。"></a>开始时，主设备首先发送一个设备地址和读写位（R/W位）给总线上的所有设备。</h6><h6 id="2-ADDR寄存器的作用-："><a href="#2-ADDR寄存器的作用-：" class="headerlink" title="2. ADDR寄存器的作用 ："></a>2. ADDR寄存器的作用 ：</h6><h3 id="◦-ADDR寄存器用于存储要发送的设备地址和读写位。当主设备开始传输设备地址后，这"><a href="#◦-ADDR寄存器用于存储要发送的设备地址和读写位。当主设备开始传输设备地址后，这" class="headerlink" title="◦ ADDR寄存器用于存储要发送的设备地址和读写位。当主设备开始传输设备地址后，这"></a>◦ ADDR寄存器用于存储要发送的设备地址和读写位。当主设备开始传输设备地址后，这</h3><h6 id="些信息会被加载到ADDR寄存器中。"><a href="#些信息会被加载到ADDR寄存器中。" class="headerlink" title="些信息会被加载到ADDR寄存器中。"></a>些信息会被加载到ADDR寄存器中。</h6><h6 id="3-ADDR寄存器的清除-："><a href="#3-ADDR寄存器的清除-：" class="headerlink" title="3. ADDR寄存器的清除 ："></a>3. ADDR寄存器的清除 ：</h6><h3 id="◦-在I²C通信中，主设备发送完设备地址后，通常需要软件来清除ADDR寄存器中的地址"><a href="#◦-在I²C通信中，主设备发送完设备地址后，通常需要软件来清除ADDR寄存器中的地址" class="headerlink" title="◦ 在I²C通信中，主设备发送完设备地址后，通常需要软件来清除ADDR寄存器中的地址"></a>◦ 在I²C通信中，主设备发送完设备地址后，通常需要软件来清除ADDR寄存器中的地址</h3><h6 id="信息。这是因为I²C控制器通常不会自动清除ADDR寄存器的内容。"><a href="#信息。这是因为I²C控制器通常不会自动清除ADDR寄存器的内容。" class="headerlink" title="信息。这是因为I²C控制器通常不会自动清除ADDR寄存器的内容。 "></a>信息。这是因为I²C控制器通常不会自动清除ADDR寄存器的内容。 </h6><h6 id="4-软件操作-："><a href="#4-软件操作-：" class="headerlink" title="4. 软件操作 ："></a>4. 软件操作 ：</h6><h3 id="◦-在大多数情况下，软件需要在发送设备地址后显式地清除ADDR寄存器。这通常通过写"><a href="#◦-在大多数情况下，软件需要在发送设备地址后显式地清除ADDR寄存器。这通常通过写" class="headerlink" title="◦ 在大多数情况下，软件需要在发送设备地址后显式地清除ADDR寄存器。这通常通过写"></a>◦ 在大多数情况下，软件需要在发送设备地址后显式地清除ADDR寄存器。这通常通过写</h3><h6 id="入特定的控制位或寄存器来完成，具体的操作取决于使用的I²C控制器和微控制器。"><a href="#入特定的控制位或寄存器来完成，具体的操作取决于使用的I²C控制器和微控制器。" class="headerlink" title="入特定的控制位或寄存器来完成，具体的操作取决于使用的I²C控制器和微控制器。"></a>入特定的控制位或寄存器来完成，具体的操作取决于使用的I²C控制器和微控制器。</h6><h6 id="5-硬件实现的例外-："><a href="#5-硬件实现的例外-：" class="headerlink" title="5. 硬件实现的例外 ："></a>5. 硬件实现的例外 ：</h6><h3 id="◦-尽管大多数情况下需要软件操作来清除ADDR寄存器，有些特定的I²C控制器和微控制"><a href="#◦-尽管大多数情况下需要软件操作来清除ADDR寄存器，有些特定的I²C控制器和微控制" class="headerlink" title="◦ 尽管大多数情况下需要软件操作来清除ADDR寄存器，有些特定的I²C控制器和微控制"></a>◦ 尽管大多数情况下需要软件操作来清除ADDR寄存器，有些特定的I²C控制器和微控制</h3><h6 id="器可能提供了自动清除的功能，但这并不是通用情况。"><a href="#器可能提供了自动清除的功能，但这并不是通用情况。" class="headerlink" title="器可能提供了自动清除的功能，但这并不是通用情况。"></a>器可能提供了自动清除的功能，但这并不是通用情况。</h6><p><strong>voidInf_W24C02_ReadBytes(uint8_tinnerAddr,uint8_t*bytes,uint8_tlen)的使用</strong> <br><strong>多字节不能读取太快，不然会发生数据覆盖。</strong><br>还有就是最后为啥要先产生应答信号后再读取数据，而不是先读取数据之后产生应答信号（ <strong>无论<br>是写入数据还是读取数据，主机在发送完地址后等待从机的应答信号</strong> ）？</p>
<ul>
<li><strong>实际是用上一次的响应信号来设置这一次的响应,读完数据硬件就立即响应，如果不先产生应答，硬</strong><br><strong>件响应的是从机非应答信号，这样读取多字节数据就可以了,而且最后一个字节要注意EV7_1包括响</strong><br><strong>应和停止！</strong></li>
<li><strong>主要是硬件响应太快，所以要先准备好应答信号，再由硬件响应。一个字节就不用考虑（就和做一</strong><br><strong>次生意是一个意思，哈哈）！</strong></li>
</ul>
<h4 id="5-软件设计（HAL库）-2"><a href="#5-软件设计（HAL库）-2" class="headerlink" title="5. 软件设计（HAL库）"></a>5. 软件设计（HAL库）</h4><h5 id="5-1-STM32CubeMx中配置"><a href="#5-1-STM32CubeMx中配置" class="headerlink" title="5.1 STM32CubeMx中配置"></a>5.1 STM32CubeMx中配置</h5><h5 id="5-2-main-c"><a href="#5-2-main-c" class="headerlink" title="5.2 main.c"></a>5.2 main.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">HAL_Init();</span><br><span class="line">SystemClock_Config();</span><br><span class="line">MX_GPIO_Init();</span><br><span class="line">MX_USART1_UART_Init();</span><br><span class="line">Inf_W24C02_Init();</span><br><span class="line">Inf_W24C02_WriteByte(<span class="number">0x00</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="type">uint8_t</span> c = Inf_W24C02_ReadByte(<span class="number">0x00</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;c=%c\r\n&quot;</span>, c);</span><br><span class="line"><span class="type">uint8_t</span> wbuff[ <span class="number">10</span> ] = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line">Inf_W24C02_WriteBytes(<span class="number">0x01</span>, wbuff, <span class="number">5</span> );</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;c=%c\r\n&quot;</span>, Inf_W24C02_ReadByte(<span class="number">0x01</span>));</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;c=%c\r\n&quot;</span>, Inf_W24C02_ReadByte(<span class="number">0x02</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;c=%c\r\n&quot;</span>, Inf_W24C02_ReadByte(<span class="number">0x03</span>));</span><br><span class="line"><span class="type">uint8_t</span> buff[ <span class="number">10</span> ] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">Inf_W24C02_ReadBytes(<span class="number">0x00</span>, buff, <span class="number">6</span> );</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;buff=%s\r\n&quot;</span>, buff);</span><br><span class="line"><span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">19</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="number">24</span></span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="number">26</span></span><br><span class="line"><span class="number">27</span></span><br><span class="line"><span class="number">28</span></span><br><span class="line"><span class="number">29</span></span><br></pre></td></tr></table></figure>
<h5 id="5-3-Inf-W24C02-h"><a href="#5-3-Inf-W24C02-h" class="headerlink" title="5.3 Inf_W24C02.h"></a>5.3 Inf_W24C02.h</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#ifndef __INF_W24C02_H</span><br><span class="line">#define __INF_W24C02_H</span><br><span class="line">#include &quot;string.h&quot;</span><br><span class="line">#include &quot;i2c.h&quot;</span><br><span class="line">#define ADDR 0xA0</span><br><span class="line">void Inf_W24C02_Init(void);</span><br><span class="line">void Inf_W24C02_WriteByte(uint8_t innerAddr, uint8_t byte);</span><br><span class="line">uint8_t Inf_W24C02_ReadByte(uint8_t innerAddr);</span><br><span class="line">void Inf_W24C02_WriteBytes(uint8_t innerAddr, uint8_t *bytes, uint8_t len);</span><br><span class="line">void Inf_W24C02_ReadBytes(uint8_t innerAddr, uint8_t *bytes, uint8_t len);</span><br><span class="line">#endif</span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td></tr></table></figure>
<h5 id="5-4-Inf-W24C02-c"><a href="#5-4-Inf-W24C02-c" class="headerlink" title="5.4 Inf_W24C02.c"></a>5.4 Inf_W24C02.c</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;Inf_W24C02.h&quot;</span><br><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">void Inf_W24C02_Init(void)</span><br><span class="line">&#123;</span><br><span class="line">MX_I2C2_Init();</span><br><span class="line">&#125;</span><br><span class="line">1 2 3 4 5 6 7 8</span><br><span class="line">void Inf_W24C02_WriteByte(uint8_t innerAddr, uint8_t byte)</span><br><span class="line">&#123;</span><br><span class="line">HAL_I2C_Mem_Write(&amp;hi2c2, ADDR, innerAddr, I2C_MEMADD_SIZE_8BIT, &amp;byte, 1 ,</span><br><span class="line">2000 );</span><br><span class="line">HAL_Delay( 5 );</span><br><span class="line">&#125;</span><br><span class="line">uint8_t Inf_W24C02_ReadByte(uint8_t innerAddr)</span><br><span class="line">&#123;</span><br><span class="line">uint8_t byte;</span><br><span class="line">HAL_I2C_Mem_Read(&amp;hi2c2, ADDR + 1 , innerAddr, I2C_MEMADD_SIZE_8BIT, &amp;byte,</span><br><span class="line">1 , 2000 );</span><br><span class="line">return byte;</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @description: ⻚写入.一次写入多个字节</span><br><span class="line"> * @param &#123;uint8_t&#125; innerAddr</span><br><span class="line"> * @param &#123;uint8_t&#125; *bytes</span><br><span class="line"> * @param &#123;uint8_t&#125; len</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">void Inf_W24C02_WriteBytes(uint8_t innerAddr, uint8_t *bytes, uint8_t len)</span><br><span class="line">&#123;</span><br><span class="line">HAL_I2C_Mem_Write(&amp;hi2c2, ADDR, innerAddr, I2C_MEMADD_SIZE_8BIT, bytes,</span><br><span class="line">len, 2000 );</span><br><span class="line">HAL_Delay( 5 );</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @description: 一次性读取多个字节的数据</span><br><span class="line"> * @param &#123;uint8_t&#125; innerAddr 起始位置</span><br><span class="line"> * @param &#123;uint8_t&#125; *bytes 存储读到的数据</span><br><span class="line"> * @param &#123;uint8_t&#125; len 读取的字节数</span><br><span class="line"> * @return &#123;*&#125;</span><br><span class="line"> */</span><br><span class="line">void Inf_W24C02_ReadBytes(uint8_t innerAddr, uint8_t *bytes, uint8_t len)</span><br><span class="line">&#123;</span><br><span class="line">HAL_I2C_Mem_Read(&amp;hi2c2, ADDR + 1 , innerAddr, I2C_MEMADD_SIZE_8BIT, bytes,</span><br><span class="line">len, 2000 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://qchilli.github.io">Chilli</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://qchilli.github.io/2024/09/01/%E6%9D%82%E8%B0%88/sb/">https://qchilli.github.io/2024/09/01/%E6%9D%82%E8%B0%88/sb/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://qchilli.github.io" target="_blank">Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://source.fomal.cc/img/default_cover_3.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/09/01/%E8%93%9D%E6%A1%A5%E6%9D%AF/MCU/mm/" title="第2篇文章"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_9.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">第2篇文章</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Chilli</div><div class="author-info__description">成长</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" href="https://qchilli.github.io/"><i class="fab fa-github"></i><span>🛴前往小家...</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xxxxx" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#STM32%E5%8D%95%E7%89%87%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%AF%87"><span class="toc-number">1.</span> <span class="toc-text">STM32单片机基础篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%BC%80%E5%8F%91%E6%9D%BF%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.</span> <span class="toc-text">1. 开发板简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%BC%80%E5%8F%91%E6%9D%BF%E5%AE%9E%E7%89%A9%E5%9B%BE"><span class="toc-number">1.2.</span> <span class="toc-text">1. 开发板实物图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%A0%B8%E5%BF%83%E6%9D%BF%E5%8E%9F%E7%90%86%E5%9B%BE"><span class="toc-number">1.3.</span> <span class="toc-text">2. 核心板原理图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%89%A9%E5%B1%95%E6%9D%BF%E5%8E%9F%E7%90%86%E5%9B%BE"><span class="toc-number">1.4.</span> <span class="toc-text">3. 扩展板原理图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-STM32%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.5.</span> <span class="toc-text">4. STM32最小系统</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#STM32%E5%8D%95%E7%89%87%E6%9C%BA%E8%83%BD%E5%B7%A5%E4%BD%9C%E7%9A%84%E6%9C%80%E5%B0%8F%E5%A4%96%E5%9B%B4%E7%94%B5%E8%B7%AF%E5%B0%B1%E5%8F%AB-%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F-%E3%80%82"><span class="toc-number">1.5.0.0.0.1.</span> <span class="toc-text">STM32单片机能工作的最小外围电路就叫 最小系统 。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F%E9%80%9A%E5%B8%B8%E5%8C%85%E6%8B%AC%EF%BC%9A-STM32%E8%8A%AF%E7%89%87%E3%80%81%E7%94%B5%E6%BA%90%E3%80%81%E6%97%B6%E9%92%9F%E3%80%81%E4%B8%8B%E8%BD%BD%E8%B0%83%E8%AF%95%E5%92%8C%E5%A4%8D%E4%BD%8D-5-%E9%83%A8%E5%88%86%E7%BB%84%E6%88%90%E3%80%82"><span class="toc-number">1.5.0.0.0.2.</span> <span class="toc-text">最小系统通常包括： STM32芯片、电源、时钟、下载调试和复位 5 部分组成。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#1-STM32%E8%8A%AF%E7%89%87"><span class="toc-number">1.5.0.0.0.3.</span> <span class="toc-text">1. STM32芯片</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%80%89%E7%94%A8%E7%9A%84%E6%98%AF-STM32F103ZET6-%E8%BF%99%E6%AC%BE%E8%8A%AF%E7%89%87%E3%80%82"><span class="toc-number">1.5.0.0.0.4.</span> <span class="toc-text">选用的是 STM32F103ZET6 这款芯片。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E7%94%B5%E6%BA%90"><span class="toc-number">1.5.0.0.0.5.</span> <span class="toc-text">2. 电源</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%8D%E7%94%A8%E9%A2%9D%E5%A4%96%E5%86%8D%E6%8E%A5%E4%B8%B2%E5%8F%A3%E6%A8%A1%E5%9D%97%E3%80%82"><span class="toc-number">1.5.0.0.0.6.</span> <span class="toc-text">不用额外再接串口模块。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E6%97%B6%E9%92%9F"><span class="toc-number">1.5.0.0.0.7.</span> <span class="toc-text">3. 时钟</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#SMT32%E6%8F%90%E4%BE%9B%E4%BA%86%E4%B8%A4%E8%B7%AF%E5%A4%96%E9%83%A8%E6%97%B6%E9%92%9F%EF%BC%9A-%E5%A4%96%E9%83%A8%E9%AB%98%E9%80%9F%E6%97%B6%E9%92%9F%E5%92%8C%E5%A4%96%E9%83%A8%E4%BD%8E%E9%80%9F%E6%97%B6%E9%92%9F-%E3%80%82"><span class="toc-number">1.5.0.0.0.8.</span> <span class="toc-text">SMT32提供了两路外部时钟： 外部高速时钟和外部低速时钟 。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-%E5%A4%8D%E4%BD%8D"><span class="toc-number">1.5.0.0.0.9.</span> <span class="toc-text">4. 复位</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5-%E4%B8%8B%E8%BD%BD%E8%B0%83%E8%AF%95"><span class="toc-number">1.5.0.0.0.10.</span> <span class="toc-text">5. 下载调试</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%82%B9%E4%BA%AELED%E7%81%AF%E6%A1%88%E4%BE%8B%EF%BC%88%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%89"><span class="toc-number">1.6.</span> <span class="toc-text">2. 点亮LED灯案例（寄存器）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%88%91%E4%BB%AC%E9%A6%96%E5%85%88%E4%BD%BF%E7%94%A8%E5%9F%BA%E4%BA%8E%E5%AF%84%E5%AD%98%E5%99%A8%E5%BC%80%E5%8F%91%E6%96%B9%E5%BC%8F%E7%82%B9%E4%BA%AE%E7%AC%AC%E4%B8%80%E4%B8%AALED%E7%81%AF%E3%80%82"><span class="toc-number">1.6.0.0.0.1.</span> <span class="toc-text">我们首先使用基于寄存器开发方式点亮第一个LED灯。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%9C%9F%E9%97%B4%E4%BC%9A%E6%B6%89%E5%8F%8A%E5%88%B0%E4%B8%80%E4%BA%9B%E5%AF%84%E5%AD%98%E5%99%A8%E7%9F%A5%E8%AF%86%EF%BC%8C%E5%85%88%E4%B8%8D%E8%A6%81%E6%B7%B1%E7%A9%B6%EF%BC%8C%E5%90%8E%E9%9D%A2%E5%86%8D%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E3%80%82%E7%8E%B0%E5%9C%A8%E8%A6%81%E5%81%9A%E7%9A%84%E5%B0%B1%E6%98%AF%E7%82%B9%E4%BA%AE%E7%AC%AC%E4%B8%80"><span class="toc-number">1.6.0.0.0.2.</span> <span class="toc-text">在代码期间会涉及到一些寄存器知识，先不要深究，后面再详细介绍。现在要做的就是点亮第一</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%AALED%E7%81%AF%E3%80%82"><span class="toc-number">1.6.0.0.0.3.</span> <span class="toc-text">个LED灯。</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%9C%80%E6%B1%82%E6%8F%8F%E8%BF%B0"><span class="toc-number">1.6.1.</span> <span class="toc-text">1. 需求描述</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E4%BD%93%E9%AA%8CSTM32%E5%BC%80%E5%8F%91%EF%BC%9A%E7%82%B9%E4%BA%AELED1%E3%80%82"><span class="toc-number">1.6.1.0.0.1.</span> <span class="toc-text">快速体验STM32开发：点亮LED1。</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.6.2.</span> <span class="toc-text">2. 硬件电路设计</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#LED1-LED3%E6%98%AF%E6%99%AE%E9%80%9ALED%E7%81%AF%EF%BC%8CLED4%E4%B8%BA%E7%94%B5%E6%BA%90%E6%8C%87%E7%A4%BA%E7%81%AF%E3%80%82"><span class="toc-number">1.6.2.0.0.1.</span> <span class="toc-text">LED1-LED3是普通LED灯，LED4为电源指示灯。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-number">1.6.2.0.0.2.</span> <span class="toc-text">说明：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%88%9B%E5%BB%BA%E9%A1%B9%E7%9B%AE%E5%B7%A5%E7%A8%8B"><span class="toc-number">1.6.3.</span> <span class="toc-text">3. 创建项目工程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E5%B7%A5%E7%A8%8B%E5%87%86%E5%A4%87"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">1. 创建工程准备</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E9%9C%80%E8%A6%81%E7%9A%84%E7%9B%AE%E5%BD%95"><span class="toc-number">1.6.3.1.0.1.</span> <span class="toc-text">1. 创建需要的目录</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E5%87%86%E5%A4%87%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6"><span class="toc-number">1.6.3.1.0.2.</span> <span class="toc-text">2. 准备启动文件</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#STM32%E7%A8%8B%E5%BA%8F%E9%9C%80%E8%A6%81%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6%EF%BC%8C%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E6%8F%90%E5%89%8D%E5%87%86%E5%A4%87%E5%A5%BD%E3%80%82%E5%85%88%E5%8E%BBST%E5%AE%98%E7%BD%91%E4%B8%8B%E8%BD%BD%E5%AE%98%E6%96%B9%E6%8F%90%E4%BE%9B%E7%9A%84%E5%A4%96%E8%AE%BE%E6%A0%87%E5%87%86%E5%BA%93%EF%BC%8C%E9%87%8C%E9%9D%A2"><span class="toc-number">1.6.3.1.0.3.</span> <span class="toc-text">STM32程序需要启动文件，我们需要提前准备好。先去ST官网下载官方提供的外设标准库，里面</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6%E9%80%89%E6%8B%A9%E6%A0%87%E5%87%86%EF%BC%9A"><span class="toc-number">1.6.3.1.0.4.</span> <span class="toc-text">启动文件选择标准：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-%E5%88%9B%E5%BB%BA%E5%B7%A5%E7%A8%8B"><span class="toc-number">1.6.3.1.0.5.</span> <span class="toc-text">4. 创建工程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%B7%A5%E7%A8%8B%E9%85%8D%E7%BD%AE"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">2. 工程配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%BC%96%E8%AF%91%E9%85%8D%E7%BD%AE"><span class="toc-number">1.6.3.3.</span> <span class="toc-text">3. 编译配置</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E7%BC%96%E8%AF%91%E5%99%A8%E7%89%88%E6%9C%AC%E6%94%B9%E4%B8%BA-5"><span class="toc-number">1.6.3.3.0.1.</span> <span class="toc-text">1. 编译器版本改为 5 </span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E4%B8%80%E4%BA%9B%E5%85%B6%E4%BB%96%E9%85%8D%E7%BD%AE"><span class="toc-number">1.6.3.3.0.2.</span> <span class="toc-text">2. 一些其他配置</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.6.4.</span> <span class="toc-text">4. 软件设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-main-c"><span class="toc-number">1.6.4.1.</span> <span class="toc-text">1. main.c</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E5%89%8D%E9%9D%A2%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AA%E8%A6%81%E8%AE%A9-GPIOA%E7%9A%84-0-%E5%8F%A3%E8%BE%93%E5%87%BA%E4%BD%8E%E7%94%B5%E5%B9%B3%E5%B0%B1%E8%A1%8C%E4%BA%86-%E3%80%82%E4%BB%A3%E7%A0%81%E9%9C%80%E8%A6%81%E6%8C%89%E7%85%A7%E4%B8%8B%E9%9D%A2%E7%9A%84%E6%AD%A5%E9%AA%A4%E6%9D%A5"><span class="toc-number">1.6.4.1.0.1.</span> <span class="toc-text">根据前面硬件电路设计，我们只要让 GPIOA的 0 口输出低电平就行了 。代码需要按照下面的步骤来</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E3%80%82"><span class="toc-number">1.6.4.1.0.2.</span> <span class="toc-text">实现。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E5%BC%80%E5%90%AF%E6%97%B6%E9%92%9F"><span class="toc-number">1.6.4.1.0.3.</span> <span class="toc-text">1. 开启时钟</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9C%A8STM32%E4%B8%AD%EF%BC%8C%E8%AE%A9IO%E5%8F%A3%E5%B7%A5%E4%BD%9C%EF%BC%8C%E5%BF%85%E9%A1%BB%E5%85%88%E5%BC%80%E5%90%AF%E5%AF%B9%E5%BA%94%E7%9A%84%E6%97%B6%E9%92%9F%E3%80%82%E6%89%80%E4%BB%A5%E9%9C%80%E8%A6%81%E5%85%88%E6%9F%A5%E6%89%BE%E5%88%B0%E5%BC%80%E5%90%AF%E6%97%B6%E9%92%9F%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%8C%E7%84%B6%E5%90%8E"><span class="toc-number">1.6.4.1.0.4.</span> <span class="toc-text">在STM32中，让IO口工作，必须先开启对应的时钟。所以需要先查找到开启时钟的寄存器，然后</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E8%AF%A5%E5%AF%84%E5%AD%98%E5%99%A8%E6%93%8D%E4%BD%9C%E6%97%B6%E9%92%9F%E7%9A%84%E5%BC%80%E5%90%AF%E6%88%96%E5%85%B3%E9%97%AD%E3%80%82%E6%88%91%E4%BB%AC%E8%A6%81%E6%89%93%E5%BC%80%E7%9A%84%E6%98%AFGPIOA%E7%9A%84%E6%97%B6%E9%92%9F%E3%80%82"><span class="toc-number">1.6.4.1.0.5.</span> <span class="toc-text">通过该寄存器操作时钟的开启或关闭。我们要打开的是GPIOA的时钟。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93RCC-APB2ENR%E8%BF%99%E4%B8%AA%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E3%80%82%E5%A6%82%E4%BD%95%E6%9F%A5%E6%89%BE%E5%91%A2%EF%BC%9F%E5%85%88%E7%9F%A5%E9%81%93RCC%E8%BF%99%E4%B8%AA%E5%A4%96%E8%AE%BE%E7%9A%84%E5%9F%BA%E5%9C%B0%E5%9D%80%EF%BC%8C%E7%84%B6"><span class="toc-number">1.6.4.1.0.6.</span> <span class="toc-text">我们需要知道RCC_APB2ENR这个寄存器的地址。如何查找呢？先知道RCC这个外设的基地址，然</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%90%8E%E5%8A%A0%E4%B8%8A%E8%BF%99%E4%B8%AA%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E5%81%8F%E7%A7%BB%E5%9C%B0%E5%9D%80%E5%B0%B1%E8%A1%8C%E4%BA%86%E3%80%82"><span class="toc-number">1.6.4.1.0.7.</span> <span class="toc-text">后加上这个寄存器的偏移地址就行了。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E7%BB%99IO%E5%8F%A3%E8%AE%BE%E7%BD%AE%E8%BE%93%E5%87%BA%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.6.4.1.0.8.</span> <span class="toc-text">2. 给IO口设置输出模式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9C%A8STM32%E4%B8%AD%EF%BC%8C%E5%A6%82%E6%9E%9C%E8%A6%81%E8%AE%A9IO%E5%8F%A3%E8%BE%93%E5%87%BA%E4%BD%8E%E7%94%B5%E5%B9%B3%E6%88%96%E9%AB%98%E7%94%B5%E5%B9%B3%EF%BC%8C%E5%BF%85%E9%A1%BB%E7%BB%99%E8%A6%81%E4%BD%BF%E7%94%A8%E7%9A%84IO%E8%AE%BE%E7%BD%AE%E4%B8%BA%E8%BE%93%E5%87%BA%E6%A8%A1%E5%BC%8F%E3%80%82"><span class="toc-number">1.6.4.1.0.9.</span> <span class="toc-text">在STM32中，如果要让IO口输出低电平或高电平，必须给要使用的IO设置为输出模式。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E5%89%8D%E9%9D%A2%E7%9A%84%E6%80%9D%E8%B7%AF%EF%BC%8C%E9%9C%80%E8%A6%81%E5%85%88%E6%89%BE%E5%88%B0GPIOA%E7%9A%84%E5%9F%BA%E5%9C%B0%E5%9D%80%EF%BC%8C%E5%86%8D%E6%A0%B9%E6%8D%AE%E5%81%8F%E7%A7%BB%E5%9C%B0%E5%9D%80%E6%89%BE%E5%88%B0%E8%A6%81%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E3%80%82"><span class="toc-number">1.6.4.1.0.10.</span> <span class="toc-text">根据前面的思路，需要先找到GPIOA的基地址，再根据偏移地址找到要使用的寄存器的地址。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%AA%E9%9C%80%E8%A6%81%E8%AE%A9%E8%BF%99%E4%B8%AA%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E6%9C%80%E5%90%8E-4-%E4%BD%8D%E6%98%AF0011%EF%BC%8C%E5%B0%B1%E6%98%AF%E6%9C%80%E5%A4%A7%E9%80%9F%E5%BA%A6%E7%9A%84%E6%8E%A8%E6%8C%BD%E8%BE%93%E5%87%BA%E3%80%82"><span class="toc-number">1.6.4.1.0.11.</span> <span class="toc-text">只需要让这个寄存器的最后 4 位是0011，就是最大速度的推挽输出。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E7%BB%99PA0%E5%8F%A3%E8%BE%93%E5%87%BA-0"><span class="toc-number">1.6.4.1.0.12.</span> <span class="toc-text">3. 给PA0口输出 0 </span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BB%99%E6%8C%87%E5%AE%9APA0%E5%8F%A3%E8%BE%93%E5%87%BA-0-%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%82%B9%E4%BA%AELED1%E4%BA%86%E3%80%82%E7%94%A8%E5%88%B0%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8%E6%98%AFODR%E6%95%B0%E6%8D%AE%E8%BE%93%E5%87%BA%E5%AF%84%E5%AD%98%E5%99%A8%E3%80%82"><span class="toc-number">1.6.4.1.0.13.</span> <span class="toc-text">给指定PA0口输出 0 就可以点亮LED1了。用到的寄存器是ODR数据输出寄存器。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%BC%96%E8%AF%91%E5%B7%A5%E7%A8%8B"><span class="toc-number">1.6.4.2.</span> <span class="toc-text">2. 编译工程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AE%89%E8%A3%85ST-LINK%E9%A9%B1%E5%8A%A8"><span class="toc-number">1.6.4.3.</span> <span class="toc-text">3. 安装ST-LINK驱动</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E6%88%91%E4%BB%AC%E4%BD%BF%E7%94%A8ST-LINK%E4%BB%BF%E7%9C%9F%E5%99%A8%E4%B8%8B%E8%BD%BD%E7%A8%8B%E5%BA%8F%E3%80%82"><span class="toc-number">1.6.4.3.0.1.</span> <span class="toc-text">1. 我们使用ST-LINK仿真器下载程序。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Keil%E4%B8%AD%E9%85%8D%E7%BD%AEST-LINK"><span class="toc-number">1.6.4.4.</span> <span class="toc-text">4. Keil中配置ST-LINK</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%B8%8B%E8%BD%BD%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.6.4.5.</span> <span class="toc-text">5. 下载程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E6%93%8D%E4%BD%9C%E5%AF%84%E5%AD%98%E5%99%A8%E6%96%B9%E5%BC%8F%E7%9A%84%E2%80%9D%E8%BF%9B%E5%8C%96%E2%80%9D"><span class="toc-number">1.6.4.6.</span> <span class="toc-text">6. 操作寄存器方式的”进化”</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E2%80%9C%E8%BF%9B%E5%8C%961%E2%80%9D"><span class="toc-number">1.6.4.6.1.</span> <span class="toc-text">1. “进化1”</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9C%A8%E6%93%8D%E4%BD%9C%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%AF%8F%E6%AC%A1%E9%83%BD%E6%9F%A5%E6%89%8B%E5%86%8C%E8%AE%A1%E7%AE%97%E5%9C%B0%E5%9D%80%EF%BC%8C%E6%98%AF%E7%9B%B8%E5%BD%93%E9%BA%BB%E7%83%A6%E4%B8%94%E6%97%A0%E8%81%8A%E3%80%82ST%E5%85%AC%E5%8F%B8%E6%97%A9%E5%B0%B1%E8%80%83%E8%99%91%E5%88%B0%E4%BA%86%E8%BF%99"><span class="toc-number">1.6.4.6.1.1.</span> <span class="toc-text">在操作寄存器的时候，如果每次都查手册计算地址，是相当麻烦且无聊。ST公司早就考虑到了这</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%AA%E9%97%AE%E9%A2%98%EF%BC%8C%E5%B7%B2%E7%BB%8F%E6%8F%90%E5%89%8D%E6%8A%8A%E6%AF%8F%E4%B8%AA%E5%A4%96%E8%AE%BE%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E6%8F%90%E5%89%8D%E7%BB%99%E6%88%91%E4%BB%AC%E7%94%A8-%E5%AE%8F%E5%AE%9A%E4%B9%89-%E7%9A%84%E6%96%B9%E5%BC%8F%E7%BB%99%E7%AE%97%E5%A5%BD%E4%BA%86%EF%BC%8C%E6%88%91%E5%8F%AA%E9%9C%80%E8%A6%81%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8"><span class="toc-number">1.6.4.6.1.2.</span> <span class="toc-text">个问题，已经提前把每个外设寄存器的地址提前给我们用 宏定义 的方式给算好了，我只需要直接使用</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BF%99%E9%87%8C%E8%BF%98%E5%B7%A7%E5%A6%99%E7%9A%84%E8%BF%90%E7%94%A8%E4%BA%86-%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E5%90%84%E4%B8%AA%E6%88%90%E5%91%98%E5%9C%B0%E5%9D%80%E6%98%AF%E8%BF%9E%E7%BB%AD%E7%9A%84%E7%89%B9%E5%BE%81-%E3%80%82CR%E5%AF%84%E5%AD%98%E5%99%A8%E6%98%AFRCC%E7%AC%AC-0-%E4%B8%AA-32-%E4%BD%8D%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%8C%E6%89%80"><span class="toc-number">1.6.4.6.1.3.</span> <span class="toc-text">这里还巧妙的运用了 结构体中各个成员地址是连续的特征 。CR寄存器是RCC第 0 个 32 位寄存器，所</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BB%A5%E5%AE%83%E7%9B%B8%E5%AF%B9%E4%BA%8E%E5%9F%BA%E5%9C%B0%E5%9D%80%E7%9A%84%E5%81%8F%E7%A7%BB%E6%98%AF-0-%E3%80%82CFGR%E7%9B%B8%E5%AF%B9%E4%BA%8E%E5%9F%BA%E5%9C%B0%E5%9D%80%E7%9A%84%E5%81%8F%E7%A7%BB%E6%98%AF-4-%EF%BC%8C%E2%80%A6"><span class="toc-number">1.6.4.6.1.4.</span> <span class="toc-text">以它相对于基地址的偏移是 0 。CFGR相对于基地址的偏移是 4 ，…</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BF%99%E6%A0%B7%E5%86%99%E8%B5%B7%E6%9D%A5%E6%98%AF%E4%B8%8D%E6%98%AF%E5%8F%AF%E8%AF%BB%E6%80%A7%E5%B0%B1%E5%A5%BD%E5%BE%88%E5%A4%9A%E4%BA%86%EF%BC%8C%E8%80%8C%E4%B8%94%E4%B9%9F%E7%AE%80%E5%8D%95%E4%BA%86%E5%BE%88%E5%A4%9A%E3%80%82"><span class="toc-number">1.6.4.6.1.5.</span> <span class="toc-text">这样写起来是不是可读性就好很多了，而且也简单了很多。</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E2%80%9C%E8%BF%9B%E5%8C%962%E2%80%9D"><span class="toc-number">1.6.4.6.2.</span> <span class="toc-text">2. “进化2”</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%B6%E5%AE%9E%E5%9C%A8%E4%B8%8A%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B8%AD%E8%BF%98%E6%9C%89%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%E3%80%82%E5%9C%A8STM32%E4%B8%AD%E4%B8%80%E4%B8%AA%E5%AF%84%E5%AD%98%E5%99%A8%E6%98%AF-32-%E4%BD%8D%E7%9A%84%EF%BC%8C%E6%88%91%E4%BB%AC%E5%9C%A8%E7%BC%96%E5%86%99%E4%BB%A3%E7%A0%81%E7%9A%84%E6%97%B6%E5%80%99%E5%8F%AA"><span class="toc-number">1.6.4.6.2.1.</span> <span class="toc-text">其实在上面的代码中还有一些问题。在STM32中一个寄存器是 32 位的，我们在编写代码的时候只</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%98%AF%E9%9C%80%E8%A6%81%E7%BB%99%E6%9F%90%E4%BD%8D%E6%88%96%E6%9F%90%E5%87%A0%E4%BD%8D%E8%B5%8B%E5%80%BC%E3%80%82%E7%94%B1%E4%BA%8ESTM32%E4%B8%8D%E6%94%AF%E6%8C%81%E4%BD%8D%E5%AF%BB%E5%9D%80%EF%BC%8C%E6%89%80%E4%BB%A5%E5%9C%A8%E5%89%8D%E9%9D%A2%E7%9A%84%E6%93%8D%E4%BD%9C%E4%B8%AD%EF%BC%8C%E6%88%91%E4%BB%AC%E5%85%B6%E5%AE%9E%E6%98%AF%E4%BF%AE%E6%94%B9%E4%BA%86%E6%89%80"><span class="toc-number">1.6.4.6.2.2.</span> <span class="toc-text">是需要给某位或某几位赋值。由于STM32不支持位寻址，所以在前面的操作中，我们其实是修改了所</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9C%89%E4%BD%8D%E3%80%82%E8%BF%99%E6%98%AF%E9%9D%9E%E5%B8%B8%E4%B8%8D%E5%90%88%E7%90%86%E7%9A%84%EF%BC%8C%E4%B9%9F%E8%AE%B8%E5%85%B6%E4%BB%96%E4%BD%8D%E5%9C%A8%E5%85%B6%E4%BB%96%E5%9C%B0%E6%96%B9%E6%9C%89%E8%B5%8B%E5%80%BC%EF%BC%8C%E6%88%91%E4%BB%AC%E9%87%8D%E6%96%B0%E8%B5%8B%E5%80%BC%E5%8A%BF%E5%BF%85%E4%BC%9A%E8%A6%86%E7%9B%96%E4%BA%86%E5%85%B6%E4%BB%96%E5%80%BC%EF%BC%8C%E5%B8%A6%E6%9D%A5"><span class="toc-number">1.6.4.6.2.3.</span> <span class="toc-text">有位。这是非常不合理的，也许其他位在其他地方有赋值，我们重新赋值势必会覆盖了其他值，带来</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9A%84%E5%90%8E%E6%9E%9C%E4%B9%9F%E6%98%AF%E5%BE%88%E4%B8%A5%E9%87%8D%E7%9A%84%E3%80%82"><span class="toc-number">1.6.4.6.2.4.</span> <span class="toc-text">的后果也是很严重的。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%8F%AA%E4%BF%AE%E6%94%B9%E7%89%B9%E5%AE%9A%E7%9A%84%E4%BD%8D%E7%9A%84%E5%80%BC%EF%BC%8C%E8%80%8C%E4%B8%8D%E5%BD%B1%E5%93%8D%E5%85%B6%E4%BB%96%E4%BD%8D%E5%91%A2%EF%BC%9F%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E5%85%88%E5%9B%9E%E9%A1%BE%E4%B8%8B%E4%B8%80%E4%BA%9B%E5%B8%B8%E2%BB%85%E7%9A%84%E4%BD%8D%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%86%8D%E6%9D%A5%E7%BB%A7%E7%BB%AD"><span class="toc-number">1.6.4.6.2.5.</span> <span class="toc-text">如何只修改特定的位的值，而不影响其他位呢？我们需要先回顾下一些常⻅的位操作，再来继续</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BF%9B%E5%8C%96%E4%B8%8A%E9%9D%A2%E7%9A%84%E4%BB%A3%E7%A0%81%E3%80%82"><span class="toc-number">1.6.4.6.2.6.</span> <span class="toc-text">进化上面的代码。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%8D%E6%93%8D%E4%BD%9C%E5%9B%9E%E9%A1%BE"><span class="toc-number">1.6.4.6.2.7.</span> <span class="toc-text">1. 常用的一些位操作回顾</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E7%BB%A7%E7%BB%AD%E8%BF%9B%E5%8C%96"><span class="toc-number">1.6.4.6.2.8.</span> <span class="toc-text">2. 继续进化</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E5%89%8D%E9%9D%A2%E5%9F%BA%E6%9C%AC%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%9A%84%E5%9B%9E%E9%A1%BE%EF%BC%8C%E6%88%91%E4%BB%AC%E7%BB%BC%E5%90%88%E4%BD%BF%E7%94%A8%E8%BF%99%E4%BA%9B%E4%BD%8D%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%8A%8A%E4%BB%A3%E7%A0%81%E8%BF%9B%E5%8C%96%E4%B8%BA%E4%B8%8B%E9%9D%A2%E7%9A%84%E5%BD%A2%E5%BC%8F%E3%80%82"><span class="toc-number">1.6.4.6.2.9.</span> <span class="toc-text">根据前面基本位操作的回顾，我们综合使用这些位操作，可以把代码进化为下面的形式。</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E2%80%9C%E8%BF%9B%E5%8C%963%E2%80%9D"><span class="toc-number">1.6.4.6.3.</span> <span class="toc-text">3. “进化3”</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9C%A8%E4%B8%8A%E6%AC%A1%E7%9A%84%E8%BF%9B%E5%8C%96%E4%B8%AD%EF%BC%8C%E6%88%91%E4%BB%AC%E6%98%AF%E7%BB%99%E5%AF%84%E5%AD%98%E5%99%A8%E2%80%9C%E6%88%96%E7%AD%89%E2%80%9D%E5%92%8C%E2%80%9C%E4%B8%8E%E7%AD%89%E2%80%9D%E4%BA%86%E4%B8%80%E4%BA%9B%E5%80%BC%EF%BC%8C%E8%BF%99%E4%BA%9B%E5%80%BC%E9%83%BD%E6%98%AF%E9%80%9A%E8%BF%87%E7%9B%B8%E5%BA%94%E7%9A%84%E2%80%9C%E7%A7%BB"><span class="toc-number">1.6.4.6.3.1.</span> <span class="toc-text">在上次的进化中，我们是给寄存器“或等”和“与等”了一些值，这些值都是通过相应的“移</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%A9%E7%94%A8ST%E5%85%AC%E5%8F%B8%E6%8F%90%E5%89%8D%E9%A2%84%E5%AE%9A%E4%B9%89%E7%9A%84%E8%BF%99%E4%BA%9B%E5%80%BC%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%BF%9B%E4%B8%80%E6%AD%A5%E8%BF%9B%E5%8C%96%E4%BB%A3%E7%A0%81%E4%B8%BA%E4%B8%8B%E9%9D%A2%E7%9A%84%E5%BD%A2%E5%BC%8F%E3%80%82"><span class="toc-number">1.6.4.6.3.2.</span> <span class="toc-text">利用ST公司提前预定义的这些值，可以进一步进化代码为下面的形式。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BF%99%E6%A0%B7%E5%8F%AF%E8%AF%BB%E6%80%A7%E5%B0%B1%E5%A5%BD%E5%A4%9A%E4%BA%86%EF%BC%8C%E7%AD%89%E6%93%8D%E4%BD%9C%E7%86%9F%E7%BB%83%E4%B9%8B%E5%90%8E%EF%BC%8C%E5%BE%88%E5%A4%9A%E6%93%8D%E4%BD%9C%E4%B8%8D%E6%9F%A5%E6%89%BE%E5%AF%84%E5%AD%98%E5%99%A8%E6%89%8B%E5%86%8C%E4%B9%9F%E8%83%BD%E7%9B%B4%E6%8E%A5%E6%93%8D%E4%BD%9C%E4%BA%86%E3%80%82"><span class="toc-number">1.6.4.6.3.3.</span> <span class="toc-text">这样可读性就好多了，等操作熟练之后，很多操作不查找寄存器手册也能直接操作了。</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-GPIO%E5%A4%96%E8%AE%BE"><span class="toc-number">1.7.</span> <span class="toc-text">3. GPIO外设</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-GPIO%E6%A6%82%E8%BF%B0"><span class="toc-number">1.7.1.</span> <span class="toc-text">1. GPIO概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-GPIO%E6%80%BB%E4%BD%93%E8%AF%B4%E6%98%8E"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">1. GPIO总体说明</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#STM32%E6%9C%89%E5%A4%9A%E7%BB%84GPIO%EF%BC%8C%E6%AF%94%E5%A6%82%E6%88%91%E4%BB%AC%E4%BD%BF%E7%94%A8%E7%9A%84%E8%8A%AF%E7%89%87%EF%BC%9ASTM32F103ZET6%E5%85%B1%E6%9C%89-7-%E7%BB%84GPIO%E7%AB%AF%E5%8F%A3-%EF%BC%8C%E4%BB%96%E4%BB%AC%E5%88%86%E5%88%AB%E6%98%AF"><span class="toc-number">1.7.1.1.0.1.</span> <span class="toc-text">STM32有多组GPIO，比如我们使用的芯片：STM32F103ZET6共有 7 组GPIO端口 ，他们分别是</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-GPIO%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">1. GPIO的主要特点</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E4%B8%8D%E5%90%8C%E5%9E%8B%E5%8F%B7%EF%BC%8CIO%E5%8F%A3%E7%9A%84%E6%95%B0%E9%87%8F%E5%8F%AF%E8%83%BD%E4%B8%8D%E4%B8%80%E6%A0%B7%E3%80%82"><span class="toc-number">1.7.1.2.0.1.</span> <span class="toc-text">1. 不同型号，IO口的数量可能不一样。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-GPIO%E7%9A%84-8-%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.7.1.3.</span> <span class="toc-text">2. GPIO的 8 种工作模式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#GPIO%E7%AB%AF%E5%8F%A3%E7%9A%84%E6%AF%8F%E4%B8%AA%E4%BD%8D%EF%BC%88%E5%BC%95%E8%84%9A%EF%BC%89%E5%8F%AF%E4%BB%A5%E7%94%B1-%E8%BD%AF%E4%BB%B6-%E5%88%86%E5%88%AB-%E9%85%8D%E7%BD%AE-%E6%88%90-8-%E7%A7%8D%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%BD%93%E7%84%B6%E5%AF%B9%E5%90%8C%E4%B8%80%E4%B8%AA%E5%BC%95%E8%84%9A%E5%90%8C%E4%B8%80%E6%97%B6%E9%97%B4%E5%8F%AA%E8%83%BD%E5%A4%84%E4%BA%8E%E6%9F%90"><span class="toc-number">1.7.1.3.0.1.</span> <span class="toc-text">GPIO端口的每个位（引脚）可以由 软件 分别 配置 成 8 种模式，当然对同一个引脚同一时间只能处于某</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%80%E7%A7%8D%E6%A8%A1%E5%BC%8F%E4%B8%AD%E3%80%82"><span class="toc-number">1.7.1.3.0.2.</span> <span class="toc-text">一种模式中。</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-GPIO%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.7.2.</span> <span class="toc-text">2. GPIO工作模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-GPIO%E6%AF%8F%E4%BD%8D%E7%9A%84%E5%85%B7%E4%BD%93%E7%94%B5%E8%B7%AF%E7%BB%93%E6%9E%84"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">1. GPIO每位的具体电路结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%AF%8F%E7%A7%8D%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">2. 每种模式详解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%BE%93%E5%87%BA%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.7.2.2.1.</span> <span class="toc-text">1. 输出模式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2%E5%99%A8%E8%A2%AB%E6%BF%80%E6%B4%BB%E3%80%82"><span class="toc-number">1.7.2.2.1.1.</span> <span class="toc-text">1. 输出缓冲器被激活。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E6%8E%A8%E6%8C%BD%E6%A8%A1%E5%BC%8F%EF%BC%9A%E8%BE%93%E5%87%BA%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8A%E7%9A%841%E5%B0%86%E6%BF%80%E6%B4%BBP-MOS%EF%BC%8C%E8%BE%93%E5%87%BA%E9%AB%98%E7%94%B5%E5%B9%B3%E3%80%820%E5%B0%86%E6%BF%80%E6%B4%BBN-MOS%EF%BC%8C%E8%BE%93%E5%87%BA%E4%BD%8E%E7%94%B5%E5%B9%B3%E3%80%82"><span class="toc-number">1.7.2.2.1.2.</span> <span class="toc-text">2. 推挽模式：输出寄存器上的1将激活P-MOS，输出高电平。0将激活N-MOS，输出低电平。 </span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E5%BC%80%E6%BC%8F%E6%A8%A1%E5%BC%8F%EF%BC%9AP-MOS%E6%B0%B8%E8%BF%9C%E5%85%B3%E9%97%AD%E3%80%82%E8%BE%93%E5%87%BA%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8A%E7%9A%840%E6%BF%80%E6%B4%BBN-MOS%EF%BC%8C%E8%80%8C%E8%BE%93%E5%87%BA%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8A%E7%9A%84-1%E5%B0%86%E7%AB%AF%E5%8F%A3%E7%BD%AE%E4%BA%8E%E9%AB%98"><span class="toc-number">1.7.2.2.1.3.</span> <span class="toc-text">3. 开漏模式：P-MOS永远关闭。输出寄存器上的0激活N-MOS，而输出寄存器上的 1将端口置于高</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%98%BB%E7%8A%B6%E6%80%81%EF%BC%8C%E6%89%80%E4%BB%A5%E5%A4%96%E9%83%A8%E5%BF%85%E9%A1%BB%E8%A6%81%E6%8E%A5%E4%B8%8A%E6%8B%89%E7%94%B5%E9%98%BB%E3%80%82"><span class="toc-number">1.7.2.2.1.4.</span> <span class="toc-text">阻状态，所以外部必须要接上拉电阻。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-%E6%96%BD%E5%AF%86%E7%89%B9%E8%A7%A6%E5%8F%91%E8%BE%93%E5%85%A5%E8%A2%AB%E6%BF%80%E6%B4%BB%E3%80%82"><span class="toc-number">1.7.2.2.1.5.</span> <span class="toc-text">4. 施密特触发输入被激活。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5-%E5%BC%B1%E4%B8%8A%E6%8B%89%E5%92%8C%E4%B8%8B%E6%8B%89%E7%94%B5%E9%98%BB%E8%A2%AB%E7%A6%81%E6%AD%A2%E3%80%82"><span class="toc-number">1.7.2.2.1.6.</span> <span class="toc-text">5. 弱上拉和下拉电阻被禁止。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#6-%E5%87%BA%E7%8E%B0%E5%9C%A8I-O%E8%84%9A%E4%B8%8A%E7%9A%84%E6%95%B0%E6%8D%AE%E5%9C%A8%E6%AF%8F%E4%B8%AAAPB2%E6%97%B6%E9%92%9F%E8%A2%AB%E9%87%87%E6%A0%B7%E5%88%B0%E8%BE%93%E5%85%A5%E6%95%B0%E6%8D%AE%E5%AF%84%E5%AD%98%E5%99%A8%E3%80%82"><span class="toc-number">1.7.2.2.1.7.</span> <span class="toc-text">6. 出现在I&#x2F;O脚上的数据在每个APB2时钟被采样到输入数据寄存器。 </span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#7-%E5%9C%A8%E5%BC%80%E6%BC%8F%E6%A8%A1%E5%BC%8F%E6%97%B6%EF%BC%8C%E5%AF%B9%E8%BE%93%E5%85%A5%E6%95%B0%E6%8D%AE%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E8%AF%BB%E8%AE%BF%E9%97%AE%E5%8F%AF%E5%BE%97%E5%88%B0I-O%E7%8A%B6%E6%80%81%E3%80%82"><span class="toc-number">1.7.2.2.1.8.</span> <span class="toc-text">7. 在开漏模式时，对输入数据寄存器的读访问可得到I&#x2F;O状态。 </span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#8-%E5%9C%A8%E6%8E%A8%E6%8C%BD%E6%A8%A1%E5%BC%8F%E6%97%B6%EF%BC%8C%E5%AF%B9%E8%BE%93%E5%87%BA%E6%95%B0%E6%8D%AE%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E8%AF%BB%E8%AE%BF%E9%97%AE%E5%BE%97%E5%88%B0%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E5%86%99%E7%9A%84%E5%80%BC%E3%80%82"><span class="toc-number">1.7.2.2.1.9.</span> <span class="toc-text">8. 在推挽模式时，对输出数据寄存器的读访问得到最后一次写的值。</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%A4%8D%E7%94%A8%E8%BE%93%E5%87%BA%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.7.2.2.2.</span> <span class="toc-text">2. 复用输出模式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E5%9C%A8%E5%BC%80%E6%BC%8F%E6%88%96%E6%8E%A8%E6%8C%BD%E5%BC%8F%E9%85%8D%E7%BD%AE%E4%B8%AD%EF%BC%8C%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2%E5%99%A8%E8%A2%AB%E6%89%93%E5%BC%80%E3%80%82"><span class="toc-number">1.7.2.2.2.1.</span> <span class="toc-text">1. 在开漏或推挽式配置中，输出缓冲器被打开。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E5%86%85%E7%BD%AE%E5%A4%96%E8%AE%BE%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2%E5%99%A8%EF%BC%88%E5%A4%8D%E7%94%A8%E5%8A%9F%E8%83%BD%E8%BE%93%E5%87%BA%EF%BC%89%E3%80%82"><span class="toc-number">1.7.2.2.2.2.</span> <span class="toc-text">2. 内置外设的信号驱动输出缓冲器（复用功能输出）。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E6%96%BD%E5%AF%86%E7%89%B9%E8%A7%A6%E5%8F%91%E8%BE%93%E5%85%A5%E8%A2%AB%E6%BF%80%E6%B4%BB%E3%80%82"><span class="toc-number">1.7.2.2.2.3.</span> <span class="toc-text">3. 施密特触发输入被激活。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-%E5%BC%B1%E4%B8%8A%E6%8B%89%E5%92%8C%E4%B8%8B%E6%8B%89%E7%94%B5%E9%98%BB%E8%A2%AB%E7%A6%81%E6%AD%A2%E3%80%82"><span class="toc-number">1.7.2.2.2.4.</span> <span class="toc-text">4. 弱上拉和下拉电阻被禁止。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5-%E5%9C%A8%E6%AF%8F%E4%B8%AAAPB2%E6%97%B6%E9%92%9F%E5%91%A8%E6%9C%9F%EF%BC%8C%E5%87%BA%E7%8E%B0%E5%9C%A8I-O%E8%84%9A%E4%B8%8A%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A2%AB%E9%87%87%E6%A0%B7%E5%88%B0%E8%BE%93%E5%85%A5%E6%95%B0%E6%8D%AE%E5%AF%84%E5%AD%98%E5%99%A8%E3%80%82"><span class="toc-number">1.7.2.2.2.5.</span> <span class="toc-text">5. 在每个APB2时钟周期，出现在I&#x2F;O脚上的数据被采样到输入数据寄存器。 </span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#6-%E5%BC%80%E6%BC%8F%E6%A8%A1%E5%BC%8F%E6%97%B6%EF%BC%8C%E8%AF%BB%E8%BE%93%E5%85%A5%E6%95%B0%E6%8D%AE%E5%AF%84%E5%AD%98%E5%99%A8%E6%97%B6%E5%8F%AF%E5%BE%97%E5%88%B0I-O%E5%8F%A3%E7%8A%B6%E6%80%81%E3%80%82"><span class="toc-number">1.7.2.2.2.6.</span> <span class="toc-text">6. 开漏模式时，读输入数据寄存器时可得到I&#x2F;O口状态。 </span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#7-%E5%9C%A8%E6%8E%A8%E6%8C%BD%E6%A8%A1%E5%BC%8F%E6%97%B6%EF%BC%8C%E8%AF%BB%E8%BE%93%E5%87%BA%E6%95%B0%E6%8D%AE%E5%AF%84%E5%AD%98%E5%99%A8%E6%97%B6%E5%8F%AF%E5%BE%97%E5%88%B0%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E5%86%99%E7%9A%84%E5%80%BC%E3%80%82"><span class="toc-number">1.7.2.2.2.7.</span> <span class="toc-text">7. 在推挽模式时，读输出数据寄存器时可得到最后一次写的值。</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.7.2.2.3.</span> <span class="toc-text">3. 输入模式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-2-%E4%B8%AA%E4%BF%9D%E6%8A%A4%E4%BA%8C%E6%9E%81%E7%AE%A1%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BF%9D%E6%8A%A4%E6%88%91%E4%BB%AC%E7%9A%84%E8%8A%AF%E7%89%87%E4%B8%8D%E4%BC%9A%E7%94%B1%E4%BA%8E%E7%94%B5%E5%8E%8B%E8%BF%87%E9%AB%98%E6%88%96%E8%BF%87%E4%BD%8E%E8%80%8C%E7%83%A7%E6%AF%81%E3%80%82"><span class="toc-number">1.7.2.2.3.1.</span> <span class="toc-text">1. 2 个保护二极管的作用是保护我们的芯片不会由于电压过高或过低而烧毁。 </span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#VDD%E6%98%AF%E6%8E%A5%E7%94%B5%E6%BA%90%EF%BC%883-3V%EF%BC%89%EF%BC%8CVSS%E6%8E%A5%E5%9C%B0%EF%BC%880V%EF%BC%89%E3%80%82%E5%A6%82%E6%9E%9CIO%E5%BC%95%E8%84%9A%E7%9A%84%E8%BE%93%E5%85%A5%E7%94%B5%E5%8E%8B%E9%AB%98%E4%BA%8EVDD%E7%9A%84%E5%80%BC%E5%88%B0%E4%B8%80%E5%AE%9A%E7%A8%8B%E5%BA%A6%EF%BC%8C%E4%B8%8A%E6%96%B9"><span class="toc-number">1.7.2.2.3.2.</span> <span class="toc-text">VDD是接电源（3.3V），VSS接地（0V）。如果IO引脚的输入电压高于VDD的值到一定程度，上方</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4%E4%BA%8C%E6%9E%81%E7%AE%A1%E5%AF%BC%E9%80%9A%EF%BC%8C%E5%88%99%E5%BC%95%E8%84%9A%E7%94%B5%E5%8E%8B%E8%A2%AB%E6%8B%89%E4%BD%8E%E5%88%B0VDD%E3%80%82%E5%A6%82%E6%9E%9CIO%E5%BC%95%E8%84%9A%E7%9A%84%E8%BE%93%E5%85%A5%E7%94%B5%E5%8E%8B%EF%BC%88%E8%B4%9F%E7%94%B5%E5%8E%8B%EF%BC%89%E4%BD%8E%E4%BA%8EVSS%E5%88%B0%E4%B8%80%E5%AE%9A%E7%A8%8B%E5%BA%A6%EF%BC%8C"><span class="toc-number">1.7.2.2.3.3.</span> <span class="toc-text">保护二极管导通，则引脚电压被拉低到VDD。如果IO引脚的输入电压（负电压）低于VSS到一定程度，</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%99%E4%B8%8B%E6%96%B9%E4%BF%9D%E6%8A%A4%E4%BA%8C%E6%9E%81%E7%AE%A1%E5%AF%BC%E9%80%9A%EF%BC%8C%E7%94%B5%E5%8E%8B%E8%A2%AB%E6%8B%89%E9%AB%98%E5%88%B0VSS%E3%80%82"><span class="toc-number">1.7.2.2.3.4.</span> <span class="toc-text">则下方保护二极管导通，电压被拉高到VSS。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-2-%E4%B8%AA%E5%BC%80%E5%85%B3%E6%8E%A7%E5%88%B6%E5%BC%95%E8%84%9A%E6%B2%A1%E6%9C%89%E8%BE%93%E5%85%A5%E7%9A%84%E6%97%B6%E5%80%99%E6%98%AF%E4%B8%8A%E6%8B%89%EF%BC%8C%E4%B8%8B%E6%8B%89%E8%BF%98%E6%98%AF%E6%B5%AE%E7%A9%BA%E3%80%82"><span class="toc-number">1.7.2.2.3.5.</span> <span class="toc-text">2. 2 个开关控制引脚没有输入的时候是上拉，下拉还是浮空。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BD%93%E4%B8%8A%E9%9D%A2%E7%9A%84%E5%BC%80%E5%85%B3%E9%97%AD%E5%90%88%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E8%BE%93%E5%85%A5%E8%A2%AB%E6%8B%89%E9%AB%98%E5%88%B0%E9%AB%98%E7%94%B5%E5%B9%B3%E3%80%82%E5%BD%93%E4%B8%8B%E9%9D%A2%E7%9A%84%E5%BC%80%E5%85%B3%E9%97%AD%E5%90%88%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%85%A5%E8%A2%AB%E6%8B%89%E4%BD%8E%E5%88%B0%E4%BD%8E%E7%94%B5"><span class="toc-number">1.7.2.2.3.6.</span> <span class="toc-text">当上面的开关闭合的时候，输入被拉高到高电平。当下面的开关闭合的时候，入被拉低到低电</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B9%B3%E3%80%82%E5%A6%82%E6%9E%9C%E4%B8%A4%E4%B8%AA%E9%83%BD%E4%B8%8D%E9%97%AD%E5%90%88%EF%BC%8C%E8%BE%93%E5%85%A5%E5%B0%B1%E6%98%AF%E6%82%AC%E7%A9%BA%E7%8A%B6%E6%80%81%E3%80%82-%E4%B8%A4%E4%B8%AA%E5%90%8C%E6%97%B6%E9%97%AD%E5%90%88%EF%BC%8C%E5%B0%B1%E6%98%AF%E8%B4%B9%E7%94%B5%E4%BA%86%EF%BC%8C%E4%B8%8D%E4%BC%9A%E8%BF%99%E4%B9%88%E5%81%9A%E7%9A%84-%E3%80%82"><span class="toc-number">1.7.2.2.3.7.</span> <span class="toc-text">平。如果两个都不闭合，输入就是悬空状态。 两个同时闭合，就是费电了，不会这么做的 。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-%E4%BB%8E%E6%96%BD%E5%AF%86%E7%89%B9%E8%A7%A6%E5%8F%91%E8%B5%B7%E5%87%BA%E6%9D%A5%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E8%BF%9B%E5%85%A5%E5%88%B0%E8%BE%93%E5%85%A5%E6%95%B0%E6%8D%AE%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD%EF%BC%8C%E6%88%91%E4%BB%AC%E5%B0%B1%E5%8F%AF%E4%BB%A5%E4%BB%8E%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E4%BA%86%E3%80%82"><span class="toc-number">1.7.2.2.3.8.</span> <span class="toc-text">4. 从施密特触发起出来的数据，进入到输入数据寄存器中，我们就可以从中读取数据了。</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E6%A8%A1%E6%8B%9F%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.7.2.2.4.</span> <span class="toc-text">4. 模拟输入模式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BD%93%E9%85%8D%E7%BD%AE%E4%B8%BA-%E6%A8%A1%E6%8B%9F%E8%BE%93%E5%85%A5-%E6%97%B6%EF%BC%9A"><span class="toc-number">1.7.2.2.4.1.</span> <span class="toc-text">当配置为 模拟输入 时：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E8%BE%93%E5%87%BA%E9%83%A8%E5%88%86%E8%A2%AB%E7%A6%81%E6%AD%A2%E3%80%82"><span class="toc-number">1.7.2.2.4.2.</span> <span class="toc-text">1. 输出部分被禁止。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E7%A6%81%E6%AD%A2%E6%96%BD%E5%AF%86%E7%89%B9%E8%A7%A6%E5%8F%91%E8%BE%93%E5%85%A5-%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%BA%86%E6%AF%8F%E4%B8%AA%E6%A8%A1%E6%8B%9FI-O%E5%BC%95%E8%84%9A%E4%B8%8A%E7%9A%84%E9%9B%B6%E6%B6%88%E8%80%97%E3%80%82%E6%96%BD%E5%AF%86%E7%89%B9%E8%A7%A6%E5%8F%91%E8%BE%93%E5%87%BA%E5%80%BC%E8%A2%AB%E5%BC%BA%E7%BD%AE%E4%B8%BA-0-%EF%BC%8C%E6%AD%A4%E6%97%B6%E4%B9%9F"><span class="toc-number">1.7.2.2.4.3.</span> <span class="toc-text">2. 禁止施密特触发输入 ，实现了每个模拟I&#x2F;O引脚上的零消耗。施密特触发输出值被强置为 0 ，此时也</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%AF%E4%BB%A5%E4%B8%8D%E7%94%A8%E5%BC%80%E5%90%AF%E5%AF%B9%E5%BA%94GPIO%E7%9A%84%E6%97%B6%E9%92%9F%E3%80%82"><span class="toc-number">1.7.2.2.4.4.</span> <span class="toc-text">可以不用开启对应GPIO的时钟。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E5%BC%B1%E4%B8%8A%E6%8B%89%E5%92%8C%E4%B8%8B%E6%8B%89%E7%94%B5%E9%98%BB%E8%A2%AB%E7%A6%81%E6%AD%A2%E3%80%82"><span class="toc-number">1.7.2.2.4.5.</span> <span class="toc-text">3. 弱上拉和下拉电阻被禁止。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-%E8%AF%BB%E5%8F%96%E8%BE%93%E5%85%A5%E6%95%B0%E6%8D%AE%E5%AF%84%E5%AD%98%E5%99%A8%E6%97%B6%E6%95%B0%E5%80%BC%E6%B0%B8%E8%BF%9C%E4%B8%BA-0-%E3%80%82"><span class="toc-number">1.7.2.2.4.6.</span> <span class="toc-text">4. 读取输入数据寄存器时数值永远为 0 。</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%8EGPIO%E7%9B%B8%E5%85%B3%E7%9A%84-7-%E4%B8%AA%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">1.7.3.</span> <span class="toc-text">3. 与GPIO相关的 7 个寄存器（重要）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%AF%8F%E4%B8%AAGPI-O%E7%AB%AF%E5%8F%A3%E6%9C%89-7-%E4%B8%AA%E7%9B%B8%E5%85%B3%E7%9A%84%EF%BC%9A"><span class="toc-number">1.7.3.0.0.1.</span> <span class="toc-text">每个GPI&#x2F;O端口有 7 个相关的：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-GPIOx-CRL%EF%BC%88%E7%AB%AF%E5%8F%A3%E9%85%8D%E7%BD%AE%E4%BD%8E%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%89"><span class="toc-number">1.7.3.1.</span> <span class="toc-text">1. GPIOx_CRL（端口配置低寄存器）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AF%A5%E5%AF%84%E5%AD%98%E5%99%A8%E9%85%8D%E7%BD%AE%E7%9A%84%E6%AF%8F%E4%B8%AAGPIO%E7%9A%840-7%E8%BF%99%E4%B8%AA-8-%E4%B8%AA%E4%BD%8D%EF%BC%8C%E6%89%80%E4%BB%A5%E5%8F%AB%E4%BD%8E%E5%AF%84%E5%AD%98%E5%99%A8%E3%80%82"><span class="toc-number">1.7.3.1.0.1.</span> <span class="toc-text">该寄存器配置的每个GPIO的0-7这个 8 个位，所以叫低寄存器。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#1-MODE%EF%BC%9A%E6%AF%8F%E4%B8%AA%E7%AB%AF%E5%8F%A3%E6%9C%89-2-%E4%B8%AAMODE%E4%BD%8D%E8%BF%9B%E8%A1%8C%E6%8E%A7%E5%88%B6%E3%80%82"><span class="toc-number">1.7.3.1.0.2.</span> <span class="toc-text">1. MODE：每个端口有 2 个MODE位进行控制。</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%AA-00-%EF%BC%9A%E6%A8%A1%E6%8B%9F%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.7.4.</span> <span class="toc-text">▪^00 ：模拟输入模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%AA-01-%EF%BC%9A%E6%B5%AE%E7%A9%BA%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F-%E5%A4%8D%E4%BD%8D%E5%90%8E%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">1.7.5.</span> <span class="toc-text">▪^01 ：浮空输入模式(复位后的状态)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%AA-10-%EF%BC%9A%E4%B8%8A%E6%8B%89-%E4%B8%8B%E6%8B%89%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.7.6.</span> <span class="toc-text">▪^10 ：上拉&#x2F;下拉输入模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%AA-11-%EF%BC%9A%E4%BF%9D%E7%95%99"><span class="toc-number">1.7.7.</span> <span class="toc-text">▪^11 ：保留</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%AA-00-%EF%BC%9A%E9%80%9A%E7%94%A8%E6%8E%A8%E6%8C%BD%E8%BE%93%E5%87%BA%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.7.8.</span> <span class="toc-text">▪^00 ：通用推挽输出模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%AA-01-%EF%BC%9A%E9%80%9A%E7%94%A8%E5%BC%80%E6%BC%8F%E8%BE%93%E5%87%BA%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.7.9.</span> <span class="toc-text">▪^01 ：通用开漏输出模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%AA-10-%EF%BC%9A%E5%A4%8D%E7%94%A8%E5%8A%9F%E8%83%BD%E6%8E%A8%E6%8C%BD%E8%BE%93%E5%87%BA%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.7.10.</span> <span class="toc-text">▪^10 ：复用功能推挽输出模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%96%AA-11-%EF%BC%9A%E5%A4%8D%E7%94%A8%E5%8A%9F%E8%83%BD%E5%BC%80%E6%BC%8F%E8%BE%93%E5%87%BA%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.7.11.</span> <span class="toc-text">▪^11 ：复用功能开漏输出模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-GPIOx-CRH%EF%BC%88%E7%AB%AF%E5%8F%A3%E9%85%8D%E7%BD%AE%E9%AB%98%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%89"><span class="toc-number">1.7.11.1.</span> <span class="toc-text">2. GPIOx_CRH（端口配置高寄存器）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-GPIOx-IDR%EF%BC%88%E7%AB%AF%E5%8F%A3%E8%BE%93%E5%85%A5%E6%95%B0%E6%8D%AE%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%89"><span class="toc-number">1.7.11.2.</span> <span class="toc-text">3. GPIOx_IDR（端口输入数据寄存器）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BF%9D%E7%95%99%E4%BD%8D%E5%A7%8B%E7%BB%88%E8%AF%BB%E4%B8%BA-0-%E3%80%82%E5%89%A9%E4%B8%8B%E7%9A%84%E5%88%86%E5%88%AB%E5%AF%B9%E5%BA%94%E6%AF%8F%E4%B8%AA%E5%BC%95%E8%84%9A%E7%9A%84%E8%BE%93%E5%85%A5%E5%80%BC%E3%80%82"><span class="toc-number">1.7.11.2.0.1.</span> <span class="toc-text">保留位始终读为 0 。剩下的分别对应每个引脚的输入值。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-GPIOx-ODR%EF%BC%88%E7%AB%AF%E5%8F%A3%E8%BE%93%E5%87%BA%E6%95%B0%E6%8D%AE%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%89"><span class="toc-number">1.7.11.3.</span> <span class="toc-text">4. GPIOx_ODR（端口输出数据寄存器）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BF%9D%E7%95%99%E4%BD%8D%E5%A7%8B%E7%BB%88%E8%AF%BB%E4%B8%BA-0-%E3%80%82%E5%89%A9%E4%B8%8B%E7%9A%84%E5%88%86%E5%88%AB%E5%AF%B9%E5%BA%94%E6%AF%8F%E4%B8%AA%E5%BC%95%E8%84%9A%E7%9A%84%E8%BE%93%E5%87%BA%E5%80%BC%E3%80%82"><span class="toc-number">1.7.11.3.0.1.</span> <span class="toc-text">保留位始终读为 0 。剩下的分别对应每个引脚的输出值。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-GPIOx-BSRR%EF%BC%88%E7%AB%AF%E5%8F%A3%E4%BD%8D%E8%AE%BE%E7%BD%AE-%E6%B8%85%E9%99%A4%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%89"><span class="toc-number">1.7.11.4.</span> <span class="toc-text">5. GPIOx_BSRR（端口位设置&#x2F;清除寄存器）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E9%AB%98-16-%E4%BD%8D%E6%98%AF%E7%94%A8%E6%B8%85%E9%99%A4%E5%AF%B9%E5%BA%94%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BE%93%E5%87%BA%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E4%BD%8D%EF%BC%880-15%EF%BC%89%E7%9A%84%E5%80%BC%EF%BC%9A%E8%AE%BE%E7%BD%AE%E4%B8%BA-0-%E4%B8%8D%E5%BD%B1%E5%93%8D%EF%BC%8C%E8%AE%BE%E7%BD%AE%E4%B8%BA-1-%E4%BC%9A%E6%B8%85%E9%99%A4ODR%E5%AF%B9"><span class="toc-number">1.7.11.4.0.1.</span> <span class="toc-text">1. 高 16 位是用清除对应的数据输出寄存器的位（0-15）的值：设置为 0 不影响，设置为 1 会清除ODR对</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BA%94%E7%9A%84%E4%BD%8D%E7%9A%84%E5%80%BC%EF%BC%88%E7%BD%AE%E4%B8%BA-0-%EF%BC%89%E3%80%82"><span class="toc-number">1.7.11.4.0.2.</span> <span class="toc-text">应的位的值（置为 0 ）。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E4%BD%8E-16-%E4%BD%8D%E6%98%AF%E7%94%A8%E8%AE%BE%E7%BD%AE%E5%AF%B9%E5%BA%94%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BE%93%E5%87%BA%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E4%BD%8D%EF%BC%880-15%EF%BC%89%E7%9A%84%E5%80%BC%EF%BC%9A%E8%AE%BE%E7%BD%AE%E4%B8%BA-0-%E4%B8%8D%E5%BD%B1%E5%93%8D%EF%BC%8C%E8%AE%BE%E7%BD%AE%E4%B8%BA-1-%E4%BC%9A%E8%AE%BE%E7%BD%AEODR%E5%AF%B9"><span class="toc-number">1.7.11.4.0.3.</span> <span class="toc-text">2. 低 16 位是用设置对应的数据输出寄存器的位（0-15）的值：设置为 0 不影响，设置为 1 会设置ODR对</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BA%94%E7%9A%84%E4%BD%8D%E7%9A%84%E5%80%BC%EF%BC%88%E7%BD%AE%E4%B8%BA-1-%EF%BC%89%E3%80%82"><span class="toc-number">1.7.11.4.0.4.</span> <span class="toc-text">应的位的值（置为 1 ）。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-GPIOx-BRR%EF%BC%88%E7%AB%AF%E5%8F%A3%E4%BD%8D%E6%B8%85%E9%99%A4%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%89"><span class="toc-number">1.7.11.5.</span> <span class="toc-text">6. GPIOx_BRR（端口位清除寄存器）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-GPIOx-LCKR%EF%BC%88%E7%AB%AF%E5%8F%A3%E9%85%8D%E7%BD%AE%E9%94%81%E5%AE%9A%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%89"><span class="toc-number">1.7.11.6.</span> <span class="toc-text">7. GPIOx_LCKR（端口配置锁定寄存器）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AF%A5%E5%AF%84%E5%AD%98%E5%99%A8%E7%94%A8%E6%9D%A5%E9%94%81%E5%AE%9A%E7%AB%AF%E5%8F%A3%E4%BD%8D%E7%9A%84%E9%85%8D%E7%BD%AE%E3%80%82%E4%BD%8D-15-0-%E7%94%A8%E4%BA%8E%E9%94%81%E5%AE%9AGPIO%E7%AB%AF%E5%8F%A3%E7%9A%84%E9%85%8D%E7%BD%AE%E3%80%82%E5%9C%A8%E8%A7%84%E5%AE%9A%E7%9A%84%E5%86%99%E5%85%A5%E6%93%8D%E4%BD%9C%E6%9C%9F%E9%97%B4%EF%BC%8C"><span class="toc-number">1.7.11.6.0.1.</span> <span class="toc-text">该寄存器用来锁定端口位的配置。位[15:0]用于锁定GPIO端口的配置。在规定的写入操作期间，</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%8D%E8%83%BD%E6%94%B9%E5%8F%98LCKP-15-0-%E3%80%82%E5%BD%93%E5%AF%B9%E7%9B%B8%E5%BA%94%E7%9A%84%E7%AB%AF%E5%8F%A3%E4%BD%8D%E6%89%A7%E8%A1%8C%E4%BA%86LOCK%E5%BA%8F%E5%88%97%E5%90%8E%EF%BC%8C%E5%9C%A8%E4%B8%8B%E6%AC%A1%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%BD%8D%E4%B9%8B%E5%89%8D%E5%B0%86%E4%B8%8D%E8%83%BD%E5%86%8D%E6%9B%B4%E6%94%B9%E7%AB%AF%E5%8F%A3"><span class="toc-number">1.7.11.6.0.2.</span> <span class="toc-text">不能改变LCKP[15:0]。当对相应的端口位执行了LOCK序列后，在下次系统复位之前将不能再更改端口</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%8D%E7%9A%84%E9%85%8D%E7%BD%AE%E3%80%82"><span class="toc-number">1.7.11.6.0.3.</span> <span class="toc-text">位的配置。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%AF%8F%E4%B8%AA%E9%94%81%E5%AE%9A%E4%BD%8D%E9%94%81%E5%AE%9A%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88CRL%EF%BC%8CCRH%EF%BC%89%E4%B8%AD%E7%9B%B8%E5%BA%94%E7%9A%84-4-%E4%B8%AA%E4%BD%8D%EF%BC%88CNF2%E4%BD%8D%E5%92%8CMODE2%E4%BD%8D%EF%BC%89%E3%80%82"><span class="toc-number">1.7.11.6.0.4.</span> <span class="toc-text">每个锁定位锁定控制寄存器（CRL，CRH）中相应的 4 个位（CNF2位和MODE2位）。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%AC%AC-16-%E4%BD%8D%E7%94%A8%E6%9D%A5%E6%BF%80%E6%B4%BB%E9%94%81%E5%AE%9A%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%8C%E5%BF%85%E9%A1%BB%E6%8C%89%E7%85%A7%E8%A7%84%E5%AE%9A%E7%9A%84%E6%97%B6%E5%BA%8F%E6%9D%A5%E6%93%8D%E4%BD%9C%E6%89%8D%E8%A1%8C-%E5%86%991-gt-%E5%86%990-gt-%E5%86%991-gt-%E8%AF%BB0-gt-%E8%AF%BB-1-%E3%80%82"><span class="toc-number">1.7.11.6.0.5.</span> <span class="toc-text">第 16 位用来激活锁定寄存器，必须按照规定的时序来操作才行:写1-&gt;写0-&gt;写1 -&gt;读0 -&gt;读 1 。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AF%B90-15%E4%BD%8D%EF%BC%9A"><span class="toc-number">1.7.11.6.0.6.</span> <span class="toc-text">对0-15位：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%97%A6-0-%EF%BC%9A%E4%B8%8D%E9%94%81%E5%AE%9A%E5%AF%B9%E5%BA%94%E7%AB%AF%E5%8F%A3%E7%9A%84%E9%85%8D%E7%BD%AE%E3%80%82"><span class="toc-number">1.7.12.</span> <span class="toc-text">◦^0 ：不锁定对应端口的配置。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%97%A6-1-%EF%BC%9A%E9%94%81%E5%AE%9A%E5%AF%B9%E5%BA%94%E7%AB%AF%E5%8F%A3%E7%9A%84%E9%85%8D%E7%BD%AE%E3%80%82"><span class="toc-number">1.7.13.</span> <span class="toc-text">◦^1 ：锁定对应端口的配置。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-GPIO%E6%A1%88%E4%BE%8B%EF%BC%9A%E6%B5%81%E6%B0%B4%E7%81%AF"><span class="toc-number">1.7.14.</span> <span class="toc-text">4. GPIO案例：流水灯</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%9C%80%E6%B1%82%E6%8F%8F%E8%BF%B0-1"><span class="toc-number">1.7.14.1.</span> <span class="toc-text">1. 需求描述</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9C%A8-3-%E4%B8%AALED%E4%B8%8A%E5%AE%9E%E7%8E%B0%E6%B5%81%E6%B0%B4%E7%81%AF%E6%95%88%E6%9E%9C%E3%80%82"><span class="toc-number">1.7.14.1.0.1.</span> <span class="toc-text">在 3 个LED上实现流水灯效果。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1-1"><span class="toc-number">1.7.14.2.</span> <span class="toc-text">2. 硬件电路设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%EF%BC%88%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%89"><span class="toc-number">1.7.14.3.</span> <span class="toc-text">3. 软件设计（寄存器）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E9%85%8D%E7%BD%AE"><span class="toc-number">1.7.14.3.1.</span> <span class="toc-text">1. 配置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81"><span class="toc-number">1.7.14.3.2.</span> <span class="toc-text">2. 具体代码</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84%E5%92%8C%E6%97%B6%E9%92%9F%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.8.</span> <span class="toc-text">4. 总体架构和时钟系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-STM32%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84"><span class="toc-number">1.8.1.</span> <span class="toc-text">1. STM32总体架构</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BB%8F%E8%BF%87%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%8C%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E4%BB%8E%E5%AE%8F%E8%A7%82%E4%B8%8A%E4%BA%86%E8%A7%A3%E4%B8%8B%E5%AE%83%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%EF%BC%8C%E5%90%84%E4%B8%AA%E6%A8%A1%E5%9D%97%E4%B9%8B%E9%97%B4%E7%9A%84%E5%B1%82%E7%BA%A7%E5%85%B3%E7%B3%BB%E4%BB%A5%E5%8F%8A%E7%9B%B8"><span class="toc-number">1.8.1.0.0.1.</span> <span class="toc-text">经过一段时间的学习，我们需要从宏观上了解下它的系统架构，各个模块之间的层级关系以及相</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BA%92%E7%9A%84%E5%BD%B1%E5%93%8D%E3%80%82"><span class="toc-number">1.8.1.0.0.2.</span> <span class="toc-text">互的影响。</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%97%B6%E9%92%9F%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.8.2.</span> <span class="toc-text">2. 时钟系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%97%B6%E9%92%9F%E6%A0%91"><span class="toc-number">1.8.2.1.</span> <span class="toc-text">1. 时钟树</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9C%A8STM32%E4%B8%AD%E6%9C%89-3-%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E6%97%B6%E9%92%9F%E6%BA%90%E7%94%A8%E6%9D%A5%E9%A9%B1%E5%8A%A8%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F-SYSCLK-%EF%BC%9A"><span class="toc-number">1.8.2.1.0.1.</span> <span class="toc-text">在STM32中有 3 种不同的时钟源用来驱动系统时钟(SYSCLK)：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%AF%E4%BB%A5%E7%9C%8B%E8%BF%99%E4%B8%AA%E7%AE%80%E5%9B%BE%EF%BC%9A"><span class="toc-number">1.8.2.1.0.2.</span> <span class="toc-text">可以看这个简图：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AF%A5%E6%97%B6%E9%92%9F%E6%A0%91%E7%9B%AE%E5%89%8D%E4%B8%8D%E8%A6%81%E6%B1%82%E8%AE%B0%E4%BD%8F%EF%BC%8C%E7%AD%89%E4%BB%A5%E5%90%8E%E7%BC%96%E7%A8%8B%E6%97%B6%EF%BC%8C%E5%8F%AA%E9%9C%80%E8%A6%81%E6%97%B6%E4%B8%8D%E6%97%B6%E5%9B%9E%E5%A4%B4%E7%BF%BB%E7%9C%8B%E5%8D%B3%E5%8F%AF%E3%80%82%E4%BB%A3%E7%A0%81%E5%86%99%E5%A4%9A%E4%BA%86%EF%BC%8C%E8%BF%99%E4%BA%9B%E7%9F%A5%E8%AF%86"><span class="toc-number">1.8.2.1.0.3.</span> <span class="toc-text">该时钟树目前不要求记住，等以后编程时，只需要时不时回头翻看即可。代码写多了，这些知识</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%87%AA%E4%BC%9A%E7%83%82%E7%86%9F%E4%BA%8E%E8%83%B8%E3%80%82"><span class="toc-number">1.8.2.1.0.4.</span> <span class="toc-text">自会烂熟于胸。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%90%84%E4%B8%AA%E6%97%B6%E9%92%9F%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.8.2.2.</span> <span class="toc-text">2. 各个时钟介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-HSE%E6%97%B6%E9%92%9F"><span class="toc-number">1.8.2.2.0.1.</span> <span class="toc-text">1. HSE时钟</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-HSI%E6%97%B6%E9%92%9F"><span class="toc-number">1.8.2.2.0.2.</span> <span class="toc-text">2. HSI时钟</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-PLL%E6%97%B6%E9%92%9F"><span class="toc-number">1.8.2.2.0.3.</span> <span class="toc-text">3. PLL时钟</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%86%85%E9%83%A8PLL%E7%94%A8%E6%9D%A5%E5%80%8D%E9%A2%91-HSIRC-%E7%9A%84%E8%BE%93%E5%87%BA%E6%97%B6%E9%92%9F%E6%88%96-HSE-%E6%99%B6%E4%BD%93%E8%BE%93%E5%87%BA%E6%97%B6%E9%92%9F%E3%80%82PLL%E7%9A%84%E8%AE%BE%E7%BD%AE%E5%BF%85%E9%A1%BB%E5%9C%A8%E5%85%B6%E8%A2%AB%E6%BF%80%E6%B4%BB%E5%89%8D%E5%AE%8C%E6%88%90%E3%80%82-%E4%B8%80"><span class="toc-number">1.8.2.2.0.4.</span> <span class="toc-text">内部PLL用来倍频 HSIRC 的输出时钟或 HSE 晶体输出时钟。PLL的设置必须在其被激活前完成。 一</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%97%A6PLL%E8%A2%AB%E6%BF%80%E6%B4%BB%EF%BC%8C%E8%BF%99%E4%BA%9B%E5%8F%82%E6%95%B0%E5%B0%B1%E4%B8%8D%E8%83%BD%E8%A2%AB%E6%94%B9%E5%8A%A8-%E3%80%82%E5%A6%82%E6%9E%9CPLL%E4%B8%AD%E6%96%AD%E5%9C%A8%E6%97%B6%E9%92%9F%E4%B8%AD%E6%96%AD%E5%AF%84%E5%AD%98%E5%99%A8%E9%87%8C%E8%A2%AB%E5%85%81%E8%AE%B8%EF%BC%8C%E5%BD%93PLL%E5%87%86%E5%A4%87%E5%B0%B1%E7%BB%AA"><span class="toc-number">1.8.2.2.0.5.</span> <span class="toc-text">旦PLL被激活，这些参数就不能被改动 。如果PLL中断在时钟中断寄存器里被允许，当PLL准备就绪</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%97%B6%EF%BC%8C%E5%8F%AF%E4%BA%A7%E7%94%9F%E4%B8%AD%E6%96%AD%E7%94%B3%E8%AF%B7%E3%80%82"><span class="toc-number">1.8.2.2.0.6.</span> <span class="toc-text">时，可产生中断申请。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-LSE%E6%97%B6%E9%92%9F"><span class="toc-number">1.8.2.2.0.7.</span> <span class="toc-text">4. LSE时钟</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5-LSI%E6%97%B6%E9%92%9F"><span class="toc-number">1.8.2.2.0.8.</span> <span class="toc-text">5. LSI时钟</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#LSIRC%E6%8B%85%E5%BD%93%E4%B8%80%E4%B8%AA%E4%BD%8E%E5%8A%9F%E8%80%97%E6%97%B6%E9%92%9F%E6%BA%90%E7%9A%84%E2%BB%86%E8%89%B2%EF%BC%8C%E5%AE%83%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%81%9C%E6%9C%BA%E5%92%8C%E5%BE%85%E6%9C%BA%E6%A8%A1%E5%BC%8F%E4%B8%8B%E4%BF%9D%E6%8C%81%E8%BF%90%E8%A1%8C%EF%BC%8C%E4%B8%BA%E7%8B%AC%E7%AB%8B%E7%9C%8B%E2%BB%94%E7%8B%97%E5%92%8C%E8%87%AA"><span class="toc-number">1.8.2.2.0.9.</span> <span class="toc-text">LSIRC担当一个低功耗时钟源的⻆色，它可以在停机和待机模式下保持运行，为独立看⻔狗和自</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-HAL%E5%BA%93%E5%BC%80%E5%8F%91%E5%85%A5%E2%BB%94"><span class="toc-number">1.9.</span> <span class="toc-text">5. HAL库开发入⻔</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-HAL%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.9.1.</span> <span class="toc-text">5.1 HAL介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0HAL%E5%BA%93%E5%BC%80%E5%8F%91"><span class="toc-number">1.9.1.0.0.1.</span> <span class="toc-text">1. 为什么要学习HAL库开发</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%B0%E7%9B%AE%E5%89%8D%E6%88%91%E4%BB%AC%E5%B7%B2%E7%BB%8F%E5%AD%A6%E4%BC%9A-1-%E7%A7%8D%E5%BC%80%E5%8F%91SMT32%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%A7%BF%E5%8A%BF%EF%BC%9A%E5%9F%BA%E4%BA%8E%E5%AF%84%E5%AD%98%E5%99%A8%E5%BC%80%E5%8F%91%E3%80%82"><span class="toc-number">1.9.1.0.0.2.</span> <span class="toc-text">到目前我们已经学会 1 种开发SMT32程序的姿势：基于寄存器开发。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E6%AF%94%E8%BE%83%E4%BD%8E%EF%BC%8C%E5%9C%A8%E5%B7%A5%E4%BD%9C%E4%B8%AD%E5%A6%82%E6%9E%9C%E6%83%B3-%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91-%E8%BF%98%E6%98%AF%E8%A6%81%E4%BC%9A%E7%94%A8%E5%88%B0HAL%E5%BA%93%E5%BC%80%E5%8F%91%E3%80%82"><span class="toc-number">1.9.1.0.0.3.</span> <span class="toc-text">寄存器开发效率比较低，在工作中如果想 快速开发 还是要会用到HAL库开发。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#HAL%E5%BA%93%E6%98%AF%E7%9B%AE%E5%89%8DST%E4%B8%BB%E5%8A%9B%E6%8E%A8%E5%B9%BF%E7%9A%84%E5%BC%80%E5%8F%91%E6%96%B9%E5%BC%8F%EF%BC%8C%E6%89%80%E4%BB%A5%E4%BD%A0%E5%A6%82%E6%9E%9C%E8%BF%98-%E8%A6%81%E7%94%A8ST%E7%9A%84%E8%8A%AF%E7%89%87-%EF%BC%8C%E4%BC%9A%E4%BD%BF%E7%94%A8HAL%E5%BA%93%E5%BC%80%E5%8F%91%E6%98%AF%E5%8A%BF%E5%9C%A8%E5%BF%85"><span class="toc-number">1.9.1.0.0.4.</span> <span class="toc-text">HAL库是目前ST主力推广的开发方式，所以你如果还 要用ST的芯片 ，会使用HAL库开发是势在必</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A1%8C%E7%9A%84%E3%80%82%E8%80%8C%E4%B8%94%E6%9C%80%E6%9C%80%E5%85%B3%E9%94%AE%E7%9A%84%E6%98%AF%EF%BC%8C%E4%BD%BF%E7%94%A8HAL%E5%BC%80%E5%8F%91%E6%9C%89%E8%AF%B8%E5%A4%9A%E7%9A%84%E5%A5%BD%E5%A4%84%E3%80%82"><span class="toc-number">1.9.1.0.0.5.</span> <span class="toc-text">行的。而且最最关键的是，使用HAL开发有诸多的好处。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9B%AE%E5%89%8D%EF%BC%8CHAL%E5%BA%93%E5%B7%B2%E7%BB%8F%E6%94%AF%E6%8C%81STM32%E5%85%A8%E7%BA%BF%E4%BA%A7%E5%93%81%E3%80%82"><span class="toc-number">1.9.1.0.0.6.</span> <span class="toc-text">目前，HAL库已经支持STM32全线产品。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AFHAL%E5%BA%93"><span class="toc-number">1.9.1.0.0.7.</span> <span class="toc-text">2. 什么是HAL库</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-HAL%E5%BA%93%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-number">1.9.2.</span> <span class="toc-text">5.2 HAL库开发环境搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AE%89%E8%A3%85Java%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83"><span class="toc-number">1.9.2.1.</span> <span class="toc-text">1. 安装Java运行环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AE%89%E8%A3%85STM32CubeMX"><span class="toc-number">1.9.2.2.</span> <span class="toc-text">2. 安装STM32CubeMX</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#ST%E5%85%AC%E5%8F%B8%E6%8F%90%E4%BE%9B%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B7%A5%E5%85%B7%EF%BC%8C%E9%9D%9E%E5%B8%B8%E6%96%B9%E4%BE%BF%E7%9A%84%E7%94%A8%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%9A%84%E6%96%B9%E5%BC%8F%E5%B8%AE%E6%88%91%E4%BB%AC%E5%88%9B%E5%BB%BA%E5%B7%A5%E7%A8%8B%EF%BC%8C%E5%92%8C%E5%AE%8C%E6%88%90%E5%90%84%E7%A7%8D%E9%85%8D%E7%BD%AE%E3%80%82"><span class="toc-number">1.9.2.2.0.1.</span> <span class="toc-text">ST公司提供的一个工具，非常方便的用图形化的方式帮我们创建工程，和完成各种配置。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%8C%E5%87%BB%E5%AE%89%E8%A3%85%E5%8D%B3%E5%8F%AF%E3%80%82"><span class="toc-number">1.9.2.2.0.2.</span> <span class="toc-text">双击安装即可。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%9C%A8%E7%BA%BF%E4%B8%8B%E8%BD%BD%E8%8A%AF%E7%89%87%E6%94%AF%E6%8C%81%E5%8C%85"><span class="toc-number">1.9.2.3.</span> <span class="toc-text">3. 在线下载芯片支持包</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%88%E5%AE%89%E8%A3%85%E4%B8%8B%E8%BD%AF%E4%BB%B6%E6%94%AF%E6%8C%81%E5%8C%85%EF%BC%9A"><span class="toc-number">1.9.2.3.0.1.</span> <span class="toc-text">先安装下软件支持包：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%82%B9%E5%87%BB%E5%AE%89%E8%A3%85%E4%B9%8B%E5%90%8E%EF%BC%8C%E9%9C%80%E8%A6%81%E5%85%88%E7%99%BB%E5%BD%95%E4%BD%A0%E7%9A%84ST%E8%B4%A6%E5%8F%B7%EF%BC%8C%E6%B2%A1%E6%9C%89%E5%B0%B1%E5%85%88%E6%B3%A8%E5%86%8C%E4%B8%80%E4%B8%AA%E3%80%82"><span class="toc-number">1.9.2.3.0.2.</span> <span class="toc-text">点击安装之后，需要先登录你的ST账号，没有就先注册一个。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E8%8A%AF%E7%89%87%E6%94%AF%E6%8C%81%E5%8C%85"><span class="toc-number">1.9.2.4.</span> <span class="toc-text">4. 离线安装芯片支持包</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E7%BD%91%E9%80%9F%E4%B8%8D%E5%A5%BD%EF%BC%8C%E4%B8%8B%E8%BD%BD%E4%BC%9A%E6%AF%94%E8%BE%83%E6%85%A2%E3%80%82%E4%B9%9F%E5%8F%AF%E4%BB%A5%E9%80%89%E6%8B%A9%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E3%80%82"><span class="toc-number">1.9.2.4.0.1.</span> <span class="toc-text">如果网速不好，下载会比较慢。也可以选择离线安装。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E4%B8%8B%E8%BD%BD%E7%A6%BB%E7%BA%BF%E8%8A%AF%E7%89%87%E6%94%AF%E6%8C%81%E5%8C%85"><span class="toc-number">1.9.2.4.0.2.</span> <span class="toc-text">1. 下载离线芯片支持包</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E5%AF%BC%E5%85%A5%E8%8A%AF%E7%89%87%E6%94%AF%E6%8C%81%E5%8C%85"><span class="toc-number">1.9.2.4.0.3.</span> <span class="toc-text">2. 导入芯片支持包</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-number">1.9.2.4.0.4.</span> <span class="toc-text">注意: </span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-LED%E6%B5%81%E6%B0%B4%E7%81%AF%E6%A1%88%E4%BE%8B%EF%BC%88HAL%E5%BA%93%EF%BC%89"><span class="toc-number">1.9.3.</span> <span class="toc-text">3. LED流水灯案例（HAL库）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E9%9C%80%E6%B1%82%E6%8F%8F%E8%BF%B0"><span class="toc-number">1.9.3.1.</span> <span class="toc-text">3.1 需求描述</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0LED%E6%B5%81%E6%B0%B4%E7%81%AF%E3%80%82%E7%94%A8%E7%9A%84GPIOA%E7%9A%840%E3%80%81-1-%E3%80%81-8-%E5%8F%A3%E3%80%82"><span class="toc-number">1.9.3.1.0.1.</span> <span class="toc-text">实现LED流水灯。用的GPIOA的0、 1 、 8 口。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.9.3.2.</span> <span class="toc-text">3.2 硬件电路设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.9.3.3.</span> <span class="toc-text">3.3 软件设计</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BAHAL%E5%BA%93%E5%B7%A5%E7%A8%8B"><span class="toc-number">1.9.3.3.1.</span> <span class="toc-text">1. 创建HAL库工程</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E6%93%8D%E4%BD%9C%E2%BB%9A%E9%9D%A2%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.9.3.3.1.1.</span> <span class="toc-text">1. 操作⻚面介绍</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E6%A0%B9%E6%8D%AE%E9%9C%80%E6%B1%82%E8%AE%BE%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="toc-number">1.9.3.3.1.2.</span> <span class="toc-text">2. 根据需求设置参数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-GPIO%E9%85%8D%E7%BD%AE"><span class="toc-number">1.9.3.3.1.3.</span> <span class="toc-text">3. GPIO配置</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-%E9%85%8D%E7%BD%AEPA0%E5%BC%95%E8%84%9A%E3%80%82"><span class="toc-number">1.9.3.3.1.4.</span> <span class="toc-text">4. 配置PA0引脚。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5-%E5%90%8C%E6%A0%B7%E7%9A%84%E6%96%B9%E5%BC%8F%E9%85%8D%E7%BD%AEPA1%E5%92%8CPA8%EF%BC%8C%E7%84%B6%E5%90%8E%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E8%BF%99-3-%E4%B8%AA%E5%BC%95%E8%84%9A%E3%80%82"><span class="toc-number">1.9.3.3.1.5.</span> <span class="toc-text">5. 同样的方式配置PA1和PA8，然后可以看到这 3 个引脚。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#6-%E5%88%86%E5%88%AB%E5%AF%B9%E4%BB%96%E4%BB%AC%E8%BF%9B%E8%A1%8C%E8%AE%BE%E7%BD%AE%E3%80%82"><span class="toc-number">1.9.3.3.1.6.</span> <span class="toc-text">6. 分别对他们进行设置。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#7-%E5%B7%A5%E7%A8%8B%E9%85%8D%E7%BD%AE"><span class="toc-number">1.9.3.3.1.7.</span> <span class="toc-text">7. 工程配置</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#8-%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81"><span class="toc-number">1.9.3.3.1.8.</span> <span class="toc-text">8. 生成代码</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E7%94%9F%E6%88%90%E7%9A%84%E5%B7%A5%E7%A8%8B%E7%9B%AE%E5%BD%95%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.9.3.3.1.9.</span> <span class="toc-text">3. 生成的工程目录介绍</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB"><span class="toc-number">1.9.3.3.2.</span> <span class="toc-text">2. 自动生成的代码解读</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%9E%84%E5%BB%BALED%E9%A9%B1%E5%8A%A8"><span class="toc-number">1.9.3.3.3.</span> <span class="toc-text">3. 构建LED驱动</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E6%B3%A8%E6%84%8F"><span class="toc-number">1.9.3.3.4.</span> <span class="toc-text">4. 注意</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-STM32%E7%9A%84%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.10.</span> <span class="toc-text">6. STM32的中断系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%AD%E6%96%AD%E6%A6%82%E8%BF%B0"><span class="toc-number">1.10.1.</span> <span class="toc-text">1. 中断概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%AD%E6%96%AD%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.10.1.1.</span> <span class="toc-text">1. 中断的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9C%A8%E4%B8%BB%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E5%87%BA%E7%8E%B0%E4%BA%86%E7%89%B9%E5%AE%9A%E4%BA%8B%E4%BB%B6%EF%BC%8C%E4%BD%BF%E5%BE%97CPU%E6%9A%82%E5%81%9C%E5%BD%93%E5%89%8D%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E7%A8%8B%E5%BA%8F%EF%BC%8C%E8%BD%AC%E8%80%8C%E5%8E%BB%E5%A4%84%E7%90%86%E8%BF%99%E4%B8%AA%E4%BA%8B"><span class="toc-number">1.10.1.1.0.1.</span> <span class="toc-text">在主程序运行过程中，出现了特定事件，使得CPU暂停当前正在运行的程序，转而去处理这个事</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BB%B6%EF%BC%8C%E7%AD%89%E8%BF%99%E4%B8%AA%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%AE%8C%E6%88%90%E4%B9%8B%E5%90%8E%EF%BC%8CCPU%E5%86%8D%E5%9B%9E%E5%88%B0%E5%88%9A%E6%89%8D%E8%A2%AB%E6%89%93%E6%96%AD%E7%9A%84%E4%BD%8D%E7%BD%AE%E7%BB%A7%E7%BB%AD%E5%A4%84%E7%90%86%EF%BC%8C%E8%BF%99%E5%B0%B1%E6%98%AF-%E4%B8%AD%E6%96%AD-%E3%80%82"><span class="toc-number">1.10.1.1.0.2.</span> <span class="toc-text">件，等这个事件处理完成之后，CPU再回到刚才被打断的位置继续处理，这就是 中断 。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9C%A8ARM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%AD%EF%BC%8C%E4%B8%AD%E6%96%AD%E9%80%9A%E5%B8%B8%E7%94%B1%E5%A4%96%E8%AE%BE%E6%88%96%E5%A4%96%E9%83%A8%E8%BE%93%E5%85%A5%E4%BA%A7%E7%94%9F%EF%BC%8C%E6%9C%89%E6%97%B6%E4%B9%9F%E5%8F%AF%E4%BB%A5%E7%94%B1%E8%BD%AF%E4%BB%B6%E8%A7%A6%E5%8F%91%E3%80%82%E4%B8%AD%E6%96%AD%E6%98%AF%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB"><span class="toc-number">1.10.1.1.0.3.</span> <span class="toc-text">在ARM体系结构中，中断通常由外设或外部输入产生，有时也可以由软件触发。中断是单片机系</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BB%9F%E5%A4%84%E7%90%86%E7%B4%A7%E6%80%A5%E6%88%96%E7%AA%81%E5%8F%91%E4%BA%8B%E4%BB%B6%E7%9A%84%E9%87%8D%E8%A6%81%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%A6%82%E5%AE%9A%E6%97%B6%E5%99%A8%E6%BA%A2%E5%87%BA%E3%80%81%E6%8C%89%E9%94%AE%E8%BE%93%E5%85%A5%E3%80%81%E4%B8%B2%E5%8F%A3%E6%95%B0%E6%8D%AE%E5%88%B0%E8%BE%BE%E7%AD%89%E3%80%82"><span class="toc-number">1.10.1.1.0.4.</span> <span class="toc-text">统处理紧急或突发事件的重要方式，如定时器溢出、按键输入、串口数据到达等。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%82%A3%E4%B8%AA%E6%89%93%E6%96%ADCPU%E6%89%A7%E8%A1%8C%E7%9A%84%E7%89%B9%E5%AE%9A%E4%BA%8B%E4%BB%B6%EF%BC%8C%E6%88%91%E4%BB%AC%E4%B8%80%E8%88%AC%E7%A7%B0%E4%B9%8B%E4%B8%BA-%E4%B8%AD%E6%96%AD%E6%BA%90-%E3%80%82%E8%A2%AB%E4%B8%AD%E6%96%AD%E6%BA%90%E6%89%93%E6%96%AD%E7%9A%84%E4%BD%8D%E7%BD%AE%E6%88%91%E4%BB%AC%E7%A7%B0%E4%B8%BA-%E6%96%AD%E7%82%B9-%E3%80%82%E5%A4%84"><span class="toc-number">1.10.1.1.0.5.</span> <span class="toc-text">那个打断CPU执行的特定事件，我们一般称之为 中断源 。被中断源打断的位置我们称为 断点 。处</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%90%86%E7%89%B9%E5%AE%9A%E4%BA%8B%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%8C%E6%88%91%E4%BB%AC%E7%A7%B0%E4%B8%BA%E6%89%A7%E8%A1%8C-%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F-%E3%80%82"><span class="toc-number">1.10.1.1.0.6.</span> <span class="toc-text">理特定事件的过程，我们称为执行 中断处理程序 。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%AD%A3%E5%9C%A8%E6%89%A7%E8%A1%8C%E4%B8%AD%E6%96%AD%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E8%BF%99%E4%B8%AA%E6%97%B6%E5%80%99%E6%9C%89%E5%8F%AF%E8%83%BD%E8%A2%AB%E5%8F%A6%E5%A4%96%E4%B8%80%E4%B8%AA%E4%B8%AD%E6%96%AD%E6%BA%90%E7%BB%99%E4%B8%AD%E6%96%AD%EF%BC%8CCPU%E8%BD%AC%E8%80%8C%E5%8E%BB%E6%89%A7%E8%A1%8C%E5%8F%A6%E5%A4%96%E4%B8%80%E4%B8%AA"><span class="toc-number">1.10.1.1.0.7.</span> <span class="toc-text">正在执行中断程序的时候，这个时候有可能被另外一个中断源给中断，CPU转而去执行另外一个</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E6%BA%90%E7%9A%84%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%EF%BC%8C%E8%BF%99%E5%8F%AB-%E4%B8%AD%E6%96%AD%E5%B5%8C%E5%A5%97-%E3%80%82"><span class="toc-number">1.10.1.1.0.8.</span> <span class="toc-text">中断源的中断处理程序，这叫 中断嵌套 。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%AD%E6%96%ADB%E8%83%BD%E5%90%A6%E6%89%93%E6%96%AD%E4%B8%AD%E6%96%ADA%EF%BC%8C%E8%A6%81%E7%9C%8B%E4%BB%96%E4%BB%AC%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%8C%E4%BC%98%E5%85%88%E7%BA%A7%E9%AB%98%E7%9A%84%E5%8F%AF%E4%BB%A5%E6%89%93%E6%96%AD%E4%BC%98%E5%85%88%E7%BA%A7%E4%BD%8E%E7%9A%84%EF%BC%8C%E4%BC%98%E5%85%88%E7%BA%A7%E4%BD%8E%E7%9A%84%E6%97%A0%E6%B3%95%E6%89%93%E6%96%AD%E4%BC%98"><span class="toc-number">1.10.1.1.0.9.</span> <span class="toc-text">中断B能否打断中断A，要看他们的优先级，优先级高的可以打断优先级低的，优先级低的无法打断优</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%88%E7%BA%A7%E9%AB%98%E7%9A%84%E3%80%82"><span class="toc-number">1.10.1.1.0.10.</span> <span class="toc-text">先级高的。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E6%BA%90%E5%8F%AF%E4%BB%A5%E6%98%AF%E5%A4%96%E9%83%A8%E7%9A%84%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E6%98%AF%E5%86%85%E9%83%A8%E7%9A%84%E3%80%82%E5%A4%96%E9%83%A8%E7%9A%84%E5%8F%AB-%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E6%BA%90-%EF%BC%8C%E5%86%85%E9%83%A8%E7%9A%84%E5%8F%AB-%E5%86%85%E9%83%A8%E4%B8%AD%E6%96%AD%E6%BA%90%EF%BC%88%E6%9C%89%E6%97%B6%E5%80%99%E4%B9%9F"><span class="toc-number">1.10.1.1.0.11.</span> <span class="toc-text">中断源可以是外部的，也可以是内部的。外部的叫 外部中断源 ，内部的叫 内部中断源（有时候也</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%AB%E5%BC%82%E5%B8%B8%EF%BC%89-%E3%80%82"><span class="toc-number">1.10.1.1.0.12.</span> <span class="toc-text">叫异常） 。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%AD%E6%96%AD"><span class="toc-number">1.10.1.2.</span> <span class="toc-text">2. 为什么需要中断</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AF%B9%E5%8D%95%E7%89%87%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%9D%A5%E8%AF%B4%EF%BC%8C-%E4%B8%AD%E6%96%AD%E8%87%B3%E5%85%B3%E9%87%8D%E8%A6%81-%E3%80%82"><span class="toc-number">1.10.1.2.0.1.</span> <span class="toc-text">对单片机系统来说， 中断至关重要 。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%9A%84%E4%B8%BB%E8%A6%81%E6%84%8F%E4%B9%89%E5%9C%A8%E4%BA%8E%E6%8F%90%E9%AB%98CPU%E7%9A%84%E6%95%88%E7%8E%87%EF%BC%8C%E8%80%8C%E4%B8%8D%E4%BC%9A%E4%B8%80%E7%9B%B4%E5%8D%A0%E7%94%A8CPU%EF%BC%8C%E5%AE%9E%E7%8E%B0%E5%AF%B9%E7%AA%81%E5%8F%91%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%AE%9E%E6%97%B6%E5%A4%84%E7%90%86%EF%BC%8C%E4%BB%A5%E5%8F%8A"><span class="toc-number">1.10.1.2.0.2.</span> <span class="toc-text">中断的主要意义在于提高CPU的效率，而不会一直占用CPU，实现对突发事件的实时处理，以及</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B9%B6%E8%A1%8C%E5%8C%96%E5%92%8C%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%88%87%E6%8D%A2%E3%80%82%E7%9B%B8%E8%BE%83%E4%BA%8E%E8%BD%AE%E8%AF%A2%E6%96%B9%E5%BC%8F%EF%BC%88%E5%8D%B3%E6%8C%89%E7%85%A7%E4%B8%80%E5%AE%9A%E7%9A%84%E9%A2%91%E7%8E%87%E5%92%8C%E5%91%A8%E6%9C%9F%E4%B8%8D%E6%96%AD%E5%9C%B0"><span class="toc-number">1.10.1.2.0.3.</span> <span class="toc-text">实现程序的并行化和嵌入式系统进程之间的切换。相较于轮询方式（即按照一定的频率和周期不断地</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E6%9F%90%E4%BA%9B%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%8F%91%E7%94%9F%EF%BC%89%EF%BC%8C%E4%B8%AD%E6%96%AD%E5%9C%A8%E5%A4%84%E7%90%86%E4%B8%80%E4%BA%9B%E5%81%B6%E7%84%B6%E5%8F%91%E7%94%9F%E7%9A%84%E4%BA%8B%E6%83%85%E6%97%B6%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98%E3%80%82"><span class="toc-number">1.10.1.2.0.4.</span> <span class="toc-text">检测某些事件的发生），中断在处理一些偶然发生的事情时效率更高。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%81%87%E8%AE%BE%E6%88%91%E4%BB%AC%E8%A6%81%E6%A3%80%E6%B5%8B%E6%8C%89%E9%94%AE%E6%98%AF%E5%90%A6%E6%8C%89%E4%B8%8B%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%E4%B8%AD%E6%96%AD%EF%BC%8C%E5%88%99%E9%9C%80%E8%A6%81%E7%94%A8%E5%BE%AA%E7%8E%AF%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%88%E9%98%BB%E5%A1%9E%EF%BC%89%E4%B8%8D%E6%96%AD%E7%9A%84%E5%8E%BB%E6%A3%80%E6%B5%8B%E6%8C%89%E9%94%AE"><span class="toc-number">1.10.1.2.0.5.</span> <span class="toc-text">假设我们要检测按键是否按下，如果没有中断，则需要用循环的方式（阻塞）不断的去检测按键</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AF%B9%E5%BA%94%E7%9A%84IO%E5%8F%A3%E7%9A%84%E7%94%B5%E5%B9%B3%EF%BC%8C%E8%BF%99%E6%98%AF%E6%AF%94%E8%BE%83%E8%80%97%E8%B4%B9CPU%E7%9A%84%E6%97%B6%E9%97%B4%E7%9A%84%E3%80%82%E5%A6%82%E6%9E%9C%E8%A6%81%E6%A3%80%E6%B5%8B%E7%9A%84%E6%9B%B4%E5%A4%9A%E7%9A%84%E8%AF%9D%EF%BC%8CC-PU%E6%9C%89%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%AF%BC%E8%87%B4%E9%98%BB%E5%A1%9E%E3%80%82"><span class="toc-number">1.10.1.2.0.6.</span> <span class="toc-text">对应的IO口的电平，这是比较耗费CPU的时间的。如果要检测的更多的话，C PU有可能会导致阻塞。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%88%99%E4%BD%BF%E8%BF%99%E4%BB%B6%E4%BA%8B%E7%AE%80%E5%8D%95%E5%8C%96-%EF%BC%8C%E4%B8%BB%E7%A8%8B%E5%BA%8F%E4%B8%8D%E9%9C%80%E8%A6%81%E5%BE%AA%E7%8E%AF%E4%B8%8D%E6%96%AD%E7%9A%84%E5%8E%BB%E6%A3%80%E6%B5%8B%E6%8C%89%E9%94%AE%EF%BC%8C%E5%BD%93%E6%9C%89%E6%8C%89%E9%94%AE%E6%8C%89%E4%B8%8B%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8CCPU%E6%89%A7%E8%A1%8C%E8%A2%AB%E6%89%93"><span class="toc-number">1.10.1.2.0.7.</span> <span class="toc-text">中断则使这件事简单化 ，主程序不需要循环不断的去检测按键，当有按键按下的时候，CPU执行被打</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%96%AD%EF%BC%8C%E5%8E%BB%E6%89%A7%E8%A1%8C%E6%8C%89%E9%94%AE%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F%E5%B0%B1%E8%A1%8C%E4%BA%86%E3%80%82%E5%BD%93%E6%B2%A1%E6%9C%89%E6%8C%89%E9%94%AE%E6%8C%89%E4%B8%8B%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8CCPU%E5%AE%8C%E5%85%A8%E5%8F%AF%E4%BB%A5%E6%AD%A3%E5%B8%B8%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%8C%E4%B8%9D%E6%AF%AB%E4%B8%8D%E5%8F%97%E4%BB%BB"><span class="toc-number">1.10.1.2.0.8.</span> <span class="toc-text">断，去执行按键处理程序就行了。当没有按键按下的时候，CPU完全可以正常执行代码，丝毫不受任</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%95%E7%9A%84%E5%BD%B1%E5%93%8D%E3%80%82"><span class="toc-number">1.10.1.2.0.9.</span> <span class="toc-text">何的影响。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-STM32%E7%9A%84%E4%B8%AD%E6%96%AD"><span class="toc-number">1.10.1.3.</span> <span class="toc-text">3. STM32的中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-STM32%E7%9A%84%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84"><span class="toc-number">1.10.1.4.</span> <span class="toc-text">4. STM32的中断体系架构</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BF%99%E5%9B%BE%E5%B7%B2%E7%BB%8F%E6%97%A0%E6%95%8C%E4%BA%86%EF%BC%81"><span class="toc-number">1.10.1.4.0.1.</span> <span class="toc-text">这图已经无敌了！</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-NVIC%E5%B5%8C%E5%A5%97%E5%90%91%E9%87%8F%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">1.10.1.5.</span> <span class="toc-text">5. NVIC嵌套向量中断控制器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-NVIC%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.10.1.5.1.</span> <span class="toc-text">1. NVIC的介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-NVIC%E5%8E%9F%E7%90%86"><span class="toc-number">1.10.1.5.2.</span> <span class="toc-text">2. NVIC原理</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A6%82%E5%9B%BE%EF%BC%9A"><span class="toc-number">1.10.1.5.2.1.</span> <span class="toc-text">如图：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%B8%AD%E6%96%AD%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.10.1.5.3.</span> <span class="toc-text">3. 中断优先级</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#NVIC%E4%B8%BA%E4%BA%86%E6%96%B9%E4%BE%BF%E7%AE%A1%E7%90%86%E4%B8%AD%E6%96%AD%EF%BC%8C%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E8%BD%AF%E4%BB%B6%E7%BB%99%E6%AF%8F%E4%B8%AA%E4%B8%AD%E6%96%AD%E8%AE%BE%E7%BD%AE%E4%BC%98%E5%85%88%E7%BA%A7%E3%80%82NVIC%E7%94%A8-4-%E4%B8%AA%E4%BD%8D%E6%9D%A5%E6%8E%A7%E5%88%B6%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%8C%E5%80%BC"><span class="toc-number">1.10.1.5.3.1.</span> <span class="toc-text">NVIC为了方便管理中断，可以通过软件给每个中断设置优先级。NVIC用 4 个位来控制优先级，值</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B0%8F%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E9%AB%98%E3%80%82%E6%8A%8A%E4%BC%98%E5%85%88%E7%BA%A7%E5%88%86%E4%B8%BA%E4%B8%A4%E7%A7%8D%EF%BC%9A%E6%8A%A2%E5%8D%A0%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E5%93%8D%E5%BA%94%E4%BC%98%E5%85%88%E7%BA%A7%E3%80%82"><span class="toc-number">1.10.1.5.3.2.</span> <span class="toc-text">小的优先级高。把优先级分为两种：抢占优先级和响应优先级。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A7%84%E5%88%99%EF%BC%9A"><span class="toc-number">1.10.1.5.3.3.</span> <span class="toc-text">规则：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%97%A6-%E4%BC%98%E5%85%88%E7%BA%A7%E5%80%BC%E8%B6%8A%E5%B0%8F%EF%BC%8C%E4%BC%98%E5%85%88%E7%BA%A7%E8%B6%8A%E9%AB%98%E3%80%82"><span class="toc-number">1.10.2.</span> <span class="toc-text">◦ 优先级值越小，优先级越高。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%97%A6-%E5%A6%82%E6%9E%9C%E4%B8%8D%E8%AE%BE%E7%BD%AE%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%8C%E5%88%99%E9%BB%98%E8%AE%A4%E4%BC%98%E5%85%88%E7%BA%A7%E4%B8%BA-0-%E3%80%82"><span class="toc-number">1.10.3.</span> <span class="toc-text">◦ 如果不设置优先级，则默认优先级为^0 。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%97%A6-%E5%85%88%E6%AF%94%E8%BE%83%E6%8A%A2%E5%8D%A0%E4%BC%98%E5%85%88%E7%BA%A7%E3%80%82%E6%8A%A2%E5%8D%A0%E4%BC%98%E5%85%88%E7%BA%A7%E9%AB%98%E7%9A%84%E5%8F%AF%E4%BB%A5%E6%89%93%E6%96%AD%E6%8A%A2%E5%8D%A0%E4%BC%98%E5%85%88%E7%BA%A7%E4%BD%8E%E7%9A%84%E3%80%82"><span class="toc-number">1.10.4.</span> <span class="toc-text">◦ 先比较抢占优先级。抢占优先级高的可以打断抢占优先级低的。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%97%A6-%E8%8B%A5%E6%8A%A2%E5%8D%A0%E4%BC%98%E5%85%88%E7%BA%A7%E4%B8%80%E6%A0%B7%EF%BC%8C%E5%86%8D%E6%AF%94%E8%BE%83%E5%93%8D%E5%BA%94%E4%BC%98%E5%85%88%E7%BA%A7%E3%80%82-%E4%BD%86%E6%98%AF%E5%93%8D%E5%BA%94%E4%BC%98%E5%85%88%E7%BA%A7%E4%B8%8D%E4%BC%9A%E5%AF%BC%E8%87%B4%E4%B8%AD%E6%96%AD%E5%B5%8C%E5%A5%97%E3%80%82"><span class="toc-number">1.10.5.</span> <span class="toc-text">◦ 若抢占优先级一样，再比较响应优先级。 但是响应优先级不会导致中断嵌套。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%97%A6-%E8%8B%A5-%E6%8A%A2%E5%8D%A0%E4%BC%98%E5%85%88%E7%BA%A7%E4%B8%80%E6%A0%B7-%E7%9A%84%E5%90%8C%E6%97%B6%E6%8C%82%E8%B5%B7%EF%BC%8C%E5%88%99%E4%BC%98%E5%85%88%E5%A4%84%E7%90%86-%E5%93%8D%E5%BA%94%E6%8A%A2%E5%8D%A0%E4%BC%98%E5%85%88%E7%BA%A7%E9%AB%98-%E7%9A%84%E3%80%82"><span class="toc-number">1.10.6.</span> <span class="toc-text">◦ 若 抢占优先级一样 的同时挂起，则优先处理 响应抢占优先级高 的。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%97%A6-%E8%8B%A5%E6%8C%82%E8%B5%B7%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%88%E6%8A%A2%E5%8D%A0%E5%92%8C%E5%93%8D%E5%BA%94%EF%BC%89%E9%83%BD%E4%B8%80%E6%A0%B7%EF%BC%8C%E5%88%99%E6%9F%A5%E6%89%BE%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8%EF%BC%8C%E5%80%BC%E5%B0%8F%E7%9A%84%E5%85%88%E5%93%8D%E5%BA%94%EF%BC%88%E7%9C%8B%E8%87%AA%E7%84%B6%E4%BC%98%E5%85%88%E7%BA%A7%E4%BC%98"><span class="toc-number">1.10.7.</span> <span class="toc-text">◦ 若挂起的优先级（抢占和响应）都一样，则查找中断向量表，值小的先响应（看自然优先级优</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%88%E7%BA%A7%EF%BC%89%E3%80%82"><span class="toc-number">1.10.7.0.0.1.</span> <span class="toc-text">先级）。</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%97%A6-NVIC%E5%AF%B9%E4%BC%98%E5%85%88%E7%BA%A7%E5%88%86%E4%BA%86-5-%E7%BB%84%EF%BC%8C%E5%9C%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%85%88%E5%AF%B9%E4%B8%AD%E6%96%AD%E8%BF%9B%E8%A1%8C%E5%88%86%E7%BB%84%EF%BC%8C%E4%BC%98%E5%85%88%E7%BA%A7%E5%AF%84%E5%AD%98%E5%99%A8IPR%E6%9C%898%E4%BD%8D%EF%BC%8C%E4%BD%86%E5%AE%9E%E9%99%85%E5%8F%AA%E4%BD%BF%E7%94%A8"><span class="toc-number">1.10.8.</span> <span class="toc-text">◦ NVIC对优先级分了^5 组，在程序中先对中断进行分组，优先级寄存器IPR有8位，但实际只使用</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%B0%E9%AB%984%E4%BD%8D%EF%BC%8C%E7%94%A8%E4%BA%8E%E5%86%B3%E5%AE%9A%E6%8A%A2%E5%8D%A0%E4%BC%98%E5%85%88%E7%BA%A7%E3%80%81%E5%93%8D%E5%BA%94%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E7%AD%89%E7%BA%A7%E3%80%82"><span class="toc-number">1.10.8.0.0.1.</span> <span class="toc-text">到高4位，用于决定抢占优先级、响应优先级的等级。</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%97%A6-%E5%85%B7%E4%BD%93%E8%BF%994%E4%BD%8D%E5%A6%82%E4%BD%95%E5%88%87%E5%89%B2%EF%BC%9F%E7%94%B1%E5%8F%88%E7%94%B1AIRCR%E5%AF%84%E5%AD%98%E5%99%A8%E6%8E%A7%E5%88%B6%EF%BC%8C%E8%80%8C%E4%B8%94%E5%88%86%E7%BB%84%E5%8F%AA%E8%83%BD%E5%88%86%E4%B8%80%E6%AC%A1%EF%BC%8C%E8%8B%A5%E5%A4%9A%E6%AC%A1%E5%88%86%EF%BC%8C%E5%8F%AA%E6%9C%89%E6%9C%80%E5%90%8E"><span class="toc-number">1.10.9.</span> <span class="toc-text">◦ 具体这4位如何切割？由又由AIRCR寄存器控制，而且分组只能分一次，若多次分，只有最后</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%80%E6%AC%A1%E7%94%9F%E6%95%88%E3%80%82"><span class="toc-number">1.10.9.0.0.1.</span> <span class="toc-text">一次生效。</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-NVIC%E5%B8%B8%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.10.9.0.1.</span> <span class="toc-text">4. NVIC常用寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A6%82%E5%9B%BE%EF%BC%9A-1"><span class="toc-number">1.10.9.0.1.1.</span> <span class="toc-text">如图：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-NVIC%E9%85%8D%E7%BD%AE%E6%80%9D%E8%B7%AF"><span class="toc-number">1.10.9.0.2.</span> <span class="toc-text">5. NVIC配置思路</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E4%B8%AD%E6%96%AD%E5%88%86%E7%BB%84%E2%86%92%E8%AE%BE%E7%BD%AE%E4%B8%AD%E6%96%AD%E4%BC%98%E5%85%88%E7%BA%A7%E2%86%92%E4%BD%BF%E8%83%BD%E4%B8%AD%E6%96%AD"><span class="toc-number">1.10.9.0.2.1.</span> <span class="toc-text">设置中断分组→设置中断优先级→使能中断 </span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8"><span class="toc-number">1.10.9.1.</span> <span class="toc-text">6. 中断向量表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%8E%BC-%E6%B3%A8%E6%84%8F%EF%BC%9A"><span class="toc-number">1.10.9.2.</span> <span class="toc-text">🎼 注意：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E4%B8%AD%E6%96%AD%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.10.9.3.</span> <span class="toc-text">7. 中断执行流程</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%8F%91%E7%94%9F%E6%97%B6%EF%BC%8CSTM32%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-number">1.10.9.3.0.1.</span> <span class="toc-text">中断发生时，STM32的执行流程如下：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%A6%96%E5%85%88%EF%BC%8C%E7%94%B1%E5%A4%96%E8%AE%BE%E5%8F%91%E5%87%BA%E4%B8%AD%E6%96%AD%E8%AF%B7%E6%B1%82%EF%BC%9B%E7%84%B6%E5%90%8E%EF%BC%8C%E5%A4%84%E7%90%86%E5%99%A8%E6%9A%82%E5%81%9C%E5%BD%93%E5%89%8D%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BB%BB%E5%8A%A1%EF%BC%8C%E4%BF%9D%E6%8A%A4%E7%8E%B0%E5%9C%BA%EF%BC%88%E5%A6%82%E5%B0%86%E5%BD%93%E5%89%8D%E4%BD%8D%E7%BD%AE%E7%9A%84PC"><span class="toc-number">1.10.9.3.0.2.</span> <span class="toc-text">首先，由外设发出中断请求；然后，处理器暂停当前执行的任务，保护现场（如将当前位置的PC</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E5%8E%8B%E6%A0%88%EF%BC%89%EF%BC%9B%E6%8E%A5%E7%9D%80%EF%BC%8C%E7%A8%8B%E5%BA%8F%E8%B7%B3%E8%BD%AC%E5%88%B0%E5%AF%B9%E5%BA%94%E7%9A%84%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%EF%BC%88ISR%EF%BC%89%E5%B9%B6%E6%89%A7%E8%A1%8C%EF%BC%9B%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%AF%95%E5%90%8E%EF%BC%8C%E6%81%A2%E5%A4%8D"><span class="toc-number">1.10.9.3.0.3.</span> <span class="toc-text">地址压栈）；接着，程序跳转到对应的中断服务程序（ISR）并执行；中断服务程序执行完毕后，恢复</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%8E%B0%E5%9C%BA%EF%BC%88%E5%A6%82%E5%B0%86%E6%A0%88%E9%A1%B6%E7%9A%84%E5%80%BC%E9%80%81%E5%9B%9EPC%EF%BC%89%EF%BC%9B%E6%9C%80%E5%90%8E%EF%BC%8C%E5%A4%84%E7%90%86%E5%99%A8%E8%BF%94%E5%9B%9E%E5%88%B0%E8%A2%AB%E4%B8%AD%E6%96%AD%E7%9A%84%E4%BD%8D%E7%BD%AE%EF%BC%8C%E7%BB%A7%E7%BB%AD%E6%89%A7%E8%A1%8C%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8C%87%E4%BB%A4%E3%80%82"><span class="toc-number">1.10.9.3.0.4.</span> <span class="toc-text">现场（如将栈顶的值送回PC）；最后，处理器返回到被中断的位置，继续执行下一个指令。</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%AD%E6%96%AD%E6%A1%88%E4%BE%8B%EF%BC%9A%E6%A3%80%E6%B5%8B%E6%8C%89%E9%94%AE%E6%8C%89%E4%B8%8B"><span class="toc-number">1.10.10.</span> <span class="toc-text">2. 中断案例：检测按键按下</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%9C%80%E6%B1%82%E6%8F%8F%E8%BF%B0-2"><span class="toc-number">1.10.10.1.</span> <span class="toc-text">1. 需求描述</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E6%A3%80%E6%B5%8B%E6%8C%89%E9%94%AEKEY3%EF%BC%8C%E5%BD%93%E6%8C%89%E9%94%AE%E6%8C%89%E4%B8%8B%EF%BC%8C%E7%BF%BB%E8%BD%ACLED1%E6%98%BE%E7%A4%BA%E3%80%82"><span class="toc-number">1.10.10.1.0.1.</span> <span class="toc-text">利用外部中断检测按键KEY3，当按键按下，翻转LED1显示。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1-2"><span class="toc-number">1.10.10.2.</span> <span class="toc-text">2. 硬件电路设计</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-LED1%E7%9A%84%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF"><span class="toc-number">1.10.10.2.1.</span> <span class="toc-text">1. LED1的硬件电路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-KEY%E7%9A%84%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF"><span class="toc-number">1.10.10.2.2.</span> <span class="toc-text">2. KEY的硬件电路</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AF%B4%E6%98%8E%EF%BC%9A-1"><span class="toc-number">1.10.10.2.2.1.</span> <span class="toc-text">说明：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#1-PF10%E5%AF%B9%E5%BA%94%E7%9A%84%E6%98%AFKEY-3-SW3-%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E8%AE%BE%E7%BD%AEPF10%E7%9A%84%E6%A8%A1%E5%BC%8F%E4%B8%BA-%E4%B8%8B%E6%8B%89%E8%BE%93%E5%85%A5-%EF%BC%8C%E5%88%99%E5%BD%93%E6%8C%89%E9%94%AE%E6%B2%A1%E6%9C%89%E6%8C%89%E4%B8%8B%E7%9A%84%E6%97%B6%E5%80%99%E6%98%AF%E4%BD%8E"><span class="toc-number">1.10.10.2.2.2.</span> <span class="toc-text">1. PF10对应的是KEY_3(SW3),我们可以设置PF10的模式为 下拉输入 ，则当按键没有按下的时候是低</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%94%B5%E5%B9%B3%EF%BC%8C%E5%BD%93%E6%8C%89%E9%94%AE%E6%8C%89%E4%B8%8B%E7%9A%84%E6%97%B6%E5%80%99%E6%98%AF%E9%AB%98%E7%94%B5%E5%B9%B3%E3%80%82"><span class="toc-number">1.10.10.2.2.3.</span> <span class="toc-text">电平，当按键按下的时候是高电平。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%EF%BC%88%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%89-1"><span class="toc-number">1.10.10.3.</span> <span class="toc-text">3. 软件设计（寄存器）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E6%88%91%E4%BB%AC%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%EF%BC%8C%E5%9C%A8%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%9F%BA%E7%A1%80%E4%B8%8A%E4%BF%AE%E6%94%B9%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%81%E5%8E%BB%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE%E6%AD%A5%E9%AA%A4%E3%80%82"><span class="toc-number">1.10.10.3.0.1.</span> <span class="toc-text">复制我们第一个项目，在第一个项目的基础上修改，可以省去一些配置步骤。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%A6%E5%A4%96%E6%96%87%E4%BB%B6%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%BB%A5%E5%90%8E%E4%B8%8D%E5%86%8D%E8%AF%B4%E6%98%8E%E3%80%82"><span class="toc-number">1.10.10.3.0.2.</span> <span class="toc-text">另外文件如何创建以后不再说明。</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-main-c"><span class="toc-number">1.10.10.3.1.</span> <span class="toc-text">3.1 main.c</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-Delay-h"><span class="toc-number">1.10.10.3.2.</span> <span class="toc-text">3.2 Delay.h</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-Delay-c"><span class="toc-number">1.10.10.3.3.</span> <span class="toc-text">3.3 Delay.c</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-Driver-LED-h"><span class="toc-number">1.10.10.3.4.</span> <span class="toc-text">3.4 Driver_LED.h</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-5-Driver-LED-c"><span class="toc-number">1.10.10.3.5.</span> <span class="toc-text">3.5 Driver_LED.c</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-6-Driver-Key-h"><span class="toc-number">1.10.10.3.6.</span> <span class="toc-text">3.6 Driver_Key.h</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-7-Driver-Key-c"><span class="toc-number">1.10.10.3.7.</span> <span class="toc-text">3.7 Driver_Key.c</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%80%9D%E8%80%83"><span class="toc-number">1.10.10.4.</span> <span class="toc-text">4. 思考</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%8E%81"><span class="toc-number">1.10.10.5.</span> <span class="toc-text">🎁</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%80%8CGPIOA-gt-IDR%E6%98%AF%E4%B8%80%E4%B8%AA%E8%BE%93%E5%85%A5%E6%95%B0%E6%8D%AE%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%8C%E5%85%B6%E4%B8%AD%E7%9A%84%E6%AF%8F%E4%B8%80%E4%BD%8D%E5%AF%B9%E5%BA%94%E4%B8%80%E4%B8%AA%E7%89%B9%E5%AE%9A%E7%9A%84%E8%BE%93%E5%85%A5%E5%BC%95%E8%84%9A%E7%9A%84%E7%8A%B6%E6%80%81%EF%BC%88%E9%80%9A"><span class="toc-number">1.10.10.5.0.1.</span> <span class="toc-text">而GPIOA-&gt;IDR是一个输入数据寄存器，其中的每一位对应一个特定的输入引脚的状态（通</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B8%B8%E6%98%AF-0-%E6%88%96-1-%EF%BC%89%E3%80%82"><span class="toc-number">1.10.10.5.0.2.</span> <span class="toc-text">常是 0 或 1 ）。 </span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%EF%BC%88HAL%E5%BA%93%EF%BC%89"><span class="toc-number">1.10.10.6.</span> <span class="toc-text">5. 软件设计（HAL库）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-STM32CubeMX%E9%85%8D%E7%BD%AE"><span class="toc-number">1.10.10.6.1.</span> <span class="toc-text">1. STM32CubeMX配置</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%85%8D%E7%BD%AELED1%E7%9A%84PA0%E5%BC%95%E8%84%9A%E3%80%82"><span class="toc-number">1.10.10.6.1.1.</span> <span class="toc-text">配置LED1的PA0引脚。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%B0%83%E6%95%B4%E6%BB%B4%E7%AD%94%E5%AE%9A%E6%97%B6%E5%99%A8%E5%92%8C%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E3%80%82%E5%90%A6%E5%88%99%E4%BD%BF%E7%94%A8%E5%BB%B6%E6%97%B6%E6%B6%88%E6%8A%96%E4%BC%9A%E5%8D%A1%E6%AD%BB%E3%80%82"><span class="toc-number">1.10.10.6.1.2.</span> <span class="toc-text">调整滴答定时器和外部中断的优先级。否则使用延时消抖会卡死。</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-GPIO%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%A3%E7%A0%81"><span class="toc-number">1.10.10.6.2.</span> <span class="toc-text">2. GPIO初始化代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%B7%BB%E5%8A%A0%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0"><span class="toc-number">1.10.10.6.3.</span> <span class="toc-text">3. 添加中断处理函数</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-USART%E4%B8%B2%E5%8F%A3%E9%80%9A%E8%AE%AF"><span class="toc-number">1.11.</span> <span class="toc-text">7. USART串口通讯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%80%9A%E8%AE%AF%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.11.1.</span> <span class="toc-text">1. 通讯基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%B2%E5%8F%A3%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.11.1.1.</span> <span class="toc-text">1. 串口介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%B2%E5%8F%A3%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.11.1.2.</span> <span class="toc-text">2. 串口通讯协议</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%AD%E4%B8%AA%E9%87%8D%E7%82%B9%EF%BC%9A"><span class="toc-number">1.11.1.2.0.1.</span> <span class="toc-text">六个重点：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E6%B3%A2%E7%89%B9%E7%8E%87"><span class="toc-number">1.11.1.2.0.2.</span> <span class="toc-text">1. 波特率</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-USART%E5%A4%96%E8%AE%BE"><span class="toc-number">1.11.2.</span> <span class="toc-text">2. USART外设</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#STM32%E7%9A%84USART%E5%8A%9F%E8%83%BD%E6%A1%86%E5%9B%BE%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-number">1.11.2.0.0.1.</span> <span class="toc-text">STM32的USART功能框图如下：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#7-%E5%8A%9F%E8%83%BD%E5%BC%95%E8%84%9A%E8%AF%B4%E6%98%8E"><span class="toc-number">1.11.2.0.0.2.</span> <span class="toc-text">7. 功能引脚说明</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%81%87%E8%AE%BE%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E7%9A%84%E6%B3%A2%E7%89%B9%E7%8E%87%E6%98%AF-115200-%EF%BC%8C%E5%88%99%E5%AF%B9%E5%BA%94%E7%9A%84%E5%88%86%E9%A2%91%E5%80%BC%E5%BA%94%E8%AF%A5%E6%98%AF%EF%BC%9A-39-0625-%EF%BC%8C%E6%8A%8A%E8%BF%99%E4%B8%AA%E5%80%BC%E5%86%99%E5%85%A5%E5%88%B0BRR%E5%AF%84%E5%AD%98"><span class="toc-number">1.11.2.0.0.3.</span> <span class="toc-text">假设我们需要的波特率是 115200 ，则对应的分频值应该是： 39.0625 ，把这个值写入到BRR寄存</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%B2%E5%8F%A3%E6%A1%88%E4%BE%8B-1-%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%92%8C%E4%B8%B2%E5%8F%A3%E9%80%9A%E8%AE%AF"><span class="toc-number">1.11.3.</span> <span class="toc-text">3. 串口案例 1 ：计算机和串口通讯</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%9C%80%E6%B1%82%E6%8F%8F%E8%BF%B0-3"><span class="toc-number">1.11.3.1.</span> <span class="toc-text">1. 需求描述</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%94%B5%E8%84%91%E9%80%9A%E8%BF%87%E4%B8%B2%E5%8F%A3%E5%90%91STM32%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%EF%BC%8CSTM32%E5%8E%9F%E5%B0%81%E4%B8%8D%E5%8A%A8%E7%9A%84%E5%86%8D%E5%8F%91%E9%80%81%E8%BF%87%E6%9D%A5%E3%80%82%E7%94%B5%E8%84%91%E5%8F%AF%E4%BB%A5%E5%80%9F%E5%8A%A9%E4%B8%B2%E5%8F%A3%E5%8A%A9%E6%89%8B%E6%9D%A5%E5%8F%91%E9%80%81"><span class="toc-number">1.11.3.1.0.1.</span> <span class="toc-text">电脑通过串口向STM32发送数据，STM32原封不动的再发送过来。电脑可以借助串口助手来发送</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%88%96%E6%8E%A5%E5%8F%97%E6%95%B0%E6%8D%AE%E3%80%82"><span class="toc-number">1.11.3.1.0.2.</span> <span class="toc-text">或接受数据。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1-3"><span class="toc-number">1.11.3.2.</span> <span class="toc-text">2. 硬件电路设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%EF%BC%9A%E8%BD%AE%E8%AF%A2%E7%9A%84%E6%96%B9%E5%BC%8F%E6%8E%A5%E6%94%B6%EF%BC%88%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%89"><span class="toc-number">1.11.3.3.</span> <span class="toc-text">3. 软件设计：轮询的方式接收（寄存器）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-main-c-1"><span class="toc-number">1.11.3.3.1.</span> <span class="toc-text">3.1 main.c</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-Driver-USART-h"><span class="toc-number">1.11.3.3.2.</span> <span class="toc-text">3.2 Driver_USART.h</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-Driver-USART-c"><span class="toc-number">1.11.3.3.3.</span> <span class="toc-text">3.3 Driver_USART.c</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%EF%BC%9A%E4%B8%AD%E6%96%AD%E7%9A%84%E6%96%B9%E5%BC%8F%E6%8E%A5%E6%94%B6%EF%BC%88%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%89"><span class="toc-number">1.11.3.4.</span> <span class="toc-text">4. 软件设计：中断的方式接收（寄存器）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#USART%E6%8F%90%E4%BE%9B%E4%BA%86%E5%A4%9A%E4%B8%AA%E4%B8%AD%E6%96%AD%E4%BA%8B%E4%BB%B6%E3%80%82"><span class="toc-number">1.11.3.4.0.1.</span> <span class="toc-text">USART提供了多个中断事件。</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-Driver-USART-c"><span class="toc-number">1.11.3.4.1.</span> <span class="toc-text">4.1 Driver_USART.c</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E4%B8%AD%E6%96%AD%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81"><span class="toc-number">1.11.3.4.1.1.</span> <span class="toc-text">添加中断相关代码</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-main-c"><span class="toc-number">1.11.3.4.2.</span> <span class="toc-text">4.2 main.c</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%EF%BC%88HAL%E5%BA%93%EF%BC%89-1"><span class="toc-number">1.11.3.5.</span> <span class="toc-text">5. 软件设计（HAL库）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8STM32CubeMx%E6%90%AD%E5%BB%BA%E5%B7%A5%E7%A8%8B"><span class="toc-number">1.11.3.5.1.</span> <span class="toc-text">1. 使用STM32CubeMx搭建工程</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE"><span class="toc-number">1.11.3.5.1.1.</span> <span class="toc-text">1. 基本配置</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E6%B7%BB%E5%8A%A0%E6%88%91%E4%BB%AC%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">1.11.3.5.1.2.</span> <span class="toc-text">3. 添加我们的代码</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%97%B6%E9%92%9F%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%8C%E4%B8%B2%E5%8F%A3%E5%88%9D%E5%A7%8B%E5%8C%96%E5%B7%A5%E5%85%B7%E5%B7%B2%E7%BB%8F%E5%B8%AE%E6%88%91%E4%BB%AC%E5%AE%8C%E6%88%90%E4%BA%86%E3%80%82%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E8%BD%AE%E8%AF%A2%E6%96%B9%E5%BC%8F%E6%94%B6%E5%8F%91%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E9%87%87%E7%94%A8%E4%B8%AD%E6%96%AD"><span class="toc-number">1.11.3.5.1.3.</span> <span class="toc-text">时钟初始化，串口初始化工具已经帮我们完成了。我们可以轮询方式收发数据，也可以采用中断</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%9A%84%E6%96%B9%E5%BC%8F%E6%94%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E3%80%82"><span class="toc-number">1.11.3.5.1.4.</span> <span class="toc-text">的方式收发数据。</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E8%BD%AE%E8%AF%A2%E7%9A%84%E6%96%B9%E5%BC%8F%E6%94%B6%E5%8F%91"><span class="toc-number">1.11.3.5.2.</span> <span class="toc-text">2. 轮询的方式收发</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BD%AE%E8%AF%A2%E7%9A%84%E6%96%B9%E5%BC%8F%E5%B0%B1%E6%98%AF%E5%9C%A8%E5%BE%AA%E7%8E%AF%E4%B8%AD%E4%B8%80%E7%9B%B4%E6%A3%80%E6%B5%8B%E4%B8%B2%E5%8F%A3%EF%BC%8C%E6%98%AF%E5%90%A6%E6%9C%89%E6%95%B0%E6%8D%AE%E8%BF%9B%E6%9D%A5%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%9C%89%E5%B0%B1%E8%AF%BB%E8%BF%9B%E6%9D%A5%EF%BC%8C%E7%84%B6%E5%90%8E%E5%86%8D%E5%8E%9F%E5%B0%81%E4%B8%8D%E5%8A%A8%E7%9A%84"><span class="toc-number">1.11.3.5.2.1.</span> <span class="toc-text">轮询的方式就是在循环中一直检测串口，是否有数据进来，如果有就读进来，然后再原封不动的</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%91%E5%87%BA%E3%80%82"><span class="toc-number">1.11.3.5.2.2.</span> <span class="toc-text">发出。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BD%AE%E8%AF%A2%E6%96%B9%E5%BC%8F%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9A%E8%BD%AE%E8%AF%A2%E6%A8%A1%E5%BC%8F%E4%BD%BF%E7%94%A8%E8%B5%B7%E6%9D%A5%E6%9C%80%E7%AE%80%E5%8D%95%EF%BC%8C%E4%BD%86%E6%98%AF%E4%BC%9A%E5%8D%A0%E7%94%A8%E5%A4%A7%E9%87%8F%E7%9A%84CPU%E6%97%B6%E9%97%B4%EF%BC%8C%E5%9C%A8%E7%AD%89%E5%BE%85%E6%8E%A5%E6%94%B6%E5%92%8C%E7%AD%89"><span class="toc-number">1.11.3.5.2.3.</span> <span class="toc-text">轮询方式的一些问题：轮询模式使用起来最简单，但是会占用大量的CPU时间，在等待接收和等</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BE%85%E5%8F%91%E9%80%81%E5%AE%8C%E6%AF%95%E6%97%B6%EF%BC%8CCPU%E4%B8%8D%E8%83%BD%E5%8E%BB%E5%81%9A%E5%88%AB%E7%9A%84%E8%BF%90%E7%AE%97%EF%BC%8C%E5%8F%AA%E8%83%BD%E5%9C%A8%E8%BF%99%E9%87%8C%E7%A9%BA%E7%AD%89%EF%BC%8C%E8%BF%90%E8%A1%8C%E7%9A%84%E6%95%88%E7%8E%87%E5%BE%88%E4%BD%8E%E3%80%82"><span class="toc-number">1.11.3.5.2.4.</span> <span class="toc-text">待发送完毕时，CPU不能去做别的运算，只能在这里空等，运行的效率很低。</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%B8%AD%E6%96%AD%E7%9A%84%E6%96%B9%E5%BC%8F%E6%8E%A5%E6%94%B6%EF%BC%9A%E5%AE%9A%E2%BB%93%E6%95%B0%E6%8D%AE"><span class="toc-number">1.11.3.5.3.</span> <span class="toc-text">3. 中断的方式接收：定⻓数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E4%B8%AD%E6%96%AD%E7%9A%84%E6%96%B9%E5%BC%8F%E6%8E%A5%E6%94%B6%EF%BC%9A%E5%8F%98%E2%BB%93%E6%95%B0%E6%8D%AE"><span class="toc-number">1.11.3.5.4.</span> <span class="toc-text">4. 中断的方式接收：变⻓数据</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%B8%B2%E5%8F%A3%E6%A1%88%E4%BE%8B-2-%EF%BC%9A%E9%87%8D%E5%AE%9A%E5%90%91printf"><span class="toc-number">1.11.4.</span> <span class="toc-text">4. 串口案例 2 ：重定向printf</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%9C%80%E6%B1%82%E6%8F%8F%E8%BF%B0-4"><span class="toc-number">1.11.4.1.</span> <span class="toc-text">1. 需求描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%EF%BC%88%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%89"><span class="toc-number">1.11.4.2.</span> <span class="toc-text">2. 软件设计（寄存器）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-Driver-USART-c"><span class="toc-number">1.11.4.2.1.</span> <span class="toc-text">2.1 Driver_USART.c</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-main-c"><span class="toc-number">1.11.4.2.2.</span> <span class="toc-text">2.2 main.c</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-Keil%E8%AE%BE%E7%BD%AE"><span class="toc-number">1.11.4.2.3.</span> <span class="toc-text">2.3 Keil设置</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%EF%BC%88HAL%E5%BA%93%EF%BC%89"><span class="toc-number">1.11.4.3.</span> <span class="toc-text">3. 软件设计（HAL库）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-usart-h%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%95"><span class="toc-number">1.11.4.3.1.</span> <span class="toc-text">3.1 usart.h代码清单</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-usart-c%E4%BB%A3%E7%A0%81%E6%B8%85%E5%8D%95"><span class="toc-number">1.11.4.3.2.</span> <span class="toc-text">3.2 usart.c代码清单</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-I2C%E9%80%9A%E8%AE%AF"><span class="toc-number">1.12.</span> <span class="toc-text">8. I2C通讯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-I2C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.12.1.</span> <span class="toc-text">1. I2C基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%8C%85-%E5%9C%A8I%C2%B2C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E4%B8%AD%EF%BC%8CSDA%EF%BC%88SerialDataLine%EF%BC%89%E7%9A%84%E7%94%B5%E5%B9%B3%E7%8A%B6%E6%80%81%E7%A1%AE%E5%AE%9E%E7%94%A8%E6%9D%A5%E8%A1%A8%E7%A4%BA%E9%80%9A%E4%BF%A1%E7%9A%84%E6%8E%A7%E5%88%B6%E6%9D%83%E5%BD%92"><span class="toc-number">1.12.1.1.</span> <span class="toc-text">🌅 在I²C通信协议中，SDA（SerialDataLine）的电平状态确实用来表示通信的控制权归</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.12.2.</span> <span class="toc-text">介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E6%80%BB%E7%BA%BF%E7%A9%BA%E9%97%B2%E7%8A%B6%E6%80%81%EF%BC%9A"><span class="toc-number">1.12.2.0.0.1.</span> <span class="toc-text">1. 总线空闲状态：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%97%A6-%E5%BD%93%E6%80%BB%E7%BA%BF%E7%A9%BA%E9%97%B2%E6%97%B6%EF%BC%8CSDA%E5%92%8CSCL%E9%83%BD%E8%A2%AB%E4%B8%8A%E6%8B%89%E7%94%B5%E9%98%BB%E6%8B%89%E9%AB%98%EF%BC%8C%E8%A1%A8%E7%A4%BA%E6%B2%A1%E6%9C%89%E8%AE%BE%E5%A4%87%E5%9C%A8%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BA%BF%E3%80%82%E8%BF%99%E6%98%AF%E6%80%BB%E7%BA%BF%E7%9A%84"><span class="toc-number">1.12.3.</span> <span class="toc-text">◦ 当总线空闲时，SDA和SCL都被上拉电阻拉高，表示没有设备在使用总线。这是总线的</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E7%8A%B6%E6%80%81%E3%80%82"><span class="toc-number">1.12.3.0.0.1.</span> <span class="toc-text">默认状态。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E5%90%AF%E5%8A%A8%E5%92%8C%E5%81%9C%E6%AD%A2%E6%9D%A1%E4%BB%B6%EF%BC%9A"><span class="toc-number">1.12.3.0.0.2.</span> <span class="toc-text">2. 启动和停止条件：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%97%A6-I2C%E9%80%9A%E4%BF%A1%E5%BC%80%E5%A7%8B%E6%97%B6%EF%BC%8C%E4%B8%BB%E8%AE%BE%E5%A4%87%E4%BC%9A%E5%8F%91%E5%87%BA%E4%B8%80%E4%B8%AA%E5%90%AF%E5%8A%A8%E6%9D%A1%E4%BB%B6%EF%BC%88StartCondition%EF%BC%89%EF%BC%8C%E8%BF%99%E8%A1%A8%E7%8E%B0%E4%B8%BAS-DA%E4%BB%8E%E9%AB%98"><span class="toc-number">1.12.4.</span> <span class="toc-text">◦ I2C通信开始时，主设备会发出一个启动条件（StartCondition），这表现为S DA从高</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%88%B0%E4%BD%8E%E7%9A%84%E8%B7%B3%E5%8F%98%EF%BC%8C%E8%80%8CSCL%E4%BF%9D%E6%8C%81%E9%AB%98%E7%94%B5%E5%B9%B3%E3%80%82"><span class="toc-number">1.12.4.0.0.1.</span> <span class="toc-text">到低的跳变，而SCL保持高电平。</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%97%A6-%E9%80%9A%E4%BF%A1%E7%BB%93%E6%9D%9F%E6%97%B6%EF%BC%8C%E4%B8%BB%E8%AE%BE%E5%A4%87%E4%BC%9A%E5%8F%91%E5%87%BA%E4%B8%80%E4%B8%AA%E5%81%9C%E6%AD%A2%E6%9D%A1%E4%BB%B6%EF%BC%88StopCondition%EF%BC%89%EF%BC%8C%E8%BF%99%E8%A1%A8%E7%8E%B0%E4%B8%BASDA%E4%BB%8E%E4%BD%8E%E5%88%B0"><span class="toc-number">1.12.5.</span> <span class="toc-text">◦ 通信结束时，主设备会发出一个停止条件（StopCondition），这表现为SDA从低到</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%AB%98%E7%9A%84%E8%B7%B3%E5%8F%98%EF%BC%8C%E8%80%8CSCL%E4%BF%9D%E6%8C%81%E9%AB%98%E7%94%B5%E5%B9%B3%E3%80%82"><span class="toc-number">1.12.5.0.0.1.</span> <span class="toc-text">高的跳变，而SCL保持高电平。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%EF%BC%9A"><span class="toc-number">1.12.5.0.0.2.</span> <span class="toc-text">3. 数据传输：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%97%A6-%E5%9C%A8%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E6%97%A0%E8%AE%BA%E6%98%AF%E4%B8%BB%E8%AE%BE%E5%A4%87%E8%BF%98%E6%98%AF%E4%BB%8E%E8%AE%BE%E5%A4%87%EF%BC%8C%E9%83%BD%E5%9C%A8SCL%E6%97%B6%E9%92%9F%E5%91%A8%E6%9C%9F%E5%86%85%E9%A9%B1%E5%8A%A8SDA%E7%BA%BF%E8%BF%9B%E8%A1%8C%E6%95%B0"><span class="toc-number">1.12.6.</span> <span class="toc-text">◦ 在数据传输过程中，无论是主设备还是从设备，都在SCL时钟周期内驱动SDA线进行数</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8D%AE%E4%BC%A0%E8%BE%93%E3%80%82%E5%BD%93%E6%9F%90%E4%B8%AA%E8%AE%BE%E5%A4%87%E9%9C%80%E8%A6%81%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E6%97%B6%EF%BC%8C%E5%AE%83%E4%BC%9A%E6%8E%A7%E5%88%B6SDA%E7%BA%BF%EF%BC%8C%E5%9C%A8SCL%E7%9A%84%E4%B8%8A%E5%8D%87%E6%B2%BF%E4%B9%8B%E5%89%8D%E8%AE%BE%E7%BD%AE%E5%A5%BD%E6%95%B0"><span class="toc-number">1.12.6.0.0.1.</span> <span class="toc-text">据传输。当某个设备需要发送数据时，它会控制SDA线，在SCL的上升沿之前设置好数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8D%AE%E3%80%82"><span class="toc-number">1.12.6.0.0.2.</span> <span class="toc-text">据。</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%97%A6-%E4%B8%BB%E8%AE%BE%E5%A4%87%E5%9C%A8%E5%8F%91%E9%80%81%E5%AE%8C%E5%9C%B0%E5%9D%80%E5%90%8E%EF%BC%8C%E6%A0%B9%E6%8D%AELSB%E7%9A%84%E5%80%BC%EF%BC%88LSB%E6%98%AF%E7%94%A8%E6%9D%A5%E6%8C%87%E7%A4%BA%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E7%9A%84%E8%AF%BB%E5%86%99%E6%96%B9%E5%90%91%E7%9A%84%EF%BC%89%E7%BB%A7%E7%BB%AD"><span class="toc-number">1.12.7.</span> <span class="toc-text">◦ 主设备在发送完地址后，根据LSB的值（LSB是用来指示数据传输的读写方向的）继续</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E3%80%82"><span class="toc-number">1.12.7.0.0.1.</span> <span class="toc-text">进行数据传输。</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%97%A6-%E5%A6%82%E6%9E%9C%E6%98%AF%E5%86%99%E6%93%8D%E4%BD%9C%EF%BC%8C%E4%B8%BB%E8%AE%BE%E5%A4%87%E4%BC%9A%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E5%AD%97%E8%8A%82%E5%88%B0%E4%BB%8E%E8%AE%BE%E5%A4%87%EF%BC%8C%E7%84%B6%E5%90%8E%E7%AD%89%E5%BE%85%E4%BB%8E%E8%AE%BE%E5%A4%87%E7%9A%84%E7%A1%AE%E8%AE%A4%E4%BF%A1%E5%8F%B7%E3%80%82"><span class="toc-number">1.12.8.</span> <span class="toc-text">◦ 如果是写操作，主设备会发送数据字节到从设备，然后等待从设备的确认信号。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%97%A6-%E5%A6%82%E6%9E%9C%E6%98%AF%E8%AF%BB%E6%93%8D%E4%BD%9C%EF%BC%8C%E4%BB%8E%E8%AE%BE%E5%A4%87%E8%A6%81%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E3%80%82%E5%9C%A8%E8%BF%99%E7%A7%8D%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E4%B8%BB%E8%AE%BE%E5%A4%87%E9%87%8A%E6%94%BESDA%E7%BA%BF%EF%BC%8C%E8%AE%A9S-DA%E9%80%9A%E8%BF%87"><span class="toc-number">1.12.9.</span> <span class="toc-text">◦ 如果是读操作，从设备要响应数据。在这种情况下，主设备释放SDA线，让S DA通过</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%8A%E6%8B%89%E7%94%B5%E9%98%BB%E6%81%A2%E5%A4%8D%E5%88%B0%E9%AB%98%E7%94%B5%E5%B9%B3%EF%BC%8C%E7%84%B6%E5%90%8E%E4%BB%8E%E8%AE%BE%E5%A4%87%E5%9C%A8%E6%8E%A5%E4%B8%8B%E6%9D%A5%E7%9A%84%E6%97%B6%E9%92%9F%E5%91%A8%E6%9C%9F%E5%86%85%E9%A9%B1%E5%8A%A8SDA%E7%BA%BF%EF%BC%8C%E4%BB%A5%E5%8F%91%E9%80%81%E6%95%B0"><span class="toc-number">1.12.9.0.0.1.</span> <span class="toc-text">上拉电阻恢复到高电平，然后从设备在接下来的时钟周期内驱动SDA线，以发送数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8D%AE%E3%80%82%E4%B8%BB%E8%AE%BE%E5%A4%87%E4%BC%9A%E6%8E%A5%E6%94%B6%E4%BB%8E%E8%AE%BE%E5%A4%87%E5%8F%91%E9%80%81%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%B9%B6%E5%8F%91%E9%80%81%E7%A1%AE%E8%AE%A4%EF%BC%88ACK%EF%BC%89%E6%88%96%E9%9D%9E%E7%A1%AE%E8%AE%A4%EF%BC%88NACK%EF%BC%89%E4%BF%A1%E5%8F%B7%E4%BB%A5"><span class="toc-number">1.12.9.0.0.2.</span> <span class="toc-text">据。主设备会接收从设备发送的数据，并发送确认（ACK）或非确认（NACK）信号以</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%91%8A%E7%9F%A5%E4%BB%8E%E8%AE%BE%E5%A4%87%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E7%BB%A7%E7%BB%AD%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E3%80%82"><span class="toc-number">1.12.9.0.0.3.</span> <span class="toc-text">告知从设备是否需要继续发送数据。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9B%A0%E4%B8%BASDA%E8%A2%AB%E8%AE%BE%E8%AE%A1%E6%88%90%E5%BC%80%E6%BC%8F%E9%A9%B1%E5%8A%A8%EF%BC%8C%E4%BB%BB%E4%BD%95%E8%AE%BE%E5%A4%87%E9%83%BD%E5%8F%AA%E8%83%BD%E6%8B%89%E4%BD%8ESDA%EF%BC%8C%E8%80%8C%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E6%8B%89%E9%AB%98%EF%BC%8C%E8%BF%99%E6%A0%B7%E4%B9%9F%E9%81%BF%E5%85%8D"><span class="toc-number">1.12.9.0.0.4.</span> <span class="toc-text">因为SDA被设计成开漏驱动，任何设备都只能拉低SDA，而不能直接拉高，这样也避免</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BA%86%E5%A4%9A%E4%B8%AA%E8%AE%BE%E5%A4%87%E5%90%8C%E6%97%B6%E9%A9%B1%E5%8A%A8SDA%E7%BA%BF%E6%97%B6%E7%9A%84%E7%94%B5%E5%B9%B3%E5%86%B2%E7%AA%81%EF%BC%8C%E8%BF%99%E6%A0%B7%E7%9A%84%E4%B8%80%E7%A7%8D%E6%9C%BA%E5%88%B6%E4%BF%9D%E8%AF%81%E4%BA%86I2C%E6%80%BB%E7%BA%BF%E4%B8%8A%E8%AE%BE%E5%A4%87%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8D%8F%E8%B0%83"><span class="toc-number">1.12.9.0.0.5.</span> <span class="toc-text">了多个设备同时驱动SDA线时的电平冲突，这样的一种机制保证了I2C总线上设备之间的协调</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%92%8C%E6%97%A0%E5%86%B2%E7%AA%81%E9%80%9A%E4%BF%A1%E3%80%82"><span class="toc-number">1.12.9.0.0.6.</span> <span class="toc-text">和无冲突通信。</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E6%96%B9%E5%90%91"><span class="toc-number">1.12.10.</span> <span class="toc-text">通信方向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-I2C%E6%A1%88%E4%BE%8B-1-%EF%BC%9A%E8%BD%AF%E4%BB%B6%E6%A8%A1%E6%8B%9FI2C"><span class="toc-number">1.12.11.</span> <span class="toc-text">2. I2C案例 1 ：软件模拟I2C</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#EEPROM%E8%8A%AF%E7%89%87%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84%E9%80%9A%E8%AE%AF%E6%96%B9%E5%BC%8F%E5%B0%B1%E6%98%AFI2C%E5%8D%8F%E8%AE%AE%E3%80%82%E6%88%91%E4%BB%AC%E4%BD%BF%E7%94%A8%E7%9A%84%E8%8A%AF%E7%89%87%E6%98%AFM24C02%E3%80%82"><span class="toc-number">1.12.11.0.0.1.</span> <span class="toc-text">EEPROM芯片最常用的通讯方式就是I2C协议。我们使用的芯片是M24C02。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%9C%80%E6%B1%82%E6%8F%8F%E8%BF%B0-5"><span class="toc-number">1.12.11.1.</span> <span class="toc-text">1. 需求描述</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%88%91%E4%BB%AC%E5%90%91E2PROM%E5%86%99%E5%85%A5%E4%B8%80%E6%AE%B5%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%86%8D%E8%AF%BB%E5%8F%96%E5%87%BA%E6%9D%A5%EF%BC%8C%E6%9C%80%E5%90%8E%E5%8F%91%E9%80%81%E5%88%B0%E4%B8%B2%E5%8F%A3%EF%BC%8C%E6%A0%B8%E5%AF%B9%E6%98%AF%E5%90%A6%E8%AF%BB%E5%86%99%E6%AD%A3%E7%A1%AE%E3%80%82"><span class="toc-number">1.12.11.1.0.1.</span> <span class="toc-text">我们向E2PROM写入一段数据，再读取出来，最后发送到串口，核对是否读写正确。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1-4"><span class="toc-number">1.12.11.2.</span> <span class="toc-text">2. 硬件电路设计</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%A1%AC%E4%BB%B6%E5%8E%9F%E7%90%86%E5%9B%BE"><span class="toc-number">1.12.11.2.1.</span> <span class="toc-text">1. 硬件原理图</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-M24C02%E7%AE%80%E4%BB%8B"><span class="toc-number">1.12.11.2.2.</span> <span class="toc-text">2. M24C02简介</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-M24C02%E7%9A%84SCL%E5%8F%8ASDA%E5%BC%95%E8%84%9A%E8%BF%9E%E6%8E%A5%E5%88%B0%E4%BA%86STM32%E5%AF%B9%E5%BA%94%E7%9A%84I2C%E5%BC%95%E8%84%9A%E4%B8%AD%EF%BC%8C%E7%BB%93%E5%90%88%E4%B8%8A%E6%8B%89%E7%94%B5%E9%98%BB%EF%BC%8C%E6%9E%84%E6%88%90%E4%BA%86I2C%E9%80%9A%E8%AE%AF%E6%80%BB"><span class="toc-number">1.12.11.2.2.1.</span> <span class="toc-text">1. M24C02的SCL及SDA引脚连接到了STM32对应的I2C引脚中，结合上拉电阻，构成了I2C通讯总</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BA%BF%EF%BC%8C%E5%AE%83%E4%BB%AC%E9%80%9A%E8%BF%87I2C%E6%80%BB%E7%BA%BF%E4%BA%A4%E4%BA%92%E3%80%82"><span class="toc-number">1.12.11.2.2.2.</span> <span class="toc-text">线，它们通过I2C总线交互。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-E2PROM%E8%8A%AF%E7%89%87%E7%9A%84%E8%AE%BE%E5%A4%87%E5%9C%B0%E5%9D%80%E4%B8%80%E5%85%B1%E6%9C%89-7-%E4%BD%8D%EF%BC%8C%E5%85%B6%E4%B8%AD%E9%AB%98-4-%E4%BD%8D%E5%9B%BA%E5%AE%9A%E4%B8%BA%EF%BC%9A-1010-%EF%BC%8C%E4%BD%8E-3-%E4%BD%8D%E5%88%99%E7%94%B1E-3-E2-E1%E4%BF%A1%E5%8F%B7%E7%BA%BF%E7%9A%84%E7%94%B5%E5%B9%B3"><span class="toc-number">1.12.11.2.2.3.</span> <span class="toc-text">2. E2PROM芯片的设备地址一共有 7 位，其中高 4 位固定为： 1010 ，低 3 位则由E 3&#x2F;E2&#x2F;E1信号线的电平</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%86%B3%E5%AE%9AE2PROM%E8%AE%BE%E5%A4%87%E5%9C%B0%E5%9D%80%E3%80%82"><span class="toc-number">1.12.11.2.2.4.</span> <span class="toc-text">决定E2PROM设备地址。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-R-W%E6%98%AF%E8%AF%BB%E5%86%99%E6%96%B9%E5%90%91%E6%8E%A7%E5%88%B6%E4%BD%8D%EF%BC%8C%E4%B8%8E%E5%9C%B0%E5%9D%80%E6%97%A0%E5%85%B3%E3%80%82"><span class="toc-number">1.12.11.2.2.5.</span> <span class="toc-text">3. R&#x2F;W是读写方向控制位，与地址无关。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%94%B1%E4%BA%8EI2C%E9%80%9A%E8%AE%AF%E6%97%B6%E5%B8%B8%E5%B8%B8%E6%98%AF%E5%9C%B0%E5%9D%80%E8%B7%9F%E8%AF%BB%E5%86%99%E6%96%B9%E5%90%91%E8%BF%9E%E5%9C%A8%E4%B8%80%E8%B5%B7%E6%9E%84%E6%88%90%E4%B8%80%E4%B8%AA-8-%E4%BD%8D%E6%95%B0%EF%BC%8C%E4%B8%94%E5%BD%93R-W%E4%BD%8D%E4%B8%BA-0-%E6%97%B6%EF%BC%8C%E8%A1%A8%E7%A4%BA%E5%86%99%E6%96%B9%E5%90%91%EF%BC%8C"><span class="toc-number">1.12.11.2.2.6.</span> <span class="toc-text">由于I2C通讯时常常是地址跟读写方向连在一起构成一个 8 位数，且当R&#x2F;W位为 0 时，表示写方向，</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%93%8D%E4%BD%9C%E6%97%B6%E5%BA%8F%E5%9B%BE%E6%95%B4%E7%90%86"><span class="toc-number">1.12.11.3.</span> <span class="toc-text">3. 操作时序图整理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%B5%B7%E5%A7%8B%E5%92%8C%E5%81%9C%E6%AD%A2%E4%BF%A1%E5%8F%B7"><span class="toc-number">1.12.11.3.1.</span> <span class="toc-text">1. 起始和停止信号</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E6%9C%89%E6%95%88%E6%80%A7"><span class="toc-number">1.12.11.3.2.</span> <span class="toc-text">2. 数据有效性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%93%8D%E5%BA%94%E5%92%8C%E9%9D%9E%E5%93%8D%E5%BA%94"><span class="toc-number">1.12.11.3.3.</span> <span class="toc-text">3. 响应和非响应</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%86%99%E5%85%A5%E4%B8%80%E4%B8%AA%E5%AD%97%E8%8A%82%E6%97%B6%E5%BA%8F"><span class="toc-number">1.12.11.3.4.</span> <span class="toc-text">4. 写入一个字节时序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E8%AF%BB%E5%87%BA%E4%B8%80%E4%B8%AA%E5%AD%97%E8%8A%82%E6%97%B6%E5%BA%8F"><span class="toc-number">1.12.11.3.5.</span> <span class="toc-text">5. 读出一个字节时序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E5%8D%95%E6%AC%A1%E5%86%99%E5%85%A5%E5%A4%9A%E4%B8%AA%E5%AD%97%E8%8A%82%E6%97%B6%E5%BA%8F"><span class="toc-number">1.12.11.3.6.</span> <span class="toc-text">6. 单次写入多个字节时序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-%E5%8D%95%E6%AC%A1%E8%AF%BB%E5%87%BA%E5%A4%9A%E4%B8%AA%E5%AD%97%E8%8A%82%E6%97%B6%E5%BA%8F"><span class="toc-number">1.12.11.3.7.</span> <span class="toc-text">7. 单次读出多个字节时序</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AF%BB%E5%87%BA%E5%A4%9A%E4%B8%AA%E5%AD%97%E8%8A%82%E7%9A%84%E6%97%B6%E5%80%99%E6%B2%A1%E6%9C%89%E9%99%90%E5%88%B6%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%AF%BB%E5%87%BA%E4%BB%BB%E6%84%8F%E5%A4%9A%E4%B8%AA%E3%80%82"><span class="toc-number">1.12.11.3.7.1.</span> <span class="toc-text">读出多个字节的时候没有限制，可以读出任意多个。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%EF%BC%88%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%89"><span class="toc-number">1.12.11.4.</span> <span class="toc-text">4. 软件设计（寄存器）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-main-c"><span class="toc-number">1.12.11.4.1.</span> <span class="toc-text">4.1 main.c</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-2-Driver-I2C2-h"><span class="toc-number">1.12.11.4.2.</span> <span class="toc-text">4.2 Driver_I2C2.h</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-Driver-I2C2-c"><span class="toc-number">1.12.11.4.3.</span> <span class="toc-text">4.3 Driver_I2C2.c</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-4-Inf-W24C02-h"><span class="toc-number">1.12.11.4.4.</span> <span class="toc-text">4.4 Inf_W24C02.h</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-5-Inf-W24C02-c"><span class="toc-number">1.12.11.4.5.</span> <span class="toc-text">4.5 Inf_W24C02.c</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-I2C%E6%A1%88%E4%BE%8B-2-%EF%BC%9A%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0I2C"><span class="toc-number">1.12.12.</span> <span class="toc-text">3. I2C案例 2 ：硬件实现I2C</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%9C%80%E6%B1%82%E6%8F%8F%E8%BF%B0-6"><span class="toc-number">1.12.12.1.</span> <span class="toc-text">1. 需求描述</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8STM32%E7%9A%84I2C%E5%A4%96%E8%AE%BE%E8%AF%BB%E5%86%99E2PROM%EF%BC%8C%E5%9F%BA%E4%BA%8E%E5%AF%84%E5%AD%98%E5%99%A8%E6%93%8D%E4%BD%9C%E3%80%82%E4%B8%8D%E9%9C%80%E8%A6%81%E6%89%8B%E5%8A%A8%E6%8E%A7%E5%88%B6%E5%BC%95%E8%84%9A%E7%94%B5%E5%B9%B3%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%EF%BC%8C%E5%8F%AA"><span class="toc-number">1.12.12.1.0.1.</span> <span class="toc-text">使用STM32的I2C外设读写E2PROM，基于寄存器操作。不需要手动控制引脚电平的输入输出，只</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E6%93%8D%E4%BD%9CI2C%E5%A4%96%E8%AE%BE%E5%AF%B9%E5%BA%94%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8%E5%8D%B3%E5%8F%AF%E3%80%82"><span class="toc-number">1.12.12.1.0.2.</span> <span class="toc-text">需要操作I2C外设对应的寄存器即可。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1-5"><span class="toc-number">1.12.12.2.</span> <span class="toc-text">2. 硬件电路设计</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-I2C%E5%A4%96%E8%AE%BE%E7%AE%80%E4%BB%8B"><span class="toc-number">1.12.12.2.1.</span> <span class="toc-text">2.1 I2C外设简介</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%89%8D%E9%9D%A2%E6%88%91%E4%BB%AC%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%A8%A1%E6%8B%9FI2C%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0%E4%BA%86%E9%80%9A%E8%AE%AF%EF%BC%8C%E4%BB%A3%E7%A0%81%E5%86%99%E8%B5%B7%E6%9D%A5%E6%AF%94%E8%BE%83%E5%A4%8D%E6%9D%82%E3%80%82"><span class="toc-number">1.12.12.2.1.1.</span> <span class="toc-text">前面我们用软件模拟I2C协议实现了通讯，代码写起来比较复杂。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%B5%B7%E5%A7%8BSTM32%E6%9C%89%E4%B8%93%E2%BB%94%E8%B4%9F%E8%B4%A3%E5%8D%8F%E8%AE%AE%E7%9A%84I2C%E5%A4%96%E8%AE%BE%EF%BC%8C%E5%8F%AA%E8%A6%81%E9%85%8D%E7%BD%AE%E5%A5%BD%E8%AF%A5%E5%A4%96%E8%AE%BE%EF%BC%8C%E5%AE%83%E5%B0%B1%E4%BC%9A%E8%87%AA%E5%8A%A8%E6%A0%B9%E6%8D%AE%E5%8D%8F%E8%AE%AE%E8%A6%81%E6%B1%82%E4%BA%A7%E7%94%9F%E9%80%9A%E8%AE%AF%E4%BF%A1"><span class="toc-number">1.12.12.2.1.2.</span> <span class="toc-text">起始STM32有专⻔负责协议的I2C外设，只要配置好该外设，它就会自动根据协议要求产生通讯信</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%B7%EF%BC%8C%E6%94%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E5%B9%B6%E7%BC%93%E5%AD%98%E8%B5%B7%E6%9D%A5%EF%BC%8CCPU%E5%8F%AA%E8%A6%81%E6%A3%80%E6%B5%8B%E8%AF%A5%E5%A4%96%E8%AE%BE%E7%9A%84%E7%8A%B6%E6%80%81%E5%92%8C%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%8C%E5%B0%B1%E8%83%BD%E5%AE%8C%E6%88%90%E6%95%B0%E6%8D%AE%E6%94%B6%E5%8F%91%E3%80%82"><span class="toc-number">1.12.12.2.1.3.</span> <span class="toc-text">号，收发数据并缓存起来，CPU只要检测该外设的状态和访问数据寄存器，就能完成数据收发。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BF%99%E7%A7%8D%E7%94%B1%E7%A1%AC%E4%BB%B6%E5%A4%96%E8%AE%BE%E5%A4%84%E7%90%86I2C%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%96%B9%E5%BC%8F%E5%87%8F%E8%BD%BB%E4%BA%86CPU%E7%9A%84%E5%B7%A5%E4%BD%9C%EF%BC%8C%E4%B8%94%E4%BD%BF%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%9B%B4%E5%8A%A0%E7%AE%80%E5%8D%95%E3%80%82"><span class="toc-number">1.12.12.2.1.4.</span> <span class="toc-text">这种由硬件外设处理I2C协议的方式减轻了CPU的工作，且使软件设计更加简单。</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-STM32%E7%9A%84I2C%E5%A4%96%E8%AE%BE%E7%9A%84%E5%8A%9F%E8%83%BD%E6%A1%86%E5%9B%BE"><span class="toc-number">1.12.12.2.2.</span> <span class="toc-text">2.2 STM32的I2C外设的功能框图</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#I2C%E7%9A%84%E6%89%80%E6%9C%89%E7%A1%AC%E4%BB%B6%E6%9E%B6%E6%9E%84%E9%83%BD%E6%98%AF%E6%A0%B9%E6%8D%AE%E5%9B%BE%E4%B8%AD%E5%B7%A6%E4%BE%A7SCL%E7%BA%BF%E5%92%8CSDA%E7%BA%BF%E5%B1%95%E5%BC%80%E7%9A%84%EF%BC%88%E5%85%B6%E4%B8%AD%E7%9A%84SMBA%E7%BA%BF%E7%94%A8%E4%BA%8ESMBUS%E7%9A%84%E8%AD%A6%E5%91%8A%E4%BF%A1"><span class="toc-number">1.12.12.2.2.1.</span> <span class="toc-text">I2C的所有硬件架构都是根据图中左侧SCL线和SDA线展开的（其中的SMBA线用于SMBUS的警告信</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%B7%EF%BC%8CI2C%E9%80%9A%E8%AE%AF%E6%B2%A1%E6%9C%89%E4%BD%BF%E7%94%A8%EF%BC%89%E3%80%82STM32%E8%8A%AF%E7%89%87%E6%9C%89%E5%A4%9A%E4%B8%AAI2C%E5%A4%96%E8%AE%BE%EF%BC%8C%E5%92%B1%E4%BB%AC%E7%8E%B0%E5%9C%A8%E7%94%A8%E7%9A%84%E8%BF%99%E6%AC%BE%E6%9C%89-2-%E4%B8%AAI-2C%E5%A4%96%E8%AE%BE%EF%BC%8C%E5%AE%83%E4%BB%AC%E7%9A%84I2C%E9%80%9A"><span class="toc-number">1.12.12.2.2.2.</span> <span class="toc-text">号，I2C通讯没有使用）。STM32芯片有多个I2C外设，咱们现在用的这款有 2 个I 2C外设，它们的I2C通</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AE%AF%E4%BF%A1%E5%8F%B7%E5%BC%95%E5%87%BA%E5%88%B0%E4%B8%8D%E5%90%8C%E7%9A%84GPIO%E5%BC%95%E8%84%9A%E4%B8%8A%EF%BC%8C%E4%BD%BF%E7%94%A8%E6%97%B6%E5%BF%85%E9%A1%BB%E9%85%8D%E7%BD%AE%E5%88%B0%E8%BF%99%E4%BA%9B%E6%8C%87%E5%AE%9A%E7%9A%84%E5%BC%95%E8%84%9A%E3%80%82"><span class="toc-number">1.12.12.2.2.3.</span> <span class="toc-text">讯信号引出到不同的GPIO引脚上，使用时必须配置到这些指定的引脚。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%EF%BC%88%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%89-2"><span class="toc-number">1.12.12.3.</span> <span class="toc-text">3. 软件设计（寄存器）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-main-c-2"><span class="toc-number">1.12.12.3.1.</span> <span class="toc-text">3.1 main.c</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-Driver-I2C2-h"><span class="toc-number">1.12.12.3.2.</span> <span class="toc-text">3.2 Driver_I2C2.h</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-Driver-I2C2-c"><span class="toc-number">1.12.12.3.3.</span> <span class="toc-text">3.3 Driver_I2C2.c</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-Inf-W24C02-h"><span class="toc-number">1.12.12.3.4.</span> <span class="toc-text">3.4 Inf_W24C02.h</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-5-Inf-W24C02-c"><span class="toc-number">1.12.12.3.5.</span> <span class="toc-text">3.5 Inf_W24C02.c</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%B3%A8%E6%84%8F-1"><span class="toc-number">1.12.12.4.</span> <span class="toc-text">4. 注意</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-GPIO%E4%B8%BA%E5%A4%8D%E7%94%A8%E5%8A%9F%E8%83%BD"><span class="toc-number">1.12.12.4.0.1.</span> <span class="toc-text">1. GPIO为复用功能 </span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B6%89%E5%8F%8A%E5%88%B0%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E9%85%8D%E7%BD%AE%EF%BC%81%E6%B3%A8%E6%84%8F%EF%BC%9A%E6%88%91%E4%BB%AC%E7%9A%84PB10%E3%80%81PB11%E6%AD%A4%E6%97%B6%E5%B9%B6%E4%B8%8D%E6%98%AF%E4%B8%A4%E4%B8%AA%E6%99%AE%E9%80%9A%E7%9A%84GPIO%E8%80%8C%E6%98%AF%E5%A4%8D%E7%94%A8%E4%BD%9CIIC%E7%9A%84"><span class="toc-number">1.12.12.4.0.2.</span> <span class="toc-text">涉及到寄存器的配置！注意：我们的PB10、PB11此时并不是两个普通的GPIO而是复用作IIC的</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#IO%E8%BE%93%E5%87%BA%E3%80%82"><span class="toc-number">1.12.12.4.0.3.</span> <span class="toc-text">IO输出。 </span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E5%9C%A8I%C2%B2C%E9%80%9A%E4%BF%A1%E4%B8%AD%EF%BC%8C%E5%8F%91%E9%80%81%E5%AE%8C%E8%AE%BE%E5%A4%87%E5%9C%B0%E5%9D%80%E5%90%8E%E9%9C%80%E8%A6%81%E6%B8%85%E9%99%A4ADDR%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%9F"><span class="toc-number">1.12.12.4.0.4.</span> <span class="toc-text">2. 在I²C通信中，发送完设备地址后需要清除ADDR寄存器？ </span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B8%85%E9%99%A4ADDR%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E7%9B%AE%E7%9A%84%E6%98%AF%E4%B8%BA%E4%BA%86%E7%A1%AE%E4%BF%9D%E4%B8%8B%E4%B8%80%E6%AC%A1%E7%9A%84I%C2%B2C%E4%BC%A0%E8%BE%93%E6%88%96%E6%93%8D%E4%BD%9C%E4%B8%8D%E4%BC%9A%E5%8F%97%E5%88%B0%E4%B8%8A%E4%B8%80%E6%AC%A1%E7%9A%84%E5%9C%B0%E5%9D%80%E4%BF%A1%E6%81%AF%E7%9A%84%E5%B9%B2%E6%89%B0%E3%80%82"><span class="toc-number">1.12.12.4.0.5.</span> <span class="toc-text">清除ADDR寄存器的目的是为了确保下一次的I²C传输或操作不会受到上一次的地址信息的干扰。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E4%B8%8D%E6%B8%85%E9%99%A4ADDR%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%8C%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%AF%BC%E8%87%B4%E9%80%9A%E4%BF%A1%E9%94%99%E8%AF%AF%E6%88%96%E8%AE%BE%E5%A4%87%E4%B8%8D%E6%AD%A3%E7%A1%AE%E5%93%8D%E5%BA%94%E3%80%82"><span class="toc-number">1.12.12.4.0.6.</span> <span class="toc-text">如果不清除ADDR寄存器，可能会导致通信错误或设备不正确响应。 </span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%F0%9F%A5%96-1-I%C2%B2C%E5%9C%B0%E5%9D%80%E4%BC%A0%E8%BE%93%E9%98%B6%E6%AE%B5-%EF%BC%9A"><span class="toc-number">1.12.12.5.</span> <span class="toc-text">🥖^1. I²C地址传输阶段 ：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%97%A6-%E5%9C%A8I%C2%B2C%E9%80%9A%E4%BF%A1%E4%B8%AD%EF%BC%8C%E4%B8%BB%E8%AE%BE%E5%A4%87%EF%BC%88%E9%80%9A%E5%B8%B8%E6%98%AF%E5%BE%AE%E6%8E%A7%E5%88%B6%E5%99%A8%EF%BC%89%E9%9C%80%E8%A6%81%E5%90%91%E4%BB%8E%E8%AE%BE%E5%A4%87%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E6%88%96%E8%80%85%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%E3%80%82%E9%80%9A%E4%BF%A1"><span class="toc-number">1.12.13.</span> <span class="toc-text">◦ 在I²C通信中，主设备（通常是微控制器）需要向从设备发送数据或者请求数据。通信</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BC%80%E5%A7%8B%E6%97%B6%EF%BC%8C%E4%B8%BB%E8%AE%BE%E5%A4%87%E9%A6%96%E5%85%88%E5%8F%91%E9%80%81%E4%B8%80%E4%B8%AA%E8%AE%BE%E5%A4%87%E5%9C%B0%E5%9D%80%E5%92%8C%E8%AF%BB%E5%86%99%E4%BD%8D%EF%BC%88R-W%E4%BD%8D%EF%BC%89%E7%BB%99%E6%80%BB%E7%BA%BF%E4%B8%8A%E7%9A%84%E6%89%80%E6%9C%89%E8%AE%BE%E5%A4%87%E3%80%82"><span class="toc-number">1.12.13.0.0.1.</span> <span class="toc-text">开始时，主设备首先发送一个设备地址和读写位（R&#x2F;W位）给总线上的所有设备。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-ADDR%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8-%EF%BC%9A"><span class="toc-number">1.12.13.0.0.2.</span> <span class="toc-text">2. ADDR寄存器的作用 ：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%97%A6-ADDR%E5%AF%84%E5%AD%98%E5%99%A8%E7%94%A8%E4%BA%8E%E5%AD%98%E5%82%A8%E8%A6%81%E5%8F%91%E9%80%81%E7%9A%84%E8%AE%BE%E5%A4%87%E5%9C%B0%E5%9D%80%E5%92%8C%E8%AF%BB%E5%86%99%E4%BD%8D%E3%80%82%E5%BD%93%E4%B8%BB%E8%AE%BE%E5%A4%87%E5%BC%80%E5%A7%8B%E4%BC%A0%E8%BE%93%E8%AE%BE%E5%A4%87%E5%9C%B0%E5%9D%80%E5%90%8E%EF%BC%8C%E8%BF%99"><span class="toc-number">1.12.14.</span> <span class="toc-text">◦ ADDR寄存器用于存储要发送的设备地址和读写位。当主设备开始传输设备地址后，这</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BA%9B%E4%BF%A1%E6%81%AF%E4%BC%9A%E8%A2%AB%E5%8A%A0%E8%BD%BD%E5%88%B0ADDR%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD%E3%80%82"><span class="toc-number">1.12.14.0.0.1.</span> <span class="toc-text">些信息会被加载到ADDR寄存器中。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-ADDR%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E6%B8%85%E9%99%A4-%EF%BC%9A"><span class="toc-number">1.12.14.0.0.2.</span> <span class="toc-text">3. ADDR寄存器的清除 ：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%97%A6-%E5%9C%A8I%C2%B2C%E9%80%9A%E4%BF%A1%E4%B8%AD%EF%BC%8C%E4%B8%BB%E8%AE%BE%E5%A4%87%E5%8F%91%E9%80%81%E5%AE%8C%E8%AE%BE%E5%A4%87%E5%9C%B0%E5%9D%80%E5%90%8E%EF%BC%8C%E9%80%9A%E5%B8%B8%E9%9C%80%E8%A6%81%E8%BD%AF%E4%BB%B6%E6%9D%A5%E6%B8%85%E9%99%A4ADDR%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80"><span class="toc-number">1.12.15.</span> <span class="toc-text">◦ 在I²C通信中，主设备发送完设备地址后，通常需要软件来清除ADDR寄存器中的地址</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BF%A1%E6%81%AF%E3%80%82%E8%BF%99%E6%98%AF%E5%9B%A0%E4%B8%BAI%C2%B2C%E6%8E%A7%E5%88%B6%E5%99%A8%E9%80%9A%E5%B8%B8%E4%B8%8D%E4%BC%9A%E8%87%AA%E5%8A%A8%E6%B8%85%E9%99%A4ADDR%E5%AF%84%E5%AD%98%E5%99%A8%E7%9A%84%E5%86%85%E5%AE%B9%E3%80%82"><span class="toc-number">1.12.15.0.0.1.</span> <span class="toc-text">信息。这是因为I²C控制器通常不会自动清除ADDR寄存器的内容。 </span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-%E8%BD%AF%E4%BB%B6%E6%93%8D%E4%BD%9C-%EF%BC%9A"><span class="toc-number">1.12.15.0.0.2.</span> <span class="toc-text">4. 软件操作 ：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%97%A6-%E5%9C%A8%E5%A4%A7%E5%A4%9A%E6%95%B0%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E8%BD%AF%E4%BB%B6%E9%9C%80%E8%A6%81%E5%9C%A8%E5%8F%91%E9%80%81%E8%AE%BE%E5%A4%87%E5%9C%B0%E5%9D%80%E5%90%8E%E6%98%BE%E5%BC%8F%E5%9C%B0%E6%B8%85%E9%99%A4ADDR%E5%AF%84%E5%AD%98%E5%99%A8%E3%80%82%E8%BF%99%E9%80%9A%E5%B8%B8%E9%80%9A%E8%BF%87%E5%86%99"><span class="toc-number">1.12.16.</span> <span class="toc-text">◦ 在大多数情况下，软件需要在发送设备地址后显式地清除ADDR寄存器。这通常通过写</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%A5%E7%89%B9%E5%AE%9A%E7%9A%84%E6%8E%A7%E5%88%B6%E4%BD%8D%E6%88%96%E5%AF%84%E5%AD%98%E5%99%A8%E6%9D%A5%E5%AE%8C%E6%88%90%EF%BC%8C%E5%85%B7%E4%BD%93%E7%9A%84%E6%93%8D%E4%BD%9C%E5%8F%96%E5%86%B3%E4%BA%8E%E4%BD%BF%E7%94%A8%E7%9A%84I%C2%B2C%E6%8E%A7%E5%88%B6%E5%99%A8%E5%92%8C%E5%BE%AE%E6%8E%A7%E5%88%B6%E5%99%A8%E3%80%82"><span class="toc-number">1.12.16.0.0.1.</span> <span class="toc-text">入特定的控制位或寄存器来完成，具体的操作取决于使用的I²C控制器和微控制器。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5-%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%BE%8B%E5%A4%96-%EF%BC%9A"><span class="toc-number">1.12.16.0.0.2.</span> <span class="toc-text">5. 硬件实现的例外 ：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%97%A6-%E5%B0%BD%E7%AE%A1%E5%A4%A7%E5%A4%9A%E6%95%B0%E6%83%85%E5%86%B5%E4%B8%8B%E9%9C%80%E8%A6%81%E8%BD%AF%E4%BB%B6%E6%93%8D%E4%BD%9C%E6%9D%A5%E6%B8%85%E9%99%A4ADDR%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%8C%E6%9C%89%E4%BA%9B%E7%89%B9%E5%AE%9A%E7%9A%84I%C2%B2C%E6%8E%A7%E5%88%B6%E5%99%A8%E5%92%8C%E5%BE%AE%E6%8E%A7%E5%88%B6"><span class="toc-number">1.12.17.</span> <span class="toc-text">◦ 尽管大多数情况下需要软件操作来清除ADDR寄存器，有些特定的I²C控制器和微控制</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%99%A8%E5%8F%AF%E8%83%BD%E6%8F%90%E4%BE%9B%E4%BA%86%E8%87%AA%E5%8A%A8%E6%B8%85%E9%99%A4%E7%9A%84%E5%8A%9F%E8%83%BD%EF%BC%8C%E4%BD%86%E8%BF%99%E5%B9%B6%E4%B8%8D%E6%98%AF%E9%80%9A%E7%94%A8%E6%83%85%E5%86%B5%E3%80%82"><span class="toc-number">1.12.17.0.0.1.</span> <span class="toc-text">器可能提供了自动清除的功能，但这并不是通用情况。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%EF%BC%88HAL%E5%BA%93%EF%BC%89-2"><span class="toc-number">1.12.17.1.</span> <span class="toc-text">5. 软件设计（HAL库）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-STM32CubeMx%E4%B8%AD%E9%85%8D%E7%BD%AE"><span class="toc-number">1.12.17.1.1.</span> <span class="toc-text">5.1 STM32CubeMx中配置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-main-c"><span class="toc-number">1.12.17.1.2.</span> <span class="toc-text">5.2 main.c</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-3-Inf-W24C02-h"><span class="toc-number">1.12.17.1.3.</span> <span class="toc-text">5.3 Inf_W24C02.h</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-Inf-W24C02-c"><span class="toc-number">1.12.17.1.4.</span> <span class="toc-text">5.4 Inf_W24C02.c</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://source.fomal.cc/img/default_cover_3.webp')"><div id="footer-wrap"><div class="copyright">&copy;2024 By Chilli</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><script defer src="/js/cursor.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="30" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://ts1.cn.mm.bing.net/th/id/R-C.06ac7d7e5f4f81229e8c7eaf79bd0fef?rik=6dPa67mO8Xo88g&amp;riu=http%3a%2f%2fwww.faceui.com%2fapps%2fupload%2fimage%2f20200113%2f1578920626569170.jpg&amp;ehk=r2TM6AGvXY%2biZcXlEyyueiblv5fcSgYkC%2f2YJiGP3bE%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0);"> <a class="categoryBar-list-link" href="categories/嵌入式/">嵌入式</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">嵌入式</span></li><li class="categoryBar-list-item" style="background:url(https://assets.akilar.top/image/cover2.webp);"> <a class="categoryBar-list-link" href="categories/蓝桥杯32/">蓝桥杯32</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">杂谈</span></li><li class="categoryBar-list-item" style="background:url(https://img-blog.csdnimg.cn/20200403105223468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzE1MTcx,size_16,color_FFFFFF,t_70);"> <a class="categoryBar-list-link" href="categories/蓝桥杯51/">蓝桥杯51</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">蓝桥杯51</span></li><li class="categoryBar-list-item" style="background:url(https://img-blog.csdnimg.cn/194297a5d3f0433cadb188c17459bfcf.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARXBpcGhhbnnmmpbpo44=,size_17,color_FFFFFF,t_70,g_se,x_16);"> <a class="categoryBar-list-link" href="categories/杂谈/">杂谈</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">蓝桥杯32</span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v6.2.0" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.3.1" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" data-title="本站采用多线部署，主线路托管于Vercel" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Vercel-brightgreen?style=flat&amp;logo=Vercel" alt=""/></a><a class="github-badge" target="_blank" href="https://dashboard.4everland.org/" style="margin-inline:5px" data-title="本站采用多线部署，备用线路托管于4EVERLAND" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-4EVERLAND-22DDDD?style=flat&amp;logo=IPFS" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="https://www.fomal.cc/static/js/runtime.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '1s');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '2');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --></body></html>