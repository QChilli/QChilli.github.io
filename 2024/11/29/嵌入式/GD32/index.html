<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>GD32 | Blog</title><meta name="author" content="Chilli"><meta name="copyright" content="Chilli"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="GPIO1.GPIO硬件结构 GPIO 是指芯片的通用输入输出管脚。  可将 GPIO 配置为输出模式，控制点亮发光二极管（LED）。也可作为输出控制打开或关闭继电器，配置为输入模式来检测外部按键，甚至配置为模拟输入模式来检测热敏电阻，以获取温度数据。 因此，GPIO 既可以作为普通的 IO 口，也可以作为模拟输入，甚至作为 I²C、SPI、串口的管脚。 单片机工作示意框图：  单片机内部主要包括">
<meta property="og:type" content="article">
<meta property="og:title" content="GD32">
<meta property="og:url" content="https://qchilli.github.io/2024/11/29/%E5%B5%8C%E5%85%A5%E5%BC%8F/GD32/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:description" content="GPIO1.GPIO硬件结构 GPIO 是指芯片的通用输入输出管脚。  可将 GPIO 配置为输出模式，控制点亮发光二极管（LED）。也可作为输出控制打开或关闭继电器，配置为输入模式来检测外部按键，甚至配置为模拟输入模式来检测热敏电阻，以获取温度数据。 因此，GPIO 既可以作为普通的 IO 口，也可以作为模拟输入，甚至作为 I²C、SPI、串口的管脚。 单片机工作示意框图：  单片机内部主要包括">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://source.fomal.cc/img/default_cover_5.webp">
<meta property="article:published_time" content="2024-11-29T12:45:56.000Z">
<meta property="article:modified_time" content="2025-01-19T03:28:19.967Z">
<meta property="article:author" content="Chilli">
<meta property="article:tag" content="GD32">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://source.fomal.cc/img/default_cover_5.webp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://qchilli.github.io/2024/11/29/%E5%B5%8C%E5%85%A5%E5%BC%8F/GD32/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Chilli","link":"链接: ","source":"来源: Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-right"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'GD32',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2025-01-19 11:28:19'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/universe.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://www.fomal.cc/static/css/runtime.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw icon--article"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw icon-guidang1"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw icon-sekuaibiaoqian"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw icon-fenlei"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://source.fomal.cc/img/default_cover_5.webp')"><nav id="nav"><span id="blog-info"><a href="/" title="Blog"><span class="site-name">Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw icon--article"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw icon-guidang1"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw icon-sekuaibiaoqian"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw icon-fenlei"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">GD32</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-29T12:45:56.000Z" title="发表于 2024-11-29 20:45:56">2024-11-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-01-19T03:28:19.967Z" title="更新于 2025-01-19 11:28:19">2025-01-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">33.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>117分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="GD32"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h1><h2 id="1-GPIO硬件结构"><a href="#1-GPIO硬件结构" class="headerlink" title="1.GPIO硬件结构"></a>1.GPIO硬件结构</h2><blockquote>
<p>GPIO 是指芯片的通用输入输出管脚。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501191128046.png" alt></p>
<p>可将 GPIO 配置为输出模式，控制点亮发光二极管（LED）。也可作为输出控制打开或关闭继电器，配置为输入模式来检测外部按键，甚至配置为模拟输入模式来检测热敏电阻，以获取温度数据。</p>
<p>因此，GPIO 既可以作为普通的 IO 口，也可以作为模拟输入，甚至作为 I²C、SPI、串口的管脚。</p>
<p>单片机工作示意框图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501182330703.png" alt></p>
<p>单片机内部主要包括 CPU、Flash 存储器、RAM 内存和片上的外设。我们可以简单地将工作过程划分为四个步骤：</p>
<ul>
<li>单片机上电后，CPU 从 Flash 中读取并响应代码指令。</li>
<li>根据指令，从片上的外设（例如光照强度传感器）获取数据。这些数据需要先保存在 RAM 内存中，然后进行进一步的数据处理。</li>
<li>经过加减乘除的运算，根据运算结果控制片上的外设（GPIO）来点亮或熄灭 LED 灯。</li>
<li>CPU 负责执行和响应代码指令，进行数学运算，往 RAM 内存里读写数据；Flash 存储器（ ROM 的一种实现方式）负责保存代码指令；RAM 内存负责在程序运行过程中保存变量数据；而片上外设则用来控制单片机外部的器件。</li>
</ul>
<p>GPIO，CPU 是基于总线来进行工作：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501182340597.png" alt="-17328844853232"></p>
<p>总线可以理解为高速公路，CPU 通过它与片上外设通信。外设内部会有寄存器，CPU 可以向寄存器写入或读取数据，从而控制片上外设的状态。根据寄存器中的数据，GPIO 会相应地输出高低电平。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501182341051.png" alt="-17328844853233"></p>
<p>一个 GPIO 口的内部硬件结构可以分为两部分：上半部分对应输出，下半部分对应输入。</p>
<p>输出可以配置为四种模式：</p>
<ul>
<li>推挽输出</li>
<li>开漏输出</li>
<li>推挽复用输出</li>
<li>开漏复用输出</li>
</ul>
<p>输入可以配置为四种模式：</p>
<ul>
<li>模拟输入</li>
<li>浮空输入</li>
<li>上拉输入</li>
<li>下拉输入</li>
</ul>
</blockquote>
<h2 id="2-GPIO输出模式"><a href="#2-GPIO输出模式" class="headerlink" title="2.GPIO输出模式"></a>2.GPIO输出模式</h2><h3 id="1-输出结构分析"><a href="#1-输出结构分析" class="headerlink" title="1.输出结构分析"></a>1.输出结构分析</h3><blockquote>
<p>在这个框架内，可以控制输出高低电平。数据来源有两种：<strong>普通的 GPIO 寄存器数据或备用功能寄存器的数据</strong>（即复用功能，例如 I²C、SPI 等）。</p>
<p>推挽输出和推挽复用输出的输出控制部分相同，只是数据来源可能不同。经过输出控制后，会有一个取反的效果后面是两个 MOSFET 管，上面是 PMOS 管，下面是 NMOS 管。这两个 MOSFET 组成的电路就是推挽输出电路。</p>
<h4 id="推挽输出电路"><a href="#推挽输出电路" class="headerlink" title="推挽输出电路"></a>推挽输出电路</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501182341913.png" alt="-17328844853234"></p>
<p>假设寄存器的数据输出高电平（1），经过取反后变为低电平（0）。此时，PMOS 管导通，连接到 VCC，NMOS 管截止。这样输出的就是高电平。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501182341597.png" alt="-17328844853235"></p>
<p>假设寄存器的数据是低电平（0），取反后为高电平（1），此时 PMOS 管截止，NMOS 管导通，电流流向地（GND），输出的就是低电平。</p>
<h4 id="LED-驱动分析"><a href="#LED-驱动分析" class="headerlink" title="LED 驱动分析"></a>LED 驱动分析</h4><p>对于发光二极管（LED）的电路设计，负极连接到 GPIO，正极连接到 VCC，并经过一个限流电阻。假设寄存器输出高电平（1），经过取反后为低电平（0），PMOS 管导通，输出为高电平，LED 灯不亮。假设寄存器输出低电平（0），经过取反后为高电平（1），此时 NMOS 管导通，电流从 Vcc 流向地，LED 灯被点亮。此时电流是由外部流向单片机的内部，再到 GND 。</p>
<p>对于 ARM 32 位单片机，GPIO 能够输出的最大电流为 25 毫安，因此驱动发光二极管是绰绰有余的。一般发光二极管需要的电流约为 5 毫安左右。需要注意的是，并不是所有 GPIO 口都能输出 25 毫安电流，因为单片机本身也需要考虑功耗。对于单片机来说，整体的输出电流一般在 200 毫安左右。</p>
</blockquote>
<h3 id="2-开漏输出分析"><a href="#2-开漏输出分析" class="headerlink" title="2.开漏输出分析"></a>2.开漏输出分析</h3><blockquote>
<p>开漏输出的电路设计与推挽输出不同。在开漏输出中，去掉了上面的 PMOS 管，只留下 NMOS 管。这种设计称为开漏输出。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501182345744.png" alt="-17328844853236"></p>
<p>当寄存器输出为高电平（1），取反后为低电平（0），此时 NMOS 管截止，状态为高阻（Hi-Z），LED 灯熄灭。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501182346077.png" alt="-17328844853237"></p>
<p>当寄存器输出低电平（0），经过取反后为高电平（1），NMOS 导通，电流从 Vcc 流过，LED 灯被点亮。</p>
<p>因此，开漏输出的特点是只能提供低电平，而不能提供高电平。</p>
<h4 id="开漏输出的优点"><a href="#开漏输出的优点" class="headerlink" title="开漏输出的优点"></a>开漏输出的优点</h4><p>由开漏输出的特点可知，要提供高电平，必须在单片机的外部增加一个上拉电阻。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501182346951.png" alt="-17328844853238"></p>
<p>开漏输出的主要优点在于可以实现电平转换和线与功能。我们先来分析电平转换的过程：</p>
<p>假设负载需要 5V 供电，而单片机系统为 3.3V。在这种情况下，可以将 Vcc 直接连接到 5V。如果单片机输出高电平（1），变为低电平（0），此时 NMOS 管截止，Vcc 的电流通过上拉电阻拉高，输出为高电平。</p>
<h4 id="线与功能分析"><a href="#线与功能分析" class="headerlink" title="线与功能分析"></a>线与功能分析</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501182347799.png" alt="-17328844853239"></p>
<p>对于 I²C 协议，可以挂载多个 I²C 设备，如 EEPROM、触摸屏驱动芯片等。I²C 总线要求实现线与功能。根据逻辑，同一线上只要有一个设备输出低电平，整个总线电平就会变为低。</p>
<p><strong>推挽输出的结构无法实现线与功能，因其可能造成短路。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501182347796.png" alt="-173288448532310"></p>
<p><strong>相反，开漏输出可以实现线与功能。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501182347805.png" alt="-173288448532311"></p>
<p>假设单片机输出高电平（1），经过取反后变为低电平，NMOS 管截止，此时总线电平为高电平（1）。如果任何一个设备输出低电平（0），NMOS 管导通，电流流入地，整个总线电平则变为低电平（0）。</p>
</blockquote>
<h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h3><p>刚才分析了输出模式下开漏输出和推挽输出的硬件结构。还回顾了 CPU 如何通过寄存器控制片上的外设。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501182352964.png" alt="-173288448532312"></p>
<p>这是寄存器的地址范围，以及 ARM 32 位单片机（如 STM32、GD32）的片上外设寄存器的基本信息。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501182348454.png" alt="-173288448532313"></p>
<p>对于 GPIO，有配置寄存器、数据寄存器和复用寄存器。配置寄存器用于设置 GPIO 口为输入或输出模式，数据寄存器用于在输入模式下获取电平，在输出模式下控制电平。</p>
<h2 id="3-GPIO输入模式"><a href="#3-GPIO输入模式" class="headerlink" title="3.GPIO输入模式"></a>3.GPIO输入模式</h2><p>在本节中，主要涉及 GPIO 外设的4种输入模式，包括：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501182349584.png" alt="-173288448532315"></p>
<ul>
<li>模拟输入</li>
<li>浮空输入</li>
<li>下拉输入</li>
<li>上拉输入</li>
</ul>
<p>模拟输入是将外部的模拟信号通过 ADC 转换为数字量。</p>
<blockquote>
<h3 id="输入模式功能"><a href="#输入模式功能" class="headerlink" title="输入模式功能"></a>输入模式功能</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501182349542.png" alt="-173288448532316"></p>
<p>这三种输入模式可以将外部的数字信号转换为数字量 0 和 1。在输入驱动单元中包含上拉电阻、下拉电阻和施密特触发器。其中，施密特触发器用于将外部的数字信号转换为 0 和 1。</p>
<p>转换后的信号有两个输出方向：</p>
<ul>
<li>可以输出给复用功能，比如串口的 RX 引脚。</li>
<li>可以输出给普通 GPIO 口的输入状态寄存器，通过读取寄存器中的数据来获取高低电平状态。</li>
</ul>
<p>对于 ARM Cortex-M3 单片机，在转换过程中有以下特性：</p>
<ul>
<li>当外部信号电压大于等于 0.7 倍 VDD 时，认为是高电平（逻辑 1）。</li>
<li>当外部信号电压小于等于 0.3 倍 VDD 时，认为是低电平（逻辑 0）。</li>
</ul>
<h4 id="浮空输入模式"><a href="#浮空输入模式" class="headerlink" title="浮空输入模式"></a>浮空输入模式</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/11/29/%E5%B5%8C%E5%85%A5%E5%BC%8F/GD32/Users/Administrator/Desktop/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/-173288448532317.png" alt="-173288448532317"></p>
<p>浮空输入模式下，输入驱动单元中的上拉电阻和下拉电阻是关闭的（没有使能），此时端口在单片机内部呈现为高阻态。这种模式的应用场景，比如 GPIO 作为单片机串口的 RX 引脚时，就需要配置为浮空输入模式，外部连接其他器件的 TX 引脚。这样，端口的电平状态完全取决于外部器件的 TX 引脚。</p>
<p>问题分析： </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501182353305.png" alt="-173288448532318"></p>
<p>如果使用浮空输入模式来检测一个按键，假设按键的一端连接到 IO 口，另一端连接到地。当按键按下时，端口被拉低，通过施密特触发器转换为数字量 0，输入状态寄存器通过读取寄存器数据判断为低电平，进而执行业务逻辑，这部分没有问题。但是当按键没有被按下时，端口是悬空的，此时电平状态不确定，可能因为外部干扰而被误判为低电平，从而错误地执行业务逻辑。</p>
<h4 id="上拉输入模式"><a href="#上拉输入模式" class="headerlink" title="上拉输入模式"></a>上拉输入模式</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501182354019.png" alt="-173288448532319"></p>
<p>针对上述问题，可以采用上拉输入模式，将输入驱动单元的上拉电阻打开，使能。当按键没有按下时，端口通过上拉电阻被拉为高电平，这样可以避免浮空输入模式下电平不确定的问题。</p>
<h4 id="下拉输入模式"><a href="#下拉输入模式" class="headerlink" title="下拉输入模式"></a>下拉输入模式</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501182359434.png" alt="-173288448532320"></p>
<p>另外一种按键驱动电路是按键连接到限流电阻，再连接到 VCC。对于这种电路，需使用下拉输入模式，也就是打开驱动单元中的下拉电阻，使能。当按键没有按下时，端口通过下拉电阻被拉到低电平；当按键按下时，电流从外部流入单片机内部，端口电平被拉高。</p>
<p>上拉<strong>（pull-up）</strong>和下拉<strong>（pull-down）</strong>电阻是电子电路中常用的元件，用于确保数字输入信号的稳定状态，其主要功能是防止输入端悬空<strong>（floating）</strong>，从而避免误判输入状态。</p>
</blockquote>
<h2 id="4-上下拉电阻选取"><a href="#4-上下拉电阻选取" class="headerlink" title="4.上下拉电阻选取"></a>4.上下拉电阻选取</h2><blockquote>
<h3 id="使用上拉电阻的情况"><a href="#使用上拉电阻的情况" class="headerlink" title="使用上拉电阻的情况"></a>使用上拉电阻的情况</h3><p><strong>上拉电阻</strong>连接在输入端和正电源之间。当输入端没有信号时，电阻会将输入状态拉高到逻辑高（通常是接近电源电压，例如5V或3.3V）。这在以下情况中很有用：</p>
<ul>
<li><strong>开关或按钮输入</strong>：当按钮未被按下时，输入状态为高电平。当按钮被按下时，输入状态被直接连接到地，变为低电平。</li>
<li><strong>防止悬空状态</strong>：在没有其他信号源时，上拉电阻确保输入端始终有一个已定义的高电平状态。</li>
<li><strong>开漏输出</strong>：在使用开漏（open-drain）输出的设备中，需要通过上拉电阻将信号拉高。</li>
</ul>
<h3 id="使用下拉电阻的情况"><a href="#使用下拉电阻的情况" class="headerlink" title="使用下拉电阻的情况"></a>使用下拉电阻的情况</h3><p><strong>下拉电阻</strong>则连接在输入端和地（GND）之间。当输入端没有信号时，电阻会将输入状态拉低到逻辑低（通常是0V）。这在以下情况中很有用：</p>
<ul>
<li><strong>开关或按钮输入</strong>：当按钮未被按下时，输入状态为低电平。当按钮被按下时，输入状态被直接连接到电源，变为高电平。</li>
<li><strong>防止悬空状态</strong>：在没有其他信号源时，下拉电阻确保输入端始终有一个已定义的低电平状态。</li>
<li><strong>反相输入</strong>：当输入信号需要反转时，使用下拉电阻可使高电平输入对应低电平输出。</li>
</ul>
<h3 id="考虑因素"><a href="#考虑因素" class="headerlink" title="考虑因素"></a>考虑因素</h3><ul>
<li><strong>电路要求</strong>：根据电路设计的需求选择上拉或下拉电阻。例如，如果设备默认应处于高电平状态，则选择上拉电阻。</li>
<li><strong>电源电压</strong>：确保电阻的值和电源电压相匹配，以避免电流过大或过小。</li>
<li><strong>信号干扰</strong>：根据电磁干扰（EMI）的潜在影响选择合适的电阻值，以增强信号的稳定性。</li>
</ul>
<h3 id="单片机内部的上拉和下拉电阻，典型值为-40kΩ，而限流电阻通常选择-1kΩ。"><a href="#单片机内部的上拉和下拉电阻，典型值为-40kΩ，而限流电阻通常选择-1kΩ。" class="headerlink" title="单片机内部的上拉和下拉电阻，典型值为 40kΩ，而限流电阻通常选择 1kΩ。"></a>单片机内部的上拉和下拉电阻，典型值为 40kΩ，而限流电阻通常选择 1kΩ。</h3><h4 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h4><p>在实际应用中，上拉输入和下拉输入模式的使用频率相对较低，更多时候使用浮空输入模式。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501182354524.png" alt="-173288448532321"></p>
<p>采用浮空输入检测按键，需要在单片机外部额外加上上拉或下拉电阻，以确保在悬空时有明确的电平状态。通常，上拉电阻选择 2kΩ 到 10kΩ 之间。例如，开发板上使用浮空输入模式并在外部加上了上拉电阻来稳定电平。此外，有时在端口处串联一个限流电阻来保护端口。</p>
</blockquote>
<h2 id="5-GPIO输出速度"><a href="#5-GPIO输出速度" class="headerlink" title="5.GPIO输出速度"></a>5.GPIO输出速度</h2><blockquote>
<p>请大家回想一下，在配置寄存器时，我们需要设置输出速度，例如10MHz、2MHz或50MHz。</p>
<p>输出速度具体指的是什么？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501182355812.png" alt="-173288448532322"></p>
<p>它指的是GPIO口高低电平变化翻转的频率。</p>
<p>如果用<code>t</code>来表示周期，那么<code>f = 1/t</code>。假设我们将输出速度设置为10MHz，那么周期<code>t</code>就等于：十的九次方除以10M，也就是十的七次方纳秒，即100纳秒。</p>
<p>设置不同的输出速度会对单片机的GPIO硬件产生什么影响呢？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501182355364.png" alt="-173288448532323"></p>
<p>理想情况下，单片机输出高低电平应该是一个方波，但实际上这个过程是有上升时间（<code>tr</code>）和下降时间（<code>tf</code>）过程的。在单片机的手册中明确说明了，为了保证输出有效的高低电平，<code>tr + tf</code>必须小于等于周期<code>t</code>的三分之二。</p>
<ul>
<li>如果我们设置输出速度为10MHz，那么周期<code>t</code>是100纳秒，则：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tr + tf&lt; <span class="number">2</span> * t / <span class="number">3</span> = <span class="number">67</span></span><br></pre></td></tr></table></figure>
<p>所以，<code>tr</code>和<code>tf</code>的总和需要小于67纳秒，通常每个时间段大约是33-34纳秒。</p>
<ul>
<li>如果我们将GPIO口的输出速度设置为50MHz，那么周期<code>t</code>是20纳秒，则：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tr + tf&lt; <span class="number">2</span> * t / <span class="number">3</span> = <span class="number">13</span></span><br></pre></td></tr></table></figure>
<p>这样，<code>tr</code>和<code>tf</code>每个大约是6-7纳秒左右。因此，设置GPIO口的输出速度越高，<code>tr</code>和<code>tf</code>就要控制得越小，上升和下降的过程越陡峭。</p>
<p>那么，如何控制<code>tr</code>和<code>tf</code>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501182356110.png" alt="-173288448532324"></p>
<p>单片机的GPIO口输出信号去控制一个外设负载，这个负载可以等效为一个电容<code>CL</code>，因为电容会影响电压变化的速率。</p>
<p>输出高低电平的过程，其实就是对电容的充放电过程，我们可以用电容充电公式来表示：</p>
<p>其中，<code>dv/dt</code>表示电压变化的速率。因此，在负载电容值<code>CL</code>一定的情况下，电压变化速率越快，所需电流<code>I</code>越大，电流越大就会导致单片机的功耗增加。此外，输出频率越高，还会涉及到EMI（电磁干扰）的问题。</p>
<p>接下来，我们来看一下单片机数据手册中关于输出交流特性的内容。在这个表格中列出了输出速度为2MHz、10MHz和50MHz的相关参数。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501182356278.png" alt="-173288448532325"></p>
<ul>
<li>当输出速度为2MHz，且负载电容<code>Cl</code>为50pF时，通过输出一定电流，<code>tr</code>和<code>tf</code>可以控制在125纳秒以下。</li>
<li>当输出速度为10MHz，<code>Cl</code>同样为50pF时，通过输出一定电流，<code>tr</code>和<code>tf</code>可以控制在25纳秒以下。</li>
<li>当输出速度为50MHz，<code>Cl</code>为30pF时，<code>tr</code>和<code>tf</code>大约是5纳秒；而当<code>Cl</code>为50pF时，<code>tr</code>和<code>tf</code>大约是8纳秒。</li>
</ul>
<p>例如，如果我们要控制一个简单的发光二极管（LED），配置成2MHz的输出速度就足够了；但如果我们要驱动SD卡，则需要配置成50MHz的输出速度。</p>
<p>因此，在配置GPIO口输出速度时，我们应当遵循够用即可的原则。</p>
</blockquote>
<h1 id="CLOCKTREE"><a href="#CLOCKTREE" class="headerlink" title="CLOCKTREE"></a>CLOCKTREE</h1><p>时钟对于单片机来说就像是人的心脏，非常重要。它为单片机提供心跳节拍，CPU 根据时钟的跳动来执行代码指令。时钟频率越高，代码指令执行得越快，系统性能也越高；反之，时钟越慢，执行也越慢。</p>
<h2 id="1-系统硬件架构回顾"><a href="#1-系统硬件架构回顾" class="headerlink" title="1.系统硬件架构回顾"></a>1.系统硬件架构回顾</h2><p>首先，我们回顾一下 51 内核单片机的系统硬件架构。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190003993.png" alt="-173288448532426"></p>
<p>在单片机的内部，有很多组件，包括中央处理器 (CPU)、片上外设 (如 Flash、RAM、定时器、串口等)。CPU 通过总线访问这些片上外设。</p>
<p>对于 ARM 32 位单片机，其系统硬件架构比 51 单片机更复杂。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190003699.png" alt="-173288448532427"></p>
<p>ARM Cortex M4 内核中有三个总线接口，分别是 ICode 总线、DCode 总线和系统总线接口。ICode 总线接口用于连接并访问 Flash，以获取代码指令；DCode 总线接口连接并访问 Flash 获取数据；系统总线接口则用于连接并访问 RAM 和片上外设。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190003380.png" alt="-173288448532428"></p>
<p>在芯片的用户手册中，我们可以看到这些总线接口的描述。ICode 和 DCode 总线对应的分别是 IBus 和 DBus，它们从 Flash 中获取代码指令和数据。而系统总线接口对应的是 AHB 总线，用于连接访问片上外设，如 FMC、SDIO、CRC、RCU 等。</p>
<p>基于 AHB 总线，派生出两个 APB 总线：APB1 和 APB2。APB1 总线连接看门狗、定时器、串口、SPI 等外设，而 APB2 总线连接串口 0、SPI 0、ADC 等外设。</p>
<h2 id="2-时钟系统架构分析"><a href="#2-时钟系统架构分析" class="headerlink" title="2.时钟系统架构分析"></a>2.时钟系统架构分析</h2><p>时钟树简易框图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190004761.png" alt="-173288448532429"></p>
<ul>
<li>振荡器 (黄色)：内部有 3 个振荡器，外部有 2 个。</li>
<li>锁相环 (PLL)：对输入时钟进行倍频。</li>
<li>分频器 (绿色)：对输入时钟进行分频。</li>
<li>片上外设 (蓝色)：例如 USB、SDIO、FMC 等。</li>
</ul>
<h2 id="3-时钟系统的具体介绍"><a href="#3-时钟系统的具体介绍" class="headerlink" title="3.时钟系统的具体介绍"></a>3.时钟系统的具体介绍</h2><blockquote>
<p>时钟树框图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190004165.png" alt="-173288448532430"></p>
<ul>
<li><strong>系统时钟：</strong>对于 GD32F303 MCU，其主频最高为 120MHz，经过 AHB 分频器后，生成 AHB 时钟，供给 AHB 外设，如 EXMC、SDIO 等。</li>
<li><strong>APB 时钟：</strong>经过 APB1 分频器，生成 APB1 时钟，最大为 60MHz，供给 APB1 外设。类似地，APB2 时钟最大为 120MHz，供给 APB2 外设。</li>
<li><strong>USB 外设：</strong>USB 是一种高速串行接口，需要精确的时钟。其时钟来源可以是 PLL 输出的时钟，也可以是内部的 IRC 48MHz 振荡器，经过分频器生成固定的 48MHz 时钟，供给 USB 外设。</li>
<li><strong>PLL 锁相环：</strong>其输入时钟来源可以是内部的 IRC 8MHz 振荡器，也可以是外部的高速晶振。内部的 IRC 8MHz 振荡器精度较低，适用于一些简单的控制任务，而对通信有要求的应用通常使用外部晶振以提高精度。</li>
<li><strong>RTC 实时时钟：</strong>输入来源有 3 个：外部高速晶振（需分频）、外部低速晶振（32.768kHz）以及内部的 IRC 40kHz 振荡器。通常选择低速晶振，以降低功耗。内部的 40kHz 振荡器则用于独立看门狗提供时钟。</li>
</ul>
</blockquote>
<h2 id="4-基于内核DWT的延时"><a href="#4-基于内核DWT的延时" class="headerlink" title="4.基于内核DWT的延时"></a>4.基于内核DWT的延时</h2><h1 id="NVIC"><a href="#NVIC" class="headerlink" title="NVIC"></a>NVIC</h1><h2 id="1-中断系统硬件和软件结构"><a href="#1-中断系统硬件和软件结构" class="headerlink" title="1.中断系统硬件和软件结构"></a>1.中断系统硬件和软件结构</h2><h3 id="1-概念介绍"><a href="#1-概念介绍" class="headerlink" title="1.概念介绍"></a>1.概念介绍</h3><p>通过一个生活中的例子来理解中断。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190009507.png" alt="-173288448532431"></p>
<blockquote>
<p>假设我正在看书，突然有人敲门，那么我需要放下书去开门查看情况，处理完后再回到座位继续看书。过一会儿，水烧开了，我又需要放下书去关火、倒水。在这个过程中，敲门声和水开了的提示都会打断我正在执行的任务（看书），去处理更紧急、更高优先级的事情（开门、关火倒水）。</p>
<p>如果将这个过程类比到单片机的中断系统：</p>
<ul>
<li>看书是单片机系统执行的主流程任务。</li>
<li>敲门声、水开了是中断触发源。</li>
<li>开门、关火倒水是中断服务函数。</li>
<li>中断处理之所以发生，是因为这些事件的优先级比当前任务（看书）更高。</li>
</ul>
<p>在我们的头脑中，听到敲门声或水烧开的声音时，我们已经定义好要去执行的动作。同样地，在单片机系统中，通过内核的 NVIC（嵌套向量中断控制器）来实现不同中断源对应不同的中断服务函数。</p>
</blockquote>
<h3 id="2-ARM-单片机中的中断"><a href="#2-ARM-单片机中的中断" class="headerlink" title="2.ARM 单片机中的中断"></a>2.ARM 单片机中的中断</h3><p><strong>在 ARM 单片机中，中断的统称是异常，而中断只是异常的一个子集。</strong>异常包括：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190010567.png" alt="-173288448532432"></p>
<ul>
<li>系统异常：由内核产生，比如系统复位异常、总线访问异常、硬错误异常、SysTick（滴答定时器）异常等。</li>
<li>中断：由片上外设产生，比如串口中断、定时器中断、ADC 中断、GPIO 引脚对应的 EXTI 外部中断等。</li>
</ul>
<h4 id="1-ARM-单片机的异常触发源"><a href="#1-ARM-单片机的异常触发源" class="headerlink" title="1.ARM 单片机的异常触发源"></a>1.ARM 单片机的异常触发源</h4><blockquote>
<p>ARM 单片机中一共有 200 多个异常触发源，包括：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190010635.png" alt="-173288448532433"></p>
<ul>
<li>系统复位异常：比如手动复位或掉电都会触发系统复位异常。</li>
<li>硬件故障异常（HardFault）：比如代码中存在除数为零的错误就会触发硬错误异常。</li>
<li>总线访问异常：例如访问内存时没有按 4 字节对齐，就会触发总线访问异常。</li>
<li>SysTick 异常：滴答定时器的异常。</li>
<li>外设中断：比如 ADC、串口、定时器、EXTI 等。</li>
</ul>
<p>这些异常在 ARM 单片机中都有对应的编号，例如：</p>
<ul>
<li>编号 1 对应的是系统复位异常，这是硬件设定好的，无法改变。</li>
<li>编号 5 对应的是总线访问异常。</li>
<li>编号 15 对应的是滴答定时器异常。</li>
</ul>
</blockquote>
<h4 id="2-异常的存储空间分配"><a href="#2-异常的存储空间分配" class="headerlink" title="2.异常的存储空间分配"></a>2.异常的存储空间分配</h4><blockquote>
<p>这些异常触发源在 Flash 中需要分配存储空间，每个触发源对应 4 个字节的存储空间。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190010313.png" alt="-173288448532434"></p>
<p>例如：</p>
<ul>
<li>系统复位异常的存储空间是 0x04 到 0x07。</li>
<li>NMI（非屏蔽中断）的存储空间是 0x08 到 0x0B。</li>
<li>SysTick 的存储空间是 0x3C 到 0x3F。</li>
</ul>
<p>这些地址与编号的对应关系是：向量编号乘以 4。</p>
<p>例如：</p>
<ul>
<li>系统复位异常的编号是 1，它的起始地址就是 1 × 4 = 0x04。</li>
<li>SysTick 的编号是 15，起始地址是 15 × 4 = 0x3C。</li>
</ul>
<p>有的同学可能注意到这些地址数据与我们在 Keil 工程中看到的 Flash 存储空间地址（从 0x08000000 起始）不一致。实际上，这涉及到 ARM 单片机的存储器映射机制。</p>
<p>存储器映射将 Flash 的地址空间从 0x00000000 映射到 0x08000000，目的是实现 ARM 单片机的几种启动模式：从 Flash 启动、从 RAM 启动、以及从预置的 Bootloader 启动。不同的启动模式下地址映射不同，这一点我们会在后续课程中详细讲解。</p>
</blockquote>
<h4 id="3-中断执行流程"><a href="#3-中断执行流程" class="headerlink" title="3.中断执行流程"></a>3.中断执行流程</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190010261.png" alt="-173288448532435"></p>
<ul>
<li>当我们手动复位或单片机掉电，会触发系统复位异常。</li>
<li>NVIC 首先通过系统复位异常的编号（1），计算出其对应的存储空间（0x04 到 0x07），然后从该存储空间中获取中断服务函数的地址，最终调用该中断服务函数。</li>
</ul>
<blockquote>
<p>在启动汇编文件 <code>startup.s</code> 中，<code>_vectors</code> 到 <code>vectors_end</code> 这段代码称为中断向量表，主要有两个作用：</p>
<ul>
<li>给中断触发源分配 Flash 存储空间（每个 4 字节，通过汇编指令 DCD 实现）。</li>
<li>关联中断服务函数的名称，例如 <code>Reset_Handler</code>。</li>
</ul>
<p><code>Reset_Handler</code> 是我们之前见过的函数，它会调用 <code>SystemInit</code> 函数进行时钟初始化，并调用 <code>_main</code> 函数，而 <code>_main</code> 会调用我们实现的 <code>main</code> 函数。通过这样的方式，中断服务函数 <code>Reset_Handler</code> 的地址会被保存在异常触发源对应的存储空间中。</p>
<p>我们可以打开编译生成的 <code>.map</code> 文件，其中包含了堆栈、函数等相关地址信息。例如，<code>_initial_sp</code> 表示栈顶地址，对分析内存问题非常有用。在该文件中可以找到 <code>Reset_Handler</code> 的地址为 <code>0x08000145</code>，并将其保存在 <code>0x00000004</code> 到 <code>0x00000007</code> 的地址空间中。</p>
<h4 id="中断服务函数实现"><a href="#中断服务函数实现" class="headerlink" title="中断服务函数实现"></a>中断服务函数实现</h4><p>除了 <code>Reset_Handler</code>，其他中断服务函数也有代码实现。例如：</p>
<ul>
<li>NMI_Handler 代码实现为 <code>b .</code>，对应 C 语言中的 <code>while(1)</code> 死循环。</li>
<li>HardFault_Handler 也是 <code>b .</code> 死循环。</li>
<li>总线访问错误中断服务函数同样是 <code>b .</code>。</li>
</ul>
<p>这些中断服务函数后面的 <code>__weak</code> 关键字表示：如果这些中断服务函数在其他代码文件中有定义实现，则优先使用那个定义；如果没有，则使用当前文件中的默认实现（即死循环 <code>b .</code>）。</p>
<p>因此，假设在初始化片上外设时忘记重新实现中断服务函数，导致中断触发时执行了默认的死循环 <code>b .</code>，造成程序卡死。</p>
</blockquote>
<h2 id="2-EXTI-中断系统"><a href="#2-EXTI-中断系统" class="headerlink" title="2.EXTI 中断系统"></a>2.EXTI 中断系统</h2><p>EXTI 可以用来检测 GPIO 口作为输入模式时的高低电平变化，进而触发上升沿或下降沿中断。</p>
<p>例如，我们可以利用它来检测按键按下的动作。当按键未按下时是高电平，按下时发生跳变为低电平，这是一个下降沿，可以触发 EXTI 中断。此外，在我们的开发板上还有一个环境传感器 AP3216C，它可以感知是否有物体靠近，当达到一定阈值时会从高电平跳变到低电平，这也是一个下降沿，同样可以产生 EXTI 中断。</p>
<blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190012522.png" alt="-173288448532436"></p>
<p>GPIO 口并不是直接连接到 NVIC 中断控制器的，而是通过 EXTI 控制器中转。EXTI 控制器和 NVIC 都包含了一些寄存器，用于控制中断触发和管理。</p>
</blockquote>
<h4 id="1-硬件连接结构"><a href="#1-硬件连接结构" class="headerlink" title="1.硬件连接结构"></a>1.硬件连接结构</h4><p>结构框图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190012593.png" alt="-173288448532437"></p>
<p>EXTI 控制器位于 GPIO 和 NVIC 之间。以 EXTI 线 0 为例，它可以连接到 PA0 到 PG0 中的任意一个 GPIO 口。在 EXTI 控制器中有一个选择器，用于选择哪个 GPIO 口连接到 EXTI 线。可以配置为上升沿、下降沿或上升沿和下降沿同时触发中断。</p>
<p>需要注意的是，同一时刻 EXTI 线只能连接一个 GPIO 口。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190012880.png" alt="-173288448532438"></p>
<p><strong>例如，如果配置 PA0 连接到 EXTI 线 0，随后再配置 PB0 连接到 EXTI 线 0，那么 PA0 的连接会失效。这一点在编写代码时可以进行验证。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190012231.png" alt="-173288448532439"></p>
<p>EXTI 线 9-5 和 15-10 的中断源与前面的 EXTI 线 0-4 不同，前者共用一个中断触发源和中断服务函数。</p>
<p>例如：</p>
<ul>
<li>EXTI 线 5 到 9 共用一个中断服务函数。</li>
<li>EXTI 线 10 到 15 共用一个中断服务函数。</li>
</ul>
<p>因此，它们的EXTI线可以同时连接中断触发源，都可以同时给触发，生成中断函数。</p>
<h4 id="2-中断优先级"><a href="#2-中断优先级" class="headerlink" title="2.中断优先级"></a>2.中断优先级</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190013120.png" alt="-173288448532440"></p>
<p>优先级主要应用在两个场景中：</p>
<ul>
<li>多个中断同时触发时，决定先处理哪个中断。 例如，我正在看书，同时听到敲门声和水烧开的声音，我需要决定是先去开门还是先关火。</li>
<li>中断抢占：当一个中断服务函数正在执行时，另一个中断到来，决定是否打断当前中断去处理新的中断。</li>
</ul>
<p>在 ARM 单片机中，通过配置 NVIC 控制器的寄存器来实现中断优先级控制。涉及的寄存器有两个：IP 和 AIRCR。</p>
<ul>
<li>IP 寄存器：每个中断源对应一个 8 位宽度的 IP 寄存器，但 GD32F303 单片机只使用高 4 位（Bit 4 到 Bit 7），数值范围是 0 到 15。</li>
<li>AIRCR 寄存器：用于配置优先级分组，一共有 5 组（0 到 4），通过配置 AIRCR 的第 8 到第 10 位实现。</li>
</ul>
<h4 id="3-优先级分组"><a href="#3-优先级分组" class="headerlink" title="3.优先级分组"></a>3.优先级分组</h4><p>在 ARM Cortex-M3/M4 权威指南的第 180 页有相关描述。优先级分组将 4 位优先级分成抢占优先级和子优先级两部分：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190013253.png" alt="-173288448532441"></p>
<ul>
<li>第 0 组：0 位用于抢占优先级，4 位用于子优先级。</li>
<li>第 4 组：4 位用于抢占优先级，0 位用于子优先级。</li>
</ul>
<p>这种机制的目的是为了灵活设置优先级，使得不同场景下的中断处理更为有效。</p>
<h4 id="4-中断执行顺序"><a href="#4-中断执行顺序" class="headerlink" title="4.中断执行顺序"></a>4.中断执行顺序</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190013513.png" alt="-173288448532442"></p>
<ul>
<li><p>如果两个中断同时发生，首先判断抢占优先级，数值越小优先级越高。如果抢占优先级相同，则判断子优先级，数值越小优先级越高。</p>
</li>
<li><p>如果一个中断正在执行，另一个中断到来，是否抢占取决于抢占优先级。</p>
</li>
<li>例如，如果中断 A 正在执行，中断 B 到来，B 的抢占优先级高（数值小于）于 A，则 B 会打断 A。</li>
<li>例如，如果中断 A 正在执行，中断 B 到来，B 的抢占优先级与 A相同，则 B 不会打断 A。</li>
</ul>
<p>在实际开发中，我们通常先配置优先级分组，再为每个中断设置抢占优先级和子优先级。优先级的配置会影响中断的嵌套关系，例如分组为 2 时支持 4 级中断嵌套，分组为 4 时支持 16 级中断嵌套。</p>
<h4 id="5-特殊中断优先级"><a href="#5-特殊中断优先级" class="headerlink" title="5.特殊中断优先级"></a>5.特殊中断优先级</h4><p>在单片机用户手册中，有些异常中断的优先级是固定的，例如复位、NMI（非屏蔽中断）、硬件错误中断等，它们的优先级分别为 -3、-2、-1，复位中断的优先级最高。其他异常中断则可以根据需要进行优先级配置。</p>
<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3.代码实现"></a>3.代码实现</h2><p>通过 EXTI 中断的方式检测 K1 按键。对应的引脚是 PA0，与 EXTI 线 0 相连接。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190014548.png" alt="-173288448532443"></p>
<p><strong>配置和初始化过程</strong>可以分为两部分：</p>
<ul>
<li>第一部分是初始化 GPIO，包括使能 GPIO 的时钟，并配置为输入模式。</li>
<li>第二部分是初始化 EXTI，分为五个步骤：<ul>
<li>使能 EXTI 外设的时钟。</li>
<li>配置引脚连接到 EXTI 线，并设置上升沿或下降沿触发。</li>
<li>清除中断标志位。</li>
<li>使能中断。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f30x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led_drv.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">GPIOInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	rcu_periph_clock_enable(RCU_GPIOA);</span><br><span class="line">	gpio_init(GPIOA, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_2MHZ, GPIO_PIN_0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">EXTIInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 使能EXTI时钟 */</span></span><br><span class="line">	rcu_periph_clock_enable(RCU_AF);</span><br><span class="line">	<span class="comment">/* I/O连接到EXTI线 */</span></span><br><span class="line">	gpio_exti_source_select(GPIO_PORT_SOURCE_GPIOA, GPIO_PIN_SOURCE_0);</span><br><span class="line">	<span class="comment">/* 配置下降沿 */</span></span><br><span class="line">	exti_init(EXTI_0, EXTI_INTERRUPT, EXTI_TRIG_FALLING);</span><br><span class="line">	<span class="comment">/* 清除标志 */</span></span><br><span class="line">	exti_interrupt_flag_clear(EXTI_0);</span><br><span class="line">	<span class="comment">/* 使能中断 */</span></span><br><span class="line">	nvic_irq_enable(EXTI0_IRQn, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief 按键硬件初始化</span></span><br><span class="line"><span class="comment">* @param</span></span><br><span class="line"><span class="comment">* @return </span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">KeyInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIOInit();</span><br><span class="line">	EXTIInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在实现使能中断时，使用 NVIC 的接口函数 <code>nvic_irq_enable</code>，其参数为中断源、抢占优先级和子优先级。默认情况下，优先级分组设置为抢占优先级 2 位，子优先级 2 位，范围为 0 到 3。</p>
<p>仿真调试时，可以通过 J-Link 连接进行单步跟踪，了解 NVIC IRQ Enable 函数的执行过程。在寄存器中，可以看到优先级分组的配置和变化。</p>
<blockquote>
<p><strong>初始化外部中断时，清除 EXTI 中断标志位就是清除对应 EXTI 中断线的标志位。</strong></p>
<p>清除对应的中断线原因：</p>
<ul>
<li><strong>避免中断干扰</strong></li>
</ul>
<p>在中断控制器配置期间，如果不清除先前的中断状态，可能会导致意外的中断触发。这会影响系统的稳定性和可靠性，甚至可能导致错误的处理流程。因此，清除中断线可以确保在配置新中断时，不会被之前未处理的中断干扰。</p>
<ul>
<li><strong>保证中断服务程序的正确执行</strong></li>
</ul>
<p>如果不清除中断线，系统可能会在配置过程中立即响应旧的中断信号，从而触发中断服务例程（ISR）。这可能导致中断服务例程执行时，硬件资源尚未正确配置，进而引发不可预期的错误。因此，清除中断线可以确保只有在配置完成后，新的中断才会被响应。</p>
<ul>
<li><strong>提高中断处理的效率</strong></li>
</ul>
<p>通过清除中断线，系统能够更快速地识别和响应新的中断信号。当中断控制器检测到一个中断请求时，它将检查相应的中断线状态。如果这些中断线在配置期间被清除，系统可以在收到新的中断请求时更加高效地进行处理。</p>
<ul>
<li><strong>避免误判和重复触发</strong></li>
</ul>
<p>如果中断线未被清除，可能导致系统误判当前的中断状态，重复触发同一个中断。这不仅浪费了处理资源，还可能导致数据损坏或系统崩溃。因此，清除中断线是一种防范机制，可以帮助确保中断处理的准确性。</p>
</blockquote>
<h3 id="1-问题一：没有中断服务函数"><a href="#1-问题一：没有中断服务函数" class="headerlink" title="1.问题一：没有中断服务函数"></a><strong>1.问题一：没有中断服务函数</strong></h3><h4 id="1-问题一：有主循环"><a href="#1-问题一：有主循环" class="headerlink" title="1.问题一：有主循环"></a>1.问题一：有主循环</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f30x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key_drv.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	DelayInit();</span><br><span class="line">	LedInit();</span><br><span class="line">	KeyInit();</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412121521569.png" alt="QQ20241212-151901"></p>
<p><strong>如果此时运行程序，由于初始化了 EXTI 并使能了中断，但没有实现中断服务函数，会导致程序进入汇编代码里面默认的中断服务函数，即死循环。</strong></p>
<h4 id="2-问题二：没有主函数循环"><a href="#2-问题二：没有主函数循环" class="headerlink" title="2.问题二：没有主函数循环"></a><strong>2.问题二：没有主函数循环</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f30x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led_drv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key_drv.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	DelayInit();</span><br><span class="line">	LedInit();</span><br><span class="line">	KeyInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412121527992.png" alt="QQ20241212-152728"></p>
<p>在程序执行完 <code>main()</code> 后，如果没有 <code>while(1)</code> 并且刚好触发了外部中断，程序的行为和有 <code>while(1)</code> 的情况是类似的，都会进入汇编启动文件的 <code>B .</code> 死循环，而不会直接执行硬件错误中断。</p>
<blockquote>
<p>如果没有 <code>while(1)</code>，并且程序执行完 <code>main()</code> 后，控制流会进入未定义区域。若此时发生外部中断，处理器会尝试跳转到 ISR，但如果 ISR 未定义或中断处理机制不完善，可能导致错误（如程序跳转到非法地址），从而触发 <code>HardFault</code>中断。</p>
<p><strong>没有为外部中断编写相应的服务函数（ISR）</strong> 是导致 <strong>HardFault</strong> 的 <strong>主要原因</strong>，而 <strong>while(1)</strong> 只是一个 <strong>次要原因</strong>。</p>
</blockquote>
<h3 id="2-问题二：未清除标志位"><a href="#2-问题二：未清除标志位" class="headerlink" title="2.问题二：未清除标志位"></a>2.问题二：未清除标志位</h3><p>验证一个问题：GPIO 口连接到 EXTI 线时，同一时刻只能有一个 IO 口连接。</p>
<blockquote>
<p><strong>现在连接的是 PA0，如果再配置 PC0 连接到 EXTI 线：</strong></p>
<p>复位后按下 K1 没有反应，去掉 PC0 配置后，按下 K1，LED 灯亮，再按下灭。</p>
</blockquote>
<p>如果在 EXTI 中断服务函数中不清除标志位会发生什么情况。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief EXTI0中断服务函数，对应PA0</span></span><br><span class="line"><span class="comment">* @param</span></span><br><span class="line"><span class="comment">* @return </span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI0_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (exti_interrupt_flag_get(EXTI_0) != RESET)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 清除外部中断线 */</span></span><br><span class="line">		<span class="comment">//exti_interrupt_flag_clear(EXTI_0);</span></span><br><span class="line">		ToggleLed(LED1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在中断服务函数中设置一个断点，全速运行，按下 K1。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412121826256.png" alt="QQ20241212-182625"></p>
<p>可以看到程序停在断点处，再次全速执行并按下K1，程序不断进入中断服务函数。</p>
<p><strong>因此，对于 EXTI 中断服务函数，必须清除中断标志位。</strong></p>
<blockquote>
<p>编写中断服务函数之前，加入管理所有中断的<code>gd32f30x_it.c</code>文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f30x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led_drv.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">GPIOInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	rcu_periph_clock_enable(RCU_GPIOA);</span><br><span class="line">	gpio_init(GPIOA, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_2MHZ, GPIO_PIN_0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">EXTIInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 使能EXTI时钟 */</span></span><br><span class="line">	rcu_periph_clock_enable(RCU_AF);</span><br><span class="line">	<span class="comment">/* I/O连接到EXTI线 */</span></span><br><span class="line">	gpio_exti_source_select(GPIO_PORT_SOURCE_GPIOA, GPIO_PIN_SOURCE_0);</span><br><span class="line">	<span class="comment">/* 配置下降沿 */</span></span><br><span class="line">	exti_init(EXTI_0, EXTI_INTERRUPT, EXTI_TRIG_FALLING);</span><br><span class="line">	<span class="comment">/* 清除标志 */</span></span><br><span class="line">	exti_interrupt_flag_clear(EXTI_0);</span><br><span class="line">	<span class="comment">/* 使能中断 */</span></span><br><span class="line">	nvic_irq_enable(EXTI0_IRQn, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief 按键硬件初始化</span></span><br><span class="line"><span class="comment">* @param</span></span><br><span class="line"><span class="comment">* @return </span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">KeyInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIOInit();</span><br><span class="line">	EXTIInit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief EXTI0中断服务函数，对应PA0</span></span><br><span class="line"><span class="comment">* @param</span></span><br><span class="line"><span class="comment">* @return </span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI0_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (exti_interrupt_flag_get(EXTI_0) != RESET)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 清除外部中断线 */</span></span><br><span class="line">		exti_interrupt_flag_clear(EXTI_0);</span><br><span class="line">		ToggleLed(LED1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="3-问题三：中断抢占优先级"><a href="#3-问题三：中断抢占优先级" class="headerlink" title="3.问题三：中断抢占优先级"></a>3.问题三：中断抢占优先级</h3><p>在EXTI0的中断服务函数中加上一个无限循环：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f30x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led_drv.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">GPIOInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	rcu_periph_clock_enable(RCU_GPIOA);</span><br><span class="line">	gpio_init(GPIOA, GPIO_MODE_IPU, GPIO_OSPEED_2MHZ, GPIO_PIN_0);</span><br><span class="line">	</span><br><span class="line">	rcu_periph_clock_enable(RCU_GPIOG);</span><br><span class="line">	gpio_init(GPIOG, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_2MHZ, GPIO_PIN_13);</span><br><span class="line">	gpio_init(GPIOG, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_2MHZ, GPIO_PIN_14);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">EXTIInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 使能EXTI时钟 */</span></span><br><span class="line">	rcu_periph_clock_enable(RCU_AF);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* I/O连接到EXTI线 */</span></span><br><span class="line">	gpio_exti_source_select(GPIO_PORT_SOURCE_GPIOA, GPIO_PIN_SOURCE_0);</span><br><span class="line">	<span class="comment">/* 配置下降沿 */</span></span><br><span class="line">	exti_init(EXTI_0, EXTI_INTERRUPT, EXTI_TRIG_FALLING);</span><br><span class="line">	<span class="comment">/* 清除标志 */</span></span><br><span class="line">	exti_interrupt_flag_clear(EXTI_0);</span><br><span class="line">	<span class="comment">/* 使能中断 */</span></span><br><span class="line">	nvic_irq_enable(EXTI0_IRQn, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* I/O连接到EXTI线 */</span></span><br><span class="line">	gpio_exti_source_select(GPIO_PORT_SOURCE_GPIOG, GPIO_PIN_SOURCE_13);</span><br><span class="line">	<span class="comment">/* 下降沿 */</span></span><br><span class="line">	exti_init(EXTI_13, EXTI_INTERRUPT, EXTI_TRIG_FALLING);</span><br><span class="line">	<span class="comment">/* 清除标志 */</span></span><br><span class="line">	exti_interrupt_flag_clear(EXTI_13);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* I/O连接到EXTI线 */</span></span><br><span class="line">	gpio_exti_source_select(GPIO_PORT_SOURCE_GPIOG, GPIO_PIN_SOURCE_14);</span><br><span class="line">	<span class="comment">/* 下降沿 */</span></span><br><span class="line">	exti_init(EXTI_14, EXTI_INTERRUPT, EXTI_TRIG_FALLING);</span><br><span class="line">	<span class="comment">/* 清除标志 */</span></span><br><span class="line">	exti_interrupt_flag_clear(EXTI_14);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 使能中断 */</span></span><br><span class="line">	nvic_irq_enable(EXTI10_15_IRQn, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief 按键硬件初始化</span></span><br><span class="line"><span class="comment">* @param</span></span><br><span class="line"><span class="comment">* @return </span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">KeyInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIOInit();</span><br><span class="line">	EXTIInit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief EXTI0中断服务函数，对应PA0</span></span><br><span class="line"><span class="comment">* @param</span></span><br><span class="line"><span class="comment">* @return </span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI0_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (exti_interrupt_flag_get(EXTI_0) != RESET)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 清除外部中断线 */</span></span><br><span class="line">		exti_interrupt_flag_clear(EXTI_0);</span><br><span class="line">		ToggleLed(LED1);</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief EXTI10_15中断服务函数，对应PG13 PG14</span></span><br><span class="line"><span class="comment">* @param</span></span><br><span class="line"><span class="comment">* @return </span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI10_15_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (exti_interrupt_flag_get(EXTI_13) != RESET)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 清除外部中断线 */</span></span><br><span class="line">		exti_interrupt_flag_clear(EXTI_13);</span><br><span class="line">		ToggleLed(LED2);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (exti_interrupt_flag_get(EXTI_14) != RESET)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 清除外部中断线 */</span></span><br><span class="line">		exti_interrupt_flag_clear(EXTI_14);</span><br><span class="line">		ToggleLed(LED3);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后，按下k1、k2和k3按键，验证LED灯是否正常亮灭。按下k1时，LED1亮灭；按下k2时，LED2亮灭；按下k3时，LED3亮灭。</p>
<h4 id="1-验证抢占优先级作用"><a href="#1-验证抢占优先级作用" class="headerlink" title="1.验证抢占优先级作用"></a>1.验证抢占优先级作用</h4><blockquote>
<p>设置EXTI15的抢占优先级为0，即高优先级。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 使能中断 */</span></span><br><span class="line">nvic_irq_enable(EXTI0_IRQn, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">/* 使能中断 */</span></span><br><span class="line">nvic_irq_enable(EXTI10_15_IRQn, <span class="number">0</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>按下k1按键，进入EXTI0的中断服务函数，点亮LED并停留在<code>while(1)</code>位置。此时，再按下k1按键，LED无法熄灭，因为EXTI0的中断服务函数没有结束，无法响应新的中断。</p>
<p><strong>如果此时按下k2或k3，LED2或LED3亮，说明本来程序停留在EXTI0的服务函数循环中，当EXTI15的中断发生时，由于EXTI15的抢占优先级较高，它会打断EXTI0的执行，先执行EXTI15的中断服务函数。</strong></p>
</blockquote>
<h4 id="2-验证子优先级作用"><a href="#2-验证子优先级作用" class="headerlink" title="2.验证子优先级作用"></a>2.验证子优先级作用</h4><blockquote>
<p>设置抢占优先级都为相同数值，并将子优先级设置为更高。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 使能中断 */</span></span><br><span class="line">nvic_irq_enable(EXTI0_IRQn, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">/* 使能中断 */</span></span><br><span class="line">nvic_irq_enable(EXTI10_15_IRQn, <span class="number">1</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>按下k1按键，进入EXTI0的中断服务函数，点亮LED并停留在<code>while(1)</code>位置。此时再按下k1后，LED1不会熄灭，因为EXTI0的中断服务函数没有结束，无法响应新的中断。</p>
<p><strong>如果此时按下k2或k3，也没有反应，说明抢占优先级相同，无法打断当前的中断服务函数，即发生不会发送抢占中断。</strong></p>
</blockquote>
<h2 id="4-方案对比"><a href="#4-方案对比" class="headerlink" title="4.方案对比"></a>4.方案对比</h2><blockquote>
<p>在实际项目中，使用EXTI方式来检测按键并不是最优方案。<strong>原因在于，在中断服务函数内执行其他模块的功能可能会造成阻塞。中断服务函数的执行时间应尽量短，以避免影响其他中断的响应。此外，如果中断服务函数的优先级较高，其他中断可能无法得到及时响应。</strong></p>
<p>为了解决以上问题，可以通过定义一个全局变量（例如 <code>uint8_t flag = 0</code>）来标识按键是否被按下。中断服务函数只需要将 <code>flag</code> 置为1，然后在主循环（<code>while(1)</code>）中轮询检查该标志。如果标志为1，则执行相应的业务功能函数。这种方法相较于直接在中断服务函数中调用其他模块的接口要更加合适，因为它避免了中断服务函数的阻塞。</p>
<p>不过，这种方法的效率不如直接轮询检测按键，因此在一些应用中，可能不需要使用EXTI中断，而是直接使用轮询的方式来检测按键。</p>
</blockquote>
<h1 id="RTC"><a href="#RTC" class="headerlink" title="RTC"></a>RTC</h1><h2 id="1-使用指针函数的注意事项"><a href="#1-使用指针函数的注意事项" class="headerlink" title="1.使用指针函数的注意事项"></a>1.使用指针函数的注意事项</h2><h2 id="2-RTC和BKP硬件结构"><a href="#2-RTC和BKP硬件结构" class="headerlink" title="2.RTC和BKP硬件结构"></a>2.RTC和BKP硬件结构</h2><h3 id="1-RTC"><a href="#1-RTC" class="headerlink" title="1.RTC"></a>1.RTC</h3><blockquote>
<p>RTC简易硬件结构框图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190016858.png" alt="image-20241130123025264"></p>
<p>GD32F303 单片机的 RTC 硬件结构与 STM32F103 相同，RTC 有三个时钟源：</p>
<ul>
<li>外部高速时钟：4~32 MHz（如开发板上的 8 MHz，可进行 128 分频），主电源掉电后将停止工作。</li>
<li>外部低速时钟：32.768 kHz，通常选用此时钟，因为在主电源掉电后，它可由纽扣电池供电，RTC 仍能持续计时。</li>
<li>内部时钟：单片机内部的 40 kHz 时钟，主电源掉电后将停止工作。</li>
</ul>
<p>原理框图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190018504.png" alt="QQ20241130-123121"></p>
<p>在开发板上，RTC 电路包括供电部分和晶振部分。</p>
<p>供电部分使用 BAT54C，它里面有两个二极管，阴极相连。当主电源有电且电压高于纽扣电池电压时，主电源侧的二极管导通，由主电源供电；当主电源掉电后，主电源电压下降，纽扣电池侧的二极管导通，由纽扣电池供电。这样实现了供电的自动切换。</p>
<p>原理框图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190018726.png" alt="QQ20241130-123457"></p>
<p>晶振部分使用 32.768 kHz 晶振和两个起振电容。</p>
<p>RTC硬件结构框图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190019024.png" alt="image-20241130123542930"></p>
<p>RTC 的时钟输入通过预分频器（PRL 和 DIV 寄存器）实现分频。将预分频值 32767 写入 PRL，对 32.768 kHz 的时钟进行分频，DIV 寄存器作为向下递减计数器，生成 1 Hz 的时钟信号，用于计数器 CNT，每记一个数值，也就是一秒钟。</p>
<p>RTC 还有闹钟寄存器 RTC_Alarm，可产生秒中断、计数溢出中断、闹钟中断等。APB1 时钟（PCLK）用于提供 APB1 读写接口。当主电源掉电时，PCLK 1停止工作，但 RTCCLK 可继续工作。因为外部有这个纽扣电池。当然，如果没有纽扣电池，它也就没办法工作了。</p>
</blockquote>
<h3 id="2-BKP"><a href="#2-BKP" class="headerlink" title="2.BKP"></a>2.BKP</h3><blockquote>
<p>RTC简易硬件结构框图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190020506.png" alt="image-20241130124458958"></p>
<p>RTC 寄存器位于备份区域（后备区），涉及片上外设 BKP（备份寄存器）。当 VDD 主电源掉电后，可由 Vbat（如纽扣电池）供电。BKP 内除了 RTC 的寄存器外，还有 42 个 16 位的寄存器（DR1~DR42），可用于存储用户数据。需要注意：如果没有纽扣电池供电，掉电后数据将丢失。这些寄存器和内存一样，在完全掉电时数据会丢失，并不像 Flash 那样是非易失性的存储器。所以，如果没有主电源供电，必须要有纽扣电池供电才可以保持数据。当设备从待机模式唤醒或者是复位后，只要有纽扣电池供电，BKP 寄存器中的数据就不会丢失。</p>
<p>此外，BKP寄存器也可以实现RTC校准和侵入检测功能：</p>
<p><strong>信号校准寄存器：</strong></p>
<p>这是我们可以配置，然后将RTC的时钟通过一个管脚，这个管脚呢是PC13是复用的，通过这个管脚将信号输出。然后我们去监测，如果发现这个时钟啊，偏差比较大，我们可以去配置这个校准寄存器用来校准，就是这个功能。</p>
<p><strong>侵入检测寄存器：</strong></p>
<p>比如说我们的产品啊，这个安全性要求比较高，不想让别人去分析，我们就可以使用侵入检测。它使用的这个PC13引脚的复用功能。要想实现侵入检测，我们可以对这个管脚，比如说加上一个上拉电阻。然后可以再通过一个导线连接一个开关，这个开关再连接到外壳上，外壳是接地的。当有人拆卸外壳时，会触发开关状态改变，PC13 引脚的电平从高电平变为低电平，检测到这种电平变化后，产生侵入检测事件。这个事件又会进一步地触发去清除BKP寄存器里面的数据。我们可以在这个寄存器里面保存一些核心的关键的参数。这样的话，别人就没有办法去完整地分析整个系统了。另外，即使设备的主电源断电了，因为有纽扣电池，通过Vbat还可以给它供电。这样的话，侵入检测的功能还是可以继续工作的。</p>
</blockquote>
<h3 id="3-RTC-amp-BKP初始化配置"><a href="#3-RTC-amp-BKP初始化配置" class="headerlink" title="3.RTC &amp; BKP初始化配置"></a>3.RTC &amp; BKP初始化配置</h3><blockquote>
<p>RTC配置框图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190021394.png" alt="image-20241130125614864"></p>
<p><strong>使能对RTC的访问，使能PMU和BKP：</strong></p>
<p>即后备区域的时钟，还有电源管理的时钟。</p>
<p><strong>使能对后备寄存器和RTC的写权限：</strong></p>
<p>来看一下用户手册。这个功能是在PMU电源管理这个章节，PMU_CTL这个寄存器第八位，在这儿BKPWEN写使能。设置为1的时候，允许对这个寄存器啊进行写访问，也包括对RTC写访问。</p>
<p><strong>复位后备寄存器：</strong></p>
<p>通过这个操作可以对后备区域的这些寄存器的数据啊，全部给它复位清零。这是我们首次初始化配置的时候啊，可以去做的一个操作。</p>
<p><strong>使能外部低速时钟LXTAL，然后等待稳定：</strong></p>
<p><strong>设置RTC的时钟输入源为LXTAL：</strong></p>
<p>使能外部低速时钟并等待其稳定，设置 RTC 的时钟源为外部低速时钟（32.768 kHz）。</p>
<p><strong>使能 RTC 时钟并等待APB1和RTC时钟同步：</strong></p>
<p>涉及到了两个时钟：一个是PCLK，这就是APB1时钟，然后还有一个RTC的时钟。那么，这两个时钟在系统复位或者是待机唤醒以后，可能会存在着不同步的问题，因此我们在代码里面，要等待两个时钟同步。</p>
<p><strong>等待上次对RTC寄存器写操作完成：</strong></p>
<p>我们要去查询一个标志位，然后才能去写一些寄存器，包括分频寄存器，包括设置计数值。</p>
<p>来看一下用户手册。在RTC配置这里面，当写操作完成以后RTC_CTL寄存器当中的RWOF位会变为1。那么，下一次写操作之前，必须要等待上次写操作完成之后才能进行，就是通过查询这个标志来判断的，判断它为1后才能去进行写操作。每一次写操作都要去判断。</p>
<p>在这个描述里面还看到，说是要将RTC设置为配置模式，才能对寄存器进行写操作。对应的是RTC_CTL的CMF位。但是，通过实际写代码验证啊，发现即使没有对这个寄存器的CMF位进行配置，也是可以写操作的。这个是RWOF，判断上次RTC写操作是否已经完成。然后这个CMF用来退出配置，或者是进入配置。那么，在代码当中啊，我们发现，只需要实现这个环节就可以了，使能对后备寄存器RTC的写权限就可以了。不配置这个CMF也没问题。</p>
<p><strong>设置预分频值：</strong></p>
<p>例如32767。这样的话，分频以后生成的这个时钟信号就是1Hz，一秒钟。</p>
<p><strong>等待上次对RTC寄存器写操作完成：</strong></p>
<p><strong>设置计数值：</strong></p>
<p>在初始化的时候，我们也可以设置一个初始的计数值假设为0，那么对应的这个日历时间就是1970年1月1号零点零分零秒。</p>
</blockquote>
<h2 id="3-RTC驱动层代码实现"><a href="#3-RTC驱动层代码实现" class="headerlink" title="3.RTC驱动层代码实现"></a>3.RTC驱动层代码实现</h2><h3 id="1-RTC-初始化过程"><a href="#1-RTC-初始化过程" class="headerlink" title="1.RTC 初始化过程"></a>1.RTC 初始化过程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RtcDrvInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (bkp_read_data(BKP_DATA_0) != MAGIC_CODE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 使能对RTC的访问，使能PMU和BKP时钟 */</span></span><br><span class="line">		rcu_periph_clock_enable(RCU_PMU);</span><br><span class="line">		rcu_periph_clock_enable(RCU_BKPI);</span><br><span class="line">        </span><br><span class="line">		<span class="comment">/* 使能对后备寄存器和RTC的写权限 */</span></span><br><span class="line">		pmu_backup_write_enable();</span><br><span class="line">        </span><br><span class="line">		<span class="comment">/* 复位后备寄存器 */</span></span><br><span class="line">		bkp_deinit();</span><br><span class="line">        </span><br><span class="line">		<span class="comment">/* 使能LXTAL，并等待其稳定 */</span></span><br><span class="line">		rcu_osci_on(RCU_LXTAL);</span><br><span class="line">		rcu_osci_stab_wait(RCU_LXTAL);</span><br><span class="line">        </span><br><span class="line">		<span class="comment">/* 设置RTC时钟源为LXTAL */</span></span><br><span class="line">		rcu_rtc_clock_config(RCU_RTCSRC_LXTAL);</span><br><span class="line">        </span><br><span class="line">		<span class="comment">/* 使能RTC时钟 */</span></span><br><span class="line">		rcu_periph_clock_enable(RCU_RTC);</span><br><span class="line">        </span><br><span class="line">		<span class="comment">/* 等待APB1接口时钟和RTC时钟同步 */</span></span><br><span class="line">		rtc_register_sync_wait();</span><br><span class="line">        </span><br><span class="line">		<span class="comment">/* 等待上次对 RTC 寄存器写操作完成 */</span></span><br><span class="line">		rtc_lwoff_wait();</span><br><span class="line">        </span><br><span class="line">		<span class="comment">/* 设置分频值32767 */</span></span><br><span class="line">		rtc_prescaler_set(<span class="number">32767</span>);</span><br><span class="line">        </span><br><span class="line">		<span class="comment">/* 等待上次对 RTC 寄存器写操作完成 */</span></span><br><span class="line">		rtc_lwoff_wait();</span><br><span class="line">        </span><br><span class="line">		<span class="comment">/* 设置时间2023-02-28 23:59:50 */</span></span><br><span class="line">		rtc_counter_set(<span class="number">1677599990</span>);</span><br><span class="line">		bkp_write_data(BKP_DATA_0, MAGIC_CODE);</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 使能对RTC的访问，使能PMU和BKP时钟 */</span></span><br><span class="line">	rcu_periph_clock_enable(RCU_PMU);</span><br><span class="line">	rcu_periph_clock_enable(RCU_BKPI);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* 使能对后备寄存器和RTC的写权限 */</span></span><br><span class="line">	pmu_backup_write_enable();</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* 等待APB1接口时钟和RTC时钟同步 */</span></span><br><span class="line">	rtc_register_sync_wait();</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* 等待上次对 RTC 寄存器写操作完成 */</span></span><br><span class="line">	rtc_lwoff_wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="解析："><a href="#解析：" class="headerlink" title="解析："></a><strong>解析：</strong></h4><h4 id="使能电源和备份接口时钟"><a href="#使能电源和备份接口时钟" class="headerlink" title="使能电源和备份接口时钟"></a>使能电源和备份接口时钟</h4><ul>
<li><p><strong>文字描述：</strong></p>
<ul>
<li><strong>RCU_APB1EN寄存器中的 <code>PMUEN</code> 和 <code>BKPEN</code> 位</strong>：用来使能电源管理单元（PMU）和备份接口（BKP）的时钟。</li>
</ul>
</li>
<li><p><strong>代码对应部分：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rcu_periph_clock_enable(RCU_PMU);</span><br><span class="line">rcu_periph_clock_enable(RCU_BKPI);</span><br></pre></td></tr></table></figure>
<p>这里的 <code>rcu_periph_clock_enable(RCU_PMU)</code> 和 <code>rcu_periph_clock_enable(RCU_BKPI)</code> 分别使能了电源管理单元和备份接口的时钟，保证后续对备份寄存器的访问和 RTC 寄存器的写入是可行的。</p>
</li>
</ul>
<h4 id="使能备份域寄存器和-RTC-的访问"><a href="#使能备份域寄存器和-RTC-的访问" class="headerlink" title="使能备份域寄存器和 RTC 的访问"></a>使能备份域寄存器和 RTC 的访问</h4><ul>
<li><p><strong>文字描述：</strong></p>
<ul>
<li><strong>PMU_CTL中的 <code>BKPWEN</code> 位</strong>：通过设置此位来使能对备份域寄存器和 RTC 的访问权限。</li>
</ul>
</li>
<li><p><strong>代码对应部分：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pmu_backup_write_enable();</span><br></pre></td></tr></table></figure>
<p><code>pmu_backup_write_enable()</code> 用于使能对备份寄存器和 RTC 寄存器的写访问权限，这一步相当于设置 <code>BKPWEN</code> 位，使系统具备对 RTC 进行写操作的权限。</p>
</li>
</ul>
<h4 id="复位后备寄存器"><a href="#复位后备寄存器" class="headerlink" title="复位后备寄存器"></a>复位后备寄存器</h4><ul>
<li><p><strong>代码部分：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bkp_deinit();</span><br></pre></td></tr></table></figure>
<p>这一行代码用于复位后备寄存器，确保备份域中的寄存器处于初始状态，尤其是在首次上电或 RTC 需要重新配置的情况下。</p>
</li>
</ul>
<h4 id="启用低速外部晶振（LXTAL）并等待其稳定"><a href="#启用低速外部晶振（LXTAL）并等待其稳定" class="headerlink" title="启用低速外部晶振（LXTAL）并等待其稳定"></a>启用低速外部晶振（LXTAL）并等待其稳定</h4><ul>
<li><p><strong>文字描述：</strong></p>
<ul>
<li>RTC 通常由外部低速晶振 (LXTAL) 提供时钟源，用于保证时间的精确性。</li>
</ul>
</li>
<li><p><strong>代码对应部分：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rcu_osci_on(RCU_LXTAL);</span><br><span class="line">rcu_osci_stab_wait(RCU_LXTAL);</span><br></pre></td></tr></table></figure>
<p><code>rcu_osci_on(RCU_LXTAL)</code> 使能低速外部晶振 (LXTAL)，用于提供 RTC 所需的 32.768 kHz 时钟。<code>rcu_osci_stab_wait(RCU_LXTAL)</code> 等待晶振稳定，这对于确保 RTC 的准确性至关重要。</p>
</li>
</ul>
<h4 id="设置-RTC-时钟源为-LXTAL"><a href="#设置-RTC-时钟源为-LXTAL" class="headerlink" title="设置 RTC 时钟源为 LXTAL"></a>设置 RTC 时钟源为 LXTAL</h4><ul>
<li><p><strong>文字描述：</strong></p>
<ul>
<li>RTC 的时钟源需要设置为 LXTAL，保证 RTC 的稳定运行。</li>
</ul>
</li>
<li><p><strong>代码对应部分：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rcu_rtc_clock_config(RCU_RTCSRC_LXTAL);</span><br></pre></td></tr></table></figure>
<p>这行代码用于将 RTC 的时钟源设置为 LXTAL，确保 RTC 使用外部稳定的 32.768 kHz 进行计数。</p>
</li>
</ul>
<h4 id="使能-RTC-时钟并等待同步"><a href="#使能-RTC-时钟并等待同步" class="headerlink" title="使能 RTC 时钟并等待同步"></a>使能 RTC 时钟并等待同步</h4><ul>
<li><p><strong>文字描述：</strong></p>
<ul>
<li><strong>APB 接口和 RTC 内核的同步问题</strong>：RTC 内核和 APB 接口分属于不同的电源域，需要进行同步。</li>
</ul>
</li>
<li><p><strong>代码对应部分：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rcu_periph_clock_enable(RCU_RTC);</span><br><span class="line">rtc_register_sync_wait();</span><br></pre></td></tr></table></figure>
<p>这里通过 <code>rcu_periph_clock_enable(RCU_RTC)</code> 启用了 RTC 时钟，使能对 RTC 的访问。<code>rtc_register_sync_wait()</code> 用于等待 APB1 接口与 RTC 内核的时钟同步，避免在未同步的情况下对 RTC 寄存器进行读写操作导致的数据错误。</p>
</li>
</ul>
<h4 id="等待上次写操作完成"><a href="#等待上次写操作完成" class="headerlink" title="等待上次写操作完成"></a>等待上次写操作完成</h4><ul>
<li><p><strong>文字描述：</strong></p>
<ul>
<li><strong>等待 <code>RTC_CTL</code> 寄存器中的 <code>LWOFF</code> 位变为 1</strong>：确保上次对 RTC 的写操作已完成，避免冲突。</li>
</ul>
</li>
<li><p><strong>代码对应部分：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rtc_lwoff_wait();</span><br></pre></td></tr></table></figure>
<p>通过 <code>rtc_lwoff_wait()</code> 函数，等待 <code>LWOFF</code> 位变为 1，确保 RTC 的上一次写操作（如设置分频值、计数器等）已经完成。</p>
</li>
</ul>
<h4 id="设置-RTC-分频器和初始时间"><a href="#设置-RTC-分频器和初始时间" class="headerlink" title="设置 RTC 分频器和初始时间"></a>设置 RTC 分频器和初始时间</h4><ul>
<li><p><strong>文字描述：</strong></p>
<ul>
<li><strong>配置模式 (<code>CMF</code> 置位)</strong>：进入配置模式来对 RTC 寄存器进行修改。</li>
</ul>
</li>
<li><p><strong>代码对应部分：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rtc_prescaler_set(<span class="number">32767</span>);</span><br><span class="line">rtc_lwoff_wait();</span><br><span class="line">rtc_counter_set(<span class="number">1677599990</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>rtc_prescaler_set(32767)</code>：设置 RTC 的分频器为 32767。RTC 使用 32.768 kHz 的时钟源，通过分频 32767 可以得到 1 Hz 的时钟，从而实现秒级计数。</li>
<li><code>rtc_lwoff_wait()</code>：再次等待上次的写操作完成，确保分频器的设置已经生效。</li>
<li><code>rtc_counter_set(1677599990)</code>：设置初始时间的计数器值为 <code>1677599990</code>，这个值表示从 Epoch（1970 年 1 月 1 日 00:00:00 UTC）以来的秒数，相当于 <code>2023-02-28 23:59:50</code>。</li>
</ul>
</li>
</ul>
<h4 id="设置备份寄存器标记已初始化"><a href="#设置备份寄存器标记已初始化" class="headerlink" title="设置备份寄存器标记已初始化"></a>设置备份寄存器标记已初始化</h4><ul>
<li><p><strong>代码部分：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bkp_write_data(BKP_DATA_0, MAGIC_CODE);</span><br></pre></td></tr></table></figure>
<p>将 <code>MAGIC_CODE</code> 写入备份寄存器 <code>BKP_DATA_0</code> 中，作为标志，表示 RTC 已经正确初始化。在下一次上电或复位时，可以通过这个标志判断是否需要重新初始化 RTC。</p>
</li>
</ul>
</blockquote>
<h3 id="2-设置时间"><a href="#2-设置时间" class="headerlink" title="2.设置时间"></a>2.设置时间</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SetRtcTime</span><span class="params">(RtcTime_t *time)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">time_t</span> timeStamp;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">tmInfo</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;tmInfo, <span class="number">0</span>, <span class="keyword">sizeof</span>(tmInfo));</span><br><span class="line">	</span><br><span class="line">	tmInfo.tm_year = time-&gt;year - <span class="number">1900</span>;</span><br><span class="line">	tmInfo.tm_mon = time-&gt;month - <span class="number">1</span>;</span><br><span class="line">	tmInfo.tm_mday = time-&gt;day;</span><br><span class="line">	tmInfo.tm_hour = time-&gt;hour;</span><br><span class="line">	tmInfo.tm_min = time-&gt;minute;</span><br><span class="line">	tmInfo.tm_sec = time-&gt;second;</span><br><span class="line">	</span><br><span class="line">	timeStamp = mktime(&amp;tmInfo) - <span class="number">8</span> * <span class="number">60</span> * <span class="number">60</span>;</span><br><span class="line">	</span><br><span class="line">	rtc_lwoff_wait();</span><br><span class="line">	rtc_counter_set(timeStamp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>SetRtcTime</code> 函数用于设置 RTC 的当前时间。</p>
<ul>
<li><p><strong>步骤解析：</strong></p>
<ul>
<li><p>创建一个 <code>tm</code> 结构体 (<code>struct tm tmInfo</code>) 用于存储时间信息。</p>
</li>
<li><p>将输入的结构体 <code>RtcTime_t</code> 中的年、月、日、小时、分钟、秒分别赋值给 <code>tmInfo</code>。</p>
</li>
<li><p>将年、月的值进行偏移，<code>tm_year</code> 是从 1900 年开始计数，而 <code>tm_mon</code> 是从 0 开始计数，所以分别做了对应的减法处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tmInfo.tm_year = time-&gt;year - <span class="number">1900</span>;</span><br><span class="line">tmInfo.tm_mon = time-&gt;month - <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用 <code>mktime()</code> 将时间转换为 Unix 时间戳（自 1970-01-01 00:00:00 以来的秒数），并减去 8 小时的偏移量，这是为了调整为 UTC 时间：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timeStamp = mktime(&amp;tmInfo) - <span class="number">8</span> * <span class="number">60</span> * <span class="number">60</span>;</span><br></pre></td></tr></table></figure>
<p>因为 <code>mktime()</code> 返回的是本地时间戳，假设本地时区为 UTC+8，所以这里需要减去 8 小时，将其转换为 UTC 时间。</p>
</li>
<li><p>等待 RTC 寄存器解锁，然后将时间戳设置到 RTC计数器：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rtc_lwoff_wait();</span><br><span class="line">rtc_counter_set(timeStamp);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="3-获取时间"><a href="#3-获取时间" class="headerlink" title="3.获取时间"></a>3.获取时间</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GetRtcTime</span><span class="params">(RtcTime_t *time)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">time_t</span> timeStamp;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">tmInfo</span>;</span></span><br><span class="line">	</span><br><span class="line">	timeStamp = rtc_counter_get() + <span class="number">8</span> * <span class="number">60</span> * <span class="number">60</span>;</span><br><span class="line">	tmInfo = localtime(&amp;timeStamp);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">	time-&gt;year = tmInfo-&gt;tm_year + <span class="number">1900</span>;</span><br><span class="line">	time-&gt;month = tmInfo-&gt;tm_mon + <span class="number">1</span>;</span><br><span class="line">	time-&gt;day = tmInfo-&gt;tm_mday;</span><br><span class="line">	time-&gt;hour = tmInfo-&gt;tm_hour;</span><br><span class="line">	time-&gt;minute = tmInfo-&gt;tm_min;</span><br><span class="line">	time-&gt;second = tmInfo-&gt;tm_sec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>GetRtcTime</code> 函数用于从 RTC 中获取当前时间并将其转换为日历时间。</p>
<ul>
<li><p><strong>步骤解析：</strong></p>
<ul>
<li><p>从 RTC 中读取当前计数器的值，即获取 Unix 时间戳：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timeStamp = rtc_counter_get() + <span class="number">8</span> * <span class="number">60</span> * <span class="number">60</span>;</span><br></pre></td></tr></table></figure>
<p>读取到的时间是 UTC 时间，所以这里加上 8 小时的偏移量，将其转换为本地时间<strong>（UTC+8）</strong>。</p>
</li>
<li><p>调用 <code>localtime()</code> 将时间戳转换为 <code>struct tm</code> 结构体。</p>
</li>
<li><p>将 <code>struct tm</code> 结构体中的值赋回到 <code>RtcTime_t</code> 结构体中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">time-&gt;year = tmInfo-&gt;tm_year + <span class="number">1900</span>;</span><br><span class="line">time-&gt;month = tmInfo-&gt;tm_mon + <span class="number">1</span>;</span><br><span class="line">time-&gt;day = tmInfo-&gt;tm_mday;</span><br><span class="line">time-&gt;hour = tmInfo-&gt;tm_hour;</span><br><span class="line">time-&gt;minute = tmInfo-&gt;tm_min;</span><br><span class="line">time-&gt;second = tmInfo-&gt;tm_sec;</span><br></pre></td></tr></table></figure>
<p>对年和月的值做了相应的调整，<code>tm_year</code> 需要加上 1900，<code>tm_mon</code> 需要加上 1。</p>
</li>
</ul>
</li>
</ul>
<h1 id="ADC"><a href="#ADC" class="headerlink" title="ADC"></a>ADC</h1><h2 id="1-ADC系统工作原理"><a href="#1-ADC系统工作原理" class="headerlink" title="1.ADC系统工作原理"></a>1.ADC系统工作原理</h2><p>ADC硬件结构框图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190026875.png" alt="image-20241130132029534"></p>
<p>GT32F303ZET6 MCU内置三个ADC模块，分别是ADC0、ADC1和ADC2。这些ADC的分辨率是可以配置的，支持12位、10位、8位或6位。此外，ADC还支持自校准功能，以提高采样的精度。采样时间和周期是可编程的，包括1.5个周期、7.5个周期等选项，转换结果可以配置为左对齐或右对齐的方式。</p>
<p>对于规则组数据转换，可以使用DMA配合搬移数据，从而减轻CPU的负担。ADC0和ADC1各自拥有16路外部模拟输入通道，而ADC2的通道数较少。ADC0还集成了一个内部温度传感器输入通道和一个内部参考电压输入通道。需要注意的是，内部温度传感器只能测量MCU芯片的温度，无法测量环境温度。</p>
<p>ADC支持多种转换模式，包括单次模式、连续模式、扫描模式、间断模式和同步模式。</p>
<p>ADC转换完成后，会产生EOC（End Of Conversion）标志，这一标志可以进一步触发NVIC中断。ADC的供电电源为VDD_A和VSSA，支持2.6V到3.6V，通常直接使用板子上的主电源3.3V。参考电源VREFP和VREFN通常将VREFP连接到VDD_A上，因此模拟输入通道的信号源输入电压范围为0V到3.3V。</p>
<p>ADC简易硬件结构框图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190026005.png" alt="image-20241130132207744"></p>
<p>ADC的硬件结构包括16个外部模拟信号输入通道（通过GPIO口复用）、一路温度传感器输入通道和一路参考电压输入通道，共18个ADC通道。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190028408.png" alt="image-20241130133726461"></p>
<p>在ADC转换之前，需要外部触发源进行触发，触发源包括<strong>定时器触发</strong>（如每秒或几百毫秒）、<strong>EXTI外部中断触发</strong>、<strong>软件触发</strong>（通过代码控制）。</p>
<p>GT32F303 MCU的ADC时钟频率最高为40MHz，由120MHz主时钟分频得到。在ADC转换器中，有规则组和注入组两种数据处理方式。规则组类似于程序的主流程，通常满足大部分需求，而注入组类似于程序中的中断，可以打断规则组的转换，优先执行注入组的任务，完成后再继续规则组的转换。转换完成的结果会存放在ADC数据寄存器中，规则组的16个通道共用一个数据寄存器，而注入组有四个独立的数据寄存器。</p>
<p>关于中断，使能ADC中断需要在初始化配置时分为两部分：</p>
<ul>
<li>单片机片上外设中打开中断输出控制。</li>
<li>内核（NVIC）中打开相应的中断开关，例如定时器的更新溢出中断。</li>
</ul>
<p>ADC通道框图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190029343.png" alt="image-20241130132431616"></p>
<p>ADC0、ADC1和ADC2的外部模拟输入通道通过GPIO口连接。ADC0和ADC1各有16个外部输入通道，分别对应PA0到PA7、PB0和PB1、PC0到PC5；而ADC2的通道数较少。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190029829.png" alt="image-20241130132504351"></p>
<p>转换模式包括</p>
<ul>
<li><p>单次模式：</p>
<p>每次ADC转换都需要外部触发源触发。</p>
</li>
<li><p>连续模式：</p>
<p>只需第一次触发，ADC将自动连续进行转换。</p>
</li>
<li><p>扫描模式：</p>
<p>针对单个ADC的多个通道，将通道号按序列放入转换序列寄存器，适用于多通道数据采集。</p>
</li>
<li><p>同步模式：</p>
<p>用于多个ADC模块同时使用的场景，如交替触发ADC0和ADC1，实现多个ADC的协同工作。相比之下，独立模式则仅单独使用某一个ADC模块，无需与其他ADC配合，适用于无需复杂协同的应用场景。常用的部分主要基于独立模式，结合单次、连续和扫描模式。</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190030614.png" alt="image-20241130132727258"></p>
<p>单次转换模式对应规则组，通过转换序列寄存器配置要转换的通道号。</p>
<p>例如，将PA2对应的通道2放在序列1中，由外部触发源触发ADC开始采集、量化和编码转换。转换完成后产生EOC标志位，下一次转换需再次触发源触发。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190030216.png" alt="image-20241130132748339"></p>
<p>连续转换模式则只需首次触发一次，ADC会自动进行后续转换，产生标志位后可读取数据寄存器内容。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190030883.png" alt="image-20241130132820364"></p>
<p>扫描模式适用于单个ADC的多通道转换，将多个通道号按序列寄存器配置后，外部触发源一次触发后，ADC依次转换各通道，完成后产生EOC标志位。</p>
<p>由于规则组只有一个数据寄存器，且每转换一个通道后数据都会移入数据寄存器中，多个通道的数据可能会被覆盖，因此需要配合DMA自动搬移数据到内存数组中，以防数据丢失。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190031476.png" alt="image-20241130133154078"></p>
<p>规则组与注入组的关系类似于程序主流程与中断。规则组按序列执行转换任务，注入组可以打断规则组的转换，优先处理注入组的转换任务，完成后再继续规则组的转换。通常项目中只需使用规则组即可，注入组的使用较为少见，具体可参考芯片用户手册和官方示例程序。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190031706.png" alt="image-20241130133740418"></p>
<p>ADC的数据对齐支持右对齐和左对齐。右对齐（默认）高位填充0，左对齐低位填充0。以12位分辨率为例，参考电压为3.3伏，对应数值范围为0到4095，每步最小电压变化约为0.8mV。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190032952.png" alt="image-20241130133843955"></p>
<p>ADC转换时间包括采样和保持、量化和编码两个步骤。转换时间等于采样时间加上固定的12.5个ADC周期。采样时间可配置，根据信号源的输出阻抗（RAIN）调整。例如，ADC时钟为30MHz，采样周期设置为1.5个周期，则转换时间为14个ADC周期，即0.467微秒。</p>
<p>ADC采集原理包括信号源通过输出阻抗<strong>R_AIN</strong>连接到采样电阻<strong>R_ADC</strong>和采样电容<strong>C_ADC</strong>。外部触发源触发转换后，采集开关SW闭合，通过<strong>R_AIN</strong>和<strong>R_ADC</strong>对<strong>C_ADC</strong>进行充电，电压达到信号源当前电压后采集开关SW抬起，保持电容两端的电压进行量化和编码转换。开关SW闭合断开的间隔时间即为采样时间周期（采样+保持）。</p>
<p>采样时间的设置依据电容充电公式：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190032982.png" alt="image-20241130135112526"></p>
<p>不同信号源的输出阻抗不同，需根据实际情况配置采样时间。</p>
<p>案例分析：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190032993.png" alt="image-20241130135347841"></p>
<p>校准与硬件滤波：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190032742.png" alt="image-20241130135759180"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190033927.png" alt="image-20241130135810508"></p>
<h2 id="2-ADC单通道转换实现"><a href="#2-ADC单通道转换实现" class="headerlink" title="2.ADC单通道转换实现"></a>2.ADC单通道转换实现</h2><p>开发板上有三个器件使用到了ADC（模数转换器）：</p>
<ul>
<li>可调电阻</li>
<li>热敏电阻</li>
<li>湿敏电阻</li>
</ul>
<p>本次重点使用可调电阻，并对应使用ADC的通道。</p>
<h3 id="1-硬件连接"><a href="#1-硬件连接" class="headerlink" title="1.硬件连接"></a><strong>1.硬件连接</strong></h3><blockquote>
<p>原理框图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190036162.png" alt="QQ20241201-173522"></p>
<p><strong>通道选择：</strong></p>
<ul>
<li>使用的通道：ADC0</li>
<li>对应GPIO口：PC2</li>
<li>通道编号：12</li>
</ul>
<p><strong>电源与电压范围：</strong></p>
<ul>
<li>供电电压：3.3V</li>
<li>电压范围：0V 到 3.3V</li>
</ul>
<p><strong>限流电阻说明：</strong></p>
<p>限流电阻不会用于分压。<strong>当GPIO口配置为模拟输入模式时，GPIO口呈现高阻态，因此限流电阻不会分压。</strong></p>
<p><strong>可调电阻调节：</strong></p>
<ul>
<li>调节到最上面时，采集到的电压为3.3V，对应数字量为4095。</li>
<li>调节到最下面时，采集到的电压为0V，对应数字量为0。</li>
</ul>
</blockquote>
<h3 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2.代码实现"></a><strong>2.代码实现</strong></h3><h4 id="1-ADC-初始化配置"><a href="#1-ADC-初始化配置" class="headerlink" title="1.ADC 初始化配置"></a><strong>1.ADC 初始化配置</strong></h4><p><strong>初始化步骤：</strong></p>
<ol>
<li><p><strong>使能GPIO时钟并配置GPIO口：</strong></p>
<ul>
<li>使能GPIOC的时钟。</li>
<li>将PC2配置为模拟输入模式，速度为10MHz。</li>
</ul>
</li>
<li><p><strong>配置ADC部分：</strong></p>
<ul>
<li>使能ADC0的时钟。</li>
<li>设置ADC时钟分频系数为6分频，得到20MHz的ADC时钟。</li>
<li>设置ADC为独立模式，不与其他ADC协同工作。</li>
<li>配置ADC为单次转换模式，每次转换需要外部触发。</li>
<li>设置数据对齐为右对齐。</li>
<li>设置转换通道的个数为1。</li>
<li>配置转换通道为12，并放在序列寄存器的第0序列位置，采样时间为239.5个周期。</li>
<li>选择软件触发作为外部触发源，并使能外部触发。</li>
<li>使能ADC。</li>
<li>进行内部校准，延时50微秒后启动校准。</li>
</ul>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190036385.png" alt="image-20241201173325251"></p>
<p>以下是参考代码，用于初始化GPIO和ADC，并实现获取ADC值及测试函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f30x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* GPIO初始化 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">GPIOInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    rcu_periph_clock_enable(RCU_GPIOC);</span><br><span class="line">    gpio_init(GPIOC, GPIO_MODE_AIN, GPIO_OSPEED_10MHZ, GPIO_PIN_2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ADC初始化 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ADCInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 使能ADC时钟 */</span></span><br><span class="line">    rcu_periph_clock_enable(RCU_ADC0);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置ADC时钟分频系数为6分频（120MHz / 6 = 20MHz） */</span></span><br><span class="line">    rcu_adc_clock_config(RCU_CKADC_CKAPB2_DIV6);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置ADC为独立模式 */</span></span><br><span class="line">    adc_mode_config(ADC_MODE_FREE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置ADC为单次转换模式 */</span></span><br><span class="line">    adc_special_function_config(ADC0, ADC_CONTINUOUS_MODE, DISABLE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置数据对齐为右对齐 */</span></span><br><span class="line">    adc_data_alignment_config(ADC0, ADC_DATAALIGN_RIGHT);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置转换通道个数为1 */</span></span><br><span class="line">    adc_channel_length_config(ADC0, ADC_REGULAR_CHANNEL, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置转换通道12，放在序列寄存器的第0序列，采样时间239.5个周期 */</span></span><br><span class="line">    adc_regular_channel_config(ADC0, <span class="number">0</span>, ADC_CHANNEL_12, ADC_SAMPLETIME_239POINT5);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 选择软件触发作为外部触发源 */</span></span><br><span class="line">    adc_external_trigger_source_config(ADC0, ADC_REGULAR_CHANNEL, ADC0_1_2_EXTTRIG_REGULAR_NONE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 使能外部触发 */</span></span><br><span class="line">    adc_external_trigger_config(ADC0, ADC_REGULAR_CHANNEL, ENABLE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 使能ADC */</span></span><br><span class="line">    adc_enable(ADC0);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 内部校准 */</span></span><br><span class="line">    DelayNus(<span class="number">50</span>);</span><br><span class="line">    adc_calibration_enable(ADC0);</span><br><span class="line">    adc_software_trigger_enable(ADC0, ADC_REGULAR_CHANNEL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief ADC硬件初始化</span></span><br><span class="line"><span class="comment">* @param</span></span><br><span class="line"><span class="comment">* @return </span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">VresInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIOInit();</span><br><span class="line">    ADCInit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取ADC值 */</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">GetAdcVal</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (!adc_flag_get(ADC0, ADC_FLAG_EOC));</span><br><span class="line">    <span class="keyword">return</span> adc_regular_data_read(ADC0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ADC测试函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">VresTest</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> AdcVal = GetAdcVal();</span><br><span class="line">    <span class="type">float</span> Voltage = (<span class="type">float</span>)AdcVal / <span class="number">4095</span> * <span class="number">3.3f</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;AdcVal = %d, Voltage = %.1f V.\n&quot;</span>, AdcVal, Voltage);</span><br><span class="line">    DelayNms(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-调试与问题解决"><a href="#2-调试与问题解决" class="headerlink" title="2.调试与问题解决"></a><strong>2.调试与问题解决</strong></h4><p>在编写和调试代码过程中，可能会遇到以下问题：</p>
<ol>
<li><p><strong>程序复位后只打印一次数据：</strong></p>
<ul>
<li>可能是因为没有正确调用回调函数或中断处理。</li>
<li>检查<code>system.c</code>中的定时器中断处理，确保回调函数指针不为空。</li>
</ul>
</li>
<li><p><strong>硬错误（Hard Fault）：</strong></p>
<ul>
<li>发生空指针引用，通常由于回调函数未正确初始化。</li>
<li>解决方法是在调用回调前加入空指针判断，例如：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (callback_ptr != <span class="literal">NULL</span>) </span><br><span class="line">&#123;</span><br><span class="line">    callback_ptr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>转换模式的调整：</strong></p>
<ul>
<li>初始实现为单次转换模式，每次获取ADC值都需要软件触发。</li>
<li>可扩展为连续转换模式，使得只需一次触发即可连续获取ADC值。</li>
</ul>
</li>
</ol>
<h4 id="3-实验与测试"><a href="#3-实验与测试" class="headerlink" title="3.实验与测试"></a><strong>3.实验与测试</strong></h4><p>将代码下载到开发板后，复位设备并观察串口打印的数据。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190037805.png" alt="QQ20241201-173721"></p>
<p>通过调节可调电阻的位置，可以看到ADC值和对应的电压值在0到3.3V之间变化。</p>
<h2 id="3-ADC多通道配合DMA转换"><a href="#3-ADC多通道配合DMA转换" class="headerlink" title="3.ADC多通道配合DMA转换"></a>3.ADC多通道配合DMA转换</h2><p>使用<strong>连续扫描模式</strong>，配合<strong>DMA</strong>（直接存储器访问）实现<strong>多通道的ADC转换</strong>。</p>
<h3 id="1-硬件连接-1"><a href="#1-硬件连接-1" class="headerlink" title="1.硬件连接"></a><strong>1.硬件连接</strong></h3><p>原理框图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190038454.png" alt="QQ20241201-174601"></p>
<blockquote>
<p><strong>转换通道选择：</strong></p>
<ul>
<li><p><strong>可调电阻</strong></p>
<ul>
<li>对应GPIO口：PC2</li>
<li>ADC通道编号：12</li>
</ul>
</li>
<li><p><strong>热敏电阻</strong></p>
<ul>
<li>对应GPIO口：PC3</li>
<li>ADC通道编号：13</li>
</ul>
</li>
</ul>
<p><strong>电源与电压范围：</strong></p>
<ul>
<li>供电电压：3.3V</li>
<li>电压范围：0V 到 3.3V</li>
</ul>
<p><strong>限流电阻说明：</strong></p>
<p>限流电阻不会用于分压。当将GPIO口配置为模拟输入模式时，GPIO口呈现高阻态，因此限流电阻不会分压。</p>
</blockquote>
<h3 id="2-代码实现-1"><a href="#2-代码实现-1" class="headerlink" title="2.代码实现"></a><strong>2.代码实现</strong></h3><h4 id="1-ADC-初始化配置-1"><a href="#1-ADC-初始化配置-1" class="headerlink" title="1.ADC 初始化配置"></a><strong>1.ADC 初始化配置</strong></h4><blockquote>
<p>与单次转换模式相比，连续扫描模式需要进行以下配置：</p>
<ol>
<li><p><strong>使能连续模式和扫描模式：</strong></p>
<ul>
<li>设置ADC为连续转换模式。</li>
<li>启用扫描模式，以支持多通道转换。</li>
</ul>
</li>
<li><p><strong>使能ADC的DMA功能：</strong></p>
<ul>
<li>通过DMA将转换结果自动搬移到内存数组中，减少CPU负担。</li>
</ul>
</li>
<li><p><strong>配置转换通道：</strong></p>
<ul>
<li>设置转换通道数量为2，分别为通道12和通道13。</li>
<li>配置每个通道在转换序列中的位置。</li>
</ul>
</li>
</ol>
</blockquote>
<h4 id="2-DMA-初始化配置"><a href="#2-DMA-初始化配置" class="headerlink" title="2.DMA 初始化配置"></a><strong>2.DMA 初始化配置</strong></h4><blockquote>
<p>DMA的初始化配置与之前讲解的串口配合DMA的方法基本相同，主要步骤如下：</p>
<ol>
<li><p><strong>使能DMA时钟并复位DMA通道：</strong></p>
<ul>
<li>使能对应DMA控制器的时钟。</li>
<li>复位DMA通道以确保配置的正确性。</li>
</ul>
</li>
<li><p><strong>配置DMA传输参数：</strong></p>
<ul>
<li><strong>传输方向：</strong> 外设到内存。</li>
<li><strong>源地址：</strong> ADC的数据寄存器地址。</li>
<li><strong>目的地址：</strong> 存放ADC转换结果的数组。</li>
<li><strong>数据传输位宽：</strong> 16位（由于ADC使用12位分辨率）。</li>
<li><strong>传输次数：</strong> 2次（对应两个通道）。</li>
<li><strong>循环模式：</strong> 使能循环模式，实现数据的循环搬移。</li>
</ul>
</li>
<li><p><strong>使能DMA通道：</strong></p>
<ul>
<li>启动DMA通道，使其开始工作。</li>
</ul>
</li>
</ol>
</blockquote>
<p>ADC多通道配合DMA转换配置框图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190037859.png" alt="image-20241201174501329"></p>
<p>以下是参考代码，用于初始化GPIO、ADC和DMA，并实现获取多通道ADC值及测试函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f30x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* GPIO初始化 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">GPIOInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    rcu_periph_clock_enable(RCU_GPIOC);</span><br><span class="line">    gpio_init(GPIOC, GPIO_MODE_AIN, GPIO_OSPEED_10MHZ, GPIO_PIN_2);</span><br><span class="line">    gpio_init(GPIOC, GPIO_MODE_AIN, GPIO_OSPEED_10MHZ, GPIO_PIN_3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ADC初始化 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ADCInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 使能ADC时钟 */</span></span><br><span class="line">    rcu_periph_clock_enable(RCU_ADC0);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置ADC时钟分频系数为6分频（120MHz / 6 = 20MHz） */</span></span><br><span class="line">    rcu_adc_clock_config(RCU_CKADC_CKAPB2_DIV6);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置ADC为独立模式 */</span></span><br><span class="line">    adc_mode_config(ADC_MODE_FREE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置ADC为连续转换模式 */</span></span><br><span class="line">    adc_special_function_config(ADC0, ADC_CONTINUOUS_MODE, ENABLE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置扫描模式 */</span></span><br><span class="line">    adc_special_function_config(ADC0, ADC_SCAN_MODE, ENABLE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置数据对齐为右对齐 */</span></span><br><span class="line">    adc_data_alignment_config(ADC0, ADC_DATAALIGN_RIGHT);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置转换通道个数为2 */</span></span><br><span class="line">    adc_channel_length_config(ADC0, ADC_REGULAR_CHANNEL, <span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置转换通道12，放在序列寄存器的第0序列，采样时间239.5个周期 */</span></span><br><span class="line">    adc_regular_channel_config(ADC0, <span class="number">0</span>, ADC_CHANNEL_12, ADC_SAMPLETIME_239POINT5);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置转换通道13，放在序列寄存器的第1序列，采样时间239.5个周期 */</span></span><br><span class="line">    adc_regular_channel_config(ADC0, <span class="number">1</span>, ADC_CHANNEL_13, ADC_SAMPLETIME_239POINT5);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 选择软件触发作为外部触发源 */</span></span><br><span class="line">    adc_external_trigger_source_config(ADC0, ADC_REGULAR_CHANNEL, ADC0_1_2_EXTTRIG_REGULAR_NONE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 使能外部触发 */</span></span><br><span class="line">    adc_external_trigger_config(ADC0, ADC_REGULAR_CHANNEL, ENABLE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 使能ADC的DMA功能 */</span></span><br><span class="line">    adc_dma_mode_enable(ADC0);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 使能ADC */</span></span><br><span class="line">    adc_enable(ADC0);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 内部校准 */</span></span><br><span class="line">    DelayNus(<span class="number">50</span>);</span><br><span class="line">    adc_calibration_enable(ADC0);</span><br><span class="line">    adc_software_trigger_enable(ADC0, ADC_REGULAR_CHANNEL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADC0_RDATA_ADDR    (ADC0 + 0x4C)</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint16_t</span> g_adcVal[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* DMA初始化 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">DMAInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 使能DMA时钟 */</span></span><br><span class="line">    rcu_periph_clock_enable(RCU_DMA0);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 复位DMA通道 */</span></span><br><span class="line">    dma_deinit(DMA0, DMA_CH0);</span><br><span class="line">    </span><br><span class="line">    dma_parameter_struct dmaStruct;</span><br><span class="line">    dma_struct_para_init(&amp;dmaStruct);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置传输方向：外设到内存 */</span></span><br><span class="line">    dmaStruct.direction = DMA_PERIPHERAL_TO_MEMORY;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置数据源地址 */</span></span><br><span class="line">    dmaStruct.periph_addr = ADC0_RDATA_ADDR;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置源地址不递增 */</span></span><br><span class="line">    dmaStruct.periph_inc = DMA_PERIPH_INCREASE_DISABLE;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置源数据传输位宽为16位 */</span></span><br><span class="line">    dmaStruct.periph_width = DMA_PERIPHERAL_WIDTH_16BIT;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置数据目的地址 */</span></span><br><span class="line">    dmaStruct.memory_addr = (<span class="type">uint32_t</span>)g_adcVal;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置目的地址递增 */</span></span><br><span class="line">    dmaStruct.memory_inc = DMA_MEMORY_INCREASE_ENABLE;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置目的数据传输位宽为16位 */</span></span><br><span class="line">    dmaStruct.memory_width = DMA_MEMORY_WIDTH_16BIT;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置数据传输最大次数为2 */</span></span><br><span class="line">    dmaStruct.number = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置DMA通道优先级为高 */</span></span><br><span class="line">    dmaStruct.priority = DMA_PRIORITY_HIGH;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 初始化DMA通道 */</span></span><br><span class="line">    dma_init(DMA0, DMA_CH0, &amp;dmaStruct);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 使能DMA循环模式搬移数据 */</span></span><br><span class="line">    dma_circulation_enable(DMA0, DMA_CH0);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 使能DMA通道 */</span></span><br><span class="line">    dma_channel_enable(DMA0, DMA_CH0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief ADC硬件初始化</span></span><br><span class="line"><span class="comment">* @param</span></span><br><span class="line"><span class="comment">* @return </span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">VresInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIOInit();</span><br><span class="line">    ADCInit();</span><br><span class="line">    DMAInit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ADC测试函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">VresTest</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;CH12 AdcVal = %d.\n&quot;</span>, g_adcVal[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;CH13 AdcVal = %d.\n&quot;</span>, g_adcVal[<span class="number">1</span>]);</span><br><span class="line">    DelayNms(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-调试与问题解决"><a href="#3-调试与问题解决" class="headerlink" title="3.调试与问题解决"></a><strong>3.调试与问题解决</strong></h4><blockquote>
<p>在编写和调试代码过程中，可能会遇到以下问题：</p>
<ol>
<li><p><strong>数据未正确搬移到内存数组：</strong></p>
<ul>
<li><strong>原因：</strong> DMA配置不正确或DMA未使能。</li>
<li><strong>解决方法：</strong> 检查DMA初始化配置，确保DMA通道已使能并配置为循环模式。</li>
</ul>
</li>
<li><p><strong>硬错误（Hard Fault）：</strong></p>
<ul>
<li><strong>原因：</strong> DMA传输地址配置错误，导致访问非法内存。</li>
<li><strong>解决方法：</strong> 确认DMA源地址和目的地址配置正确，确保目的数组已正确声明并分配足够内存。</li>
</ul>
</li>
<li><p><strong>ADC数据不更新或保持不变：</strong></p>
<ul>
<li><strong>原因：</strong> ADC未正确启动或DMA未正确配置。</li>
<li><strong>解决方法：</strong> 确认ADC已使能并开始转换，检查DMA是否正常工作。</li>
</ul>
</li>
<li><p><strong>CPU负担过重或系统响应缓慢：</strong></p>
<ul>
<li><strong>原因：</strong> 未使用DMA，手动读取ADC数据导致CPU负担增加。</li>
<li><strong>解决方法：</strong>使用DMA搬移数据，减少CPU的中断处理次数。</li>
</ul>
</li>
</ol>
</blockquote>
<h2 id="4-ADC硬件滤波和软件滤波"><a href="#4-ADC硬件滤波和软件滤波" class="headerlink" title="4.ADC硬件滤波和软件滤波"></a>4.ADC硬件滤波和软件滤波</h2><h3 id="1-硬件滤波原理与配置"><a href="#1-硬件滤波原理与配置" class="headerlink" title="1.硬件滤波原理与配置"></a><strong>1.硬件滤波原理与配置</strong></h3><blockquote>
<p><strong>过采样滤波原理：</strong></p>
<ul>
<li><strong>过采样单元</strong>通过多次采样并求和，随后进行右移操作，实现数据的平均滤波。</li>
<li><strong>配置参数：</strong><ul>
<li><strong>n</strong>：代表将多少次的结果求和。</li>
<li><strong>m</strong>：对应的是除法系数，即右移的次数。右移一次相当于除以二，右移两次相当于除以四，依此类推。</li>
</ul>
</li>
</ul>
<p><strong>实例配置：</strong></p>
<ul>
<li>配置为取16次的结果求和（n = 16）。</li>
<li>进行右移4次（m = 4），相当于除以16。</li>
</ul>
<p><strong>硬件滤波的优势：</strong></p>
<ul>
<li>减少CPU的负担，提升系统效率。</li>
<li>实现快速的硬件滤波，提升数据处理速度。</li>
</ul>
<p><strong>ADC 硬件滤波初始化配置：</strong></p>
<p>与之前的连续扫描模式和DMA配置相比，硬件滤波模式需要进行以下额外配置：</p>
<ol>
<li><p><strong>配置ADC为连续模式：</strong></p>
<ul>
<li>设置ADC为连续转换模式，只需一次触发即可连续进行转换。</li>
</ul>
</li>
<li><p><strong>配置硬件滤波参数：</strong></p>
<ul>
<li>设置过采样次数（n）和右移次数（m）。</li>
<li>例如，配置为16次求和，右移4次。</li>
</ul>
</li>
<li><p><strong>使能ADC的过采样模式：</strong></p>
<ul>
<li>启用ADC的过采样功能，以实现硬件滤波。</li>
</ul>
</li>
</ol>
</blockquote>
<h3 id="2-软件滤波算法"><a href="#2-软件滤波算法" class="headerlink" title="2.软件滤波算法"></a><strong>2.软件滤波算法</strong></h3><blockquote>
<p>在项目开发中，软件滤波算法常用于处理ADC采集的数据。以下介绍几种常用的软件滤波算法：</p>
<ol>
<li><p><strong>算术平均滤波法（Arithmetic Average Filter）：</strong></p>
<ul>
<li>取n个采样值进行算术平均运算。</li>
<li>简单易实现，但对极端值敏感。</li>
</ul>
</li>
<li><p><strong>中位值滤波法（Median Filter）：</strong></p>
<ul>
<li>连续采样n次，将n次采样值按大小排序，取中间值作为有效值。</li>
<li>对极端值有较好的抑制效果，适用于去除脉冲干扰。</li>
</ul>
</li>
<li><p><strong>中位值平均滤波法（Median Average Filter）：</strong></p>
<ul>
<li>连续采样n个数据，去掉一个最大值和一个最小值，然后计算剩余n-2个数据的算术平均值。</li>
<li>兼具算术平均和中位值滤波的优点，既能去除极端值，又能平滑数据。</li>
</ul>
</li>
</ol>
</blockquote>
<h3 id="3-代码实现-1"><a href="#3-代码实现-1" class="headerlink" title="3.代码实现"></a><strong>3.代码实现</strong></h3><p>以下是参考代码，用于初始化GPIO和ADC，并实现ADC硬件滤波功能及测试函数：</p>
<h4 id="1-硬件滤波代码"><a href="#1-硬件滤波代码" class="headerlink" title="1.硬件滤波代码"></a><strong>1.硬件滤波代码</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f30x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* GPIO初始化 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">GPIOInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    rcu_periph_clock_enable(RCU_GPIOC);</span><br><span class="line">    gpio_init(GPIOC, GPIO_MODE_AIN, GPIO_OSPEED_10MHZ, GPIO_PIN_2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ADC初始化 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ADCInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 使能ADC时钟 */</span></span><br><span class="line">    rcu_periph_clock_enable(RCU_ADC0);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置ADC时钟分频系数为6分频（120MHz / 6 = 20MHz） */</span></span><br><span class="line">    rcu_adc_clock_config(RCU_CKADC_CKAPB2_DIV6);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置ADC为独立模式 */</span></span><br><span class="line">    adc_mode_config(ADC_MODE_FREE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置连续转换模式 */</span></span><br><span class="line">    adc_special_function_config(ADC0, ADC_CONTINUOUS_MODE, ENABLE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置数据对齐为右对齐 */</span></span><br><span class="line">    adc_data_alignment_config(ADC0, ADC_DATAALIGN_RIGHT);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置转换通道个数为1 */</span></span><br><span class="line">    adc_channel_length_config(ADC0, ADC_REGULAR_CHANNEL, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置转换通道12，放在序列寄存器的第0序列，采样时间239.5个周期 */</span></span><br><span class="line">    adc_regular_channel_config(ADC0, <span class="number">0</span>, ADC_CHANNEL_12, ADC_SAMPLETIME_239POINT5);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 选择软件触发作为外部触发源 */</span></span><br><span class="line">    adc_external_trigger_source_config(ADC0, ADC_REGULAR_CHANNEL, ADC0_1_2_EXTTRIG_REGULAR_NONE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 使能外部触发 */</span></span><br><span class="line">    adc_external_trigger_config(ADC0, ADC_REGULAR_CHANNEL, ENABLE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置硬件滤波 */</span></span><br><span class="line">    adc_oversample_mode_config(ADC0, ADC_OVERSAMPLING_ALL_CONVERT, ADC_OVERSAMPLING_SHIFT_4B, ADC_OVERSAMPLING_RATIO_MUL16);</span><br><span class="line">    adc_oversample_mode_enable(ADC0);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 使能ADC */</span></span><br><span class="line">    adc_enable(ADC0);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 内部校准 */</span></span><br><span class="line">    DelayNus(<span class="number">50</span>);</span><br><span class="line">    adc_calibration_enable(ADC0);</span><br><span class="line">    adc_software_trigger_enable(ADC0, ADC_REGULAR_CHANNEL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief ADC硬件初始化</span></span><br><span class="line"><span class="comment">* @param</span></span><br><span class="line"><span class="comment">* @return </span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">VresInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIOInit();</span><br><span class="line">    ADCInit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">GetAdcVal</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (!adc_flag_get(ADC0, ADC_FLAG_EOC));</span><br><span class="line">    <span class="keyword">return</span> adc_regular_data_read(ADC0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">VresTest</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> AdcVal = GetAdcVal();</span><br><span class="line">    <span class="type">float</span> Voltage = (<span class="type">float</span>)AdcVal / <span class="number">4095</span> * <span class="number">3.3f</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;AdcVal = %d, Voltage = %.1f V.\n&quot;</span>, AdcVal, Voltage);</span><br><span class="line">    DelayNms(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-软件滤波代码："><a href="#2-软件滤波代码：" class="headerlink" title="2.软件滤波代码："></a><strong>2.软件滤波代码：</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f30x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADC0_RDATA_ADDR    (ADC0 + 0x4C)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BUF_SIZE        10</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint16_t</span> g_adcVal[MAX_BUF_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* GPIO初始化 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">GPIOInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    rcu_periph_clock_enable(RCU_GPIOC);</span><br><span class="line">    gpio_init(GPIOC, GPIO_MODE_AIN, GPIO_OSPEED_10MHZ, GPIO_PIN_2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ADC初始化 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ADCInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 使能ADC时钟 */</span></span><br><span class="line">    rcu_periph_clock_enable(RCU_ADC0);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置ADC时钟分频系数为6分频（120MHz / 6 = 20MHz） */</span></span><br><span class="line">    rcu_adc_clock_config(RCU_CKADC_CKAPB2_DIV6);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置ADC为独立模式 */</span></span><br><span class="line">    adc_mode_config(ADC_MODE_FREE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置连续转换模式 */</span></span><br><span class="line">    adc_special_function_config(ADC0, ADC_CONTINUOUS_MODE, ENABLE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置扫描模式 */</span></span><br><span class="line">    adc_special_function_config(ADC0, ADC_SCAN_MODE, ENABLE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置数据对齐为右对齐 */</span></span><br><span class="line">    adc_data_alignment_config(ADC0, ADC_DATAALIGN_RIGHT);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置转换通道个数为1 */</span></span><br><span class="line">    adc_channel_length_config(ADC0, ADC_REGULAR_CHANNEL, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置转换通道12，放在序列寄存器的第0序列，采样时间239.5个周期 */</span></span><br><span class="line">    adc_regular_channel_config(ADC0, <span class="number">0</span>, ADC_CHANNEL_12, ADC_SAMPLETIME_239POINT5);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 选择软件触发作为外部触发源 */</span></span><br><span class="line">    adc_external_trigger_source_config(ADC0, ADC_REGULAR_CHANNEL, ADC0_1_2_EXTTRIG_REGULAR_NONE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 使能外部触发 */</span></span><br><span class="line">    adc_external_trigger_config(ADC0, ADC_REGULAR_CHANNEL, ENABLE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 使能ADC的DMA功能 */</span></span><br><span class="line">    adc_dma_mode_enable(ADC0);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 使能ADC */</span></span><br><span class="line">    adc_enable(ADC0);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 内部校准 */</span></span><br><span class="line">    DelayNus(<span class="number">50</span>);</span><br><span class="line">    adc_calibration_enable(ADC0);</span><br><span class="line">    adc_software_trigger_enable(ADC0, ADC_REGULAR_CHANNEL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* DMA初始化 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">DMAInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 使能DMA时钟 */</span></span><br><span class="line">    rcu_periph_clock_enable(RCU_DMA0);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 复位DMA通道 */</span></span><br><span class="line">    dma_deinit(DMA0, DMA_CH0);</span><br><span class="line">    </span><br><span class="line">    dma_parameter_struct dmaStruct;</span><br><span class="line">    dma_struct_para_init(&amp;dmaStruct);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置传输方向：外设到内存 */</span></span><br><span class="line">    dmaStruct.direction = DMA_PERIPHERAL_TO_MEMORY;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置数据源地址 */</span></span><br><span class="line">    dmaStruct.periph_addr = ADC0_RDATA_ADDR;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置源地址不递增 */</span></span><br><span class="line">    dmaStruct.periph_inc = DMA_PERIPH_INCREASE_DISABLE;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置源数据传输位宽为16位 */</span></span><br><span class="line">    dmaStruct.periph_width = DMA_PERIPHERAL_WIDTH_16BIT;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置数据目的地址 */</span></span><br><span class="line">    dmaStruct.memory_addr = (<span class="type">uint32_t</span>)g_adcVal;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置目的地址递增 */</span></span><br><span class="line">    dmaStruct.memory_inc = DMA_MEMORY_INCREASE_ENABLE;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置目的数据传输位宽为16位 */</span></span><br><span class="line">    dmaStruct.memory_width = DMA_MEMORY_WIDTH_16BIT;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置数据传输最大次数为MAX_BUF_SIZE */</span></span><br><span class="line">    dmaStruct.number = MAX_BUF_SIZE;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置DMA通道优先级为高 */</span></span><br><span class="line">    dmaStruct.priority = DMA_PRIORITY_HIGH;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 初始化DMA通道 */</span></span><br><span class="line">    dma_init(DMA0, DMA_CH0, &amp;dmaStruct);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 使能DMA循环模式搬移数据 */</span></span><br><span class="line">    dma_circulation_enable(DMA0, DMA_CH0);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 使能DMA通道 */</span></span><br><span class="line">    dma_channel_enable(DMA0, DMA_CH0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief ADC硬件初始化</span></span><br><span class="line"><span class="comment">* @param</span></span><br><span class="line"><span class="comment">* @return </span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">VresInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIOInit();</span><br><span class="line">    ADCInit();</span><br><span class="line">    DMAInit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 算术平均滤波函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint16_t</span> <span class="title function_">ArithAvgFltr</span><span class="params">(<span class="type">uint16_t</span> *arr, <span class="type">uint32_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">uint16_t</span>)(sum / len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">VresTest</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> buf[MAX_BUF_SIZE];</span><br><span class="line">    <span class="built_in">memcpy</span>(buf, g_adcVal, <span class="keyword">sizeof</span>(<span class="type">uint16_t</span>) * MAX_BUF_SIZE);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint8_t</span> i = <span class="number">0</span>; i &lt; MAX_BUF_SIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;AdcVal[%d] = %d.\n&quot;</span>, i, buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> res = ArithAvgFltr(buf, MAX_BUF_SIZE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;res = %d.\n&quot;</span>, res);</span><br><span class="line">    DelayNms(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-调试与问题解决-1"><a href="#3-调试与问题解决-1" class="headerlink" title="3.调试与问题解决"></a><strong>3.调试与问题解决</strong></h4><blockquote>
<p>在实现和调试ADC滤波功能时，可能会遇到以下问题：</p>
<ol>
<li><p><strong>ADC数据不更新或保持不变：</strong></p>
<ul>
<li><strong>原因：</strong> ADC未正确启动或DMA未正确配置。</li>
<li><strong>解决方法：</strong> 确认ADC已使能并开始转换，检查DMA配置是否正确，确保DMA通道已使能。</li>
</ul>
</li>
<li><p><strong>硬错误（Hard Fault）：</strong></p>
<ul>
<li><strong>原因：</strong> DMA传输地址配置错误，导致访问非法内存。</li>
<li><strong>解决方法：</strong> 确认DMA源地址和目的地址配置正确，确保目的数组已正确声明并分配足够内存。</li>
</ul>
</li>
<li><p><strong>滤波结果不准确：</strong></p>
<ul>
<li><strong>原因：</strong> 过采样参数配置不当，或滤波算法实现有误。</li>
<li><strong>解决方法：</strong> 检查过采样次数和右移次数的配置，确保滤波算法逻辑正确。</li>
</ul>
</li>
<li><p><strong>CPU负担过重或系统响应缓慢：</strong></p>
<ul>
<li><strong>原因：</strong> 未使用DMA，手动读取ADC数据导致CPU负担增加。</li>
<li><strong>解决方法：</strong> 使用DMA搬移数据，减少CPU的中断处理次数。</li>
</ul>
</li>
</ol>
</blockquote>
<h2 id="5-快速排序的使用方法"><a href="#5-快速排序的使用方法" class="headerlink" title="5.快速排序的使用方法"></a>5.快速排序的使用方法</h2><h3 id="快速排序概述"><a href="#快速排序概述" class="headerlink" title="快速排序概述"></a><strong>快速排序概述</strong></h3><blockquote>
<p><strong>快速排序（Quick Sort）</strong>是一种高效的排序算法，采用分治策略，通过一个基准元素将数组分成两部分，递归地排序这两部分。相比<strong>冒泡排序法</strong>，快速排序具有以下优势：</p>
<ul>
<li><strong>更高的性能</strong>：平均时间复杂度为O(n log n)，而冒泡排序为O(n²)。</li>
<li><strong>更灵活</strong>：C标准库提供了快速排序的接口函数<code>qsort</code>，简化了排序过程。</li>
</ul>
<p><strong>快速排序优点</strong></p>
<ul>
<li><strong>灵活性</strong>：<code>qsort</code>函数允许用户自定义排序规则，通过函数指针实现升序或降序排序。</li>
<li><strong>性能优越</strong>：快速排序在大多数情况下比冒泡排序更快，适用于需要高效排序的应用场景。</li>
</ul>
</blockquote>
<h3 id="qsort函数简介"><a href="#qsort函数简介" class="headerlink" title="qsort函数简介"></a><strong><code>qsort</code>函数简介</strong></h3><blockquote>
<p>在C标准库中，<code>qsort</code>函数用于对数组进行排序。其函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">qsort</span><span class="params">(<span class="type">void</span> *base, <span class="type">size_t</span> nmemb, <span class="type">size_t</span> size, <span class="type">int</span> (*compar)(<span class="type">const</span> <span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *))</span>;</span><br></pre></td></tr></table></figure>
<p><strong>参数说明：</strong></p>
<ol>
<li><strong><code>base</code></strong>：指向要排序的数组的首地址。</li>
<li><strong><code>nmemb</code></strong>：数组中元素的个数。</li>
<li><strong><code>size</code></strong>：数组中每个元素所占用的内存空间大小（通常使用<code>sizeof</code>运算符计算）。</li>
<li><strong><code>compar</code></strong>：指向比较函数的指针，用于定义排序规则（升序或降序）。</li>
</ol>
<p><strong>比较函数的定义：</strong></p>
<p>比较函数必须符合以下签名：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">compar</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span>;</span><br></pre></td></tr></table></figure>
<p><strong>返回值：</strong></p>
<ul>
<li><strong>负值</strong>：如果<code>*a</code>小于<code>*b</code>。</li>
<li><strong>零</strong>：如果<code>*a</code>等于<code>*b</code>。</li>
<li><strong>正值</strong>：如果<code>*a</code>大于<code>*b</code>（升序）。</li>
</ul>
<p>通过调整比较函数的返回值，可以实现升序或降序排序。</p>
</blockquote>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h3><p>以下是一个使用<code>qsort</code>对<code>uint16_t</code>类型数组和结构体数组进行排序的示例代码。</p>
<h4 id="1-排序整数数组"><a href="#1-排序整数数组" class="headerlink" title="1. 排序整数数组"></a><strong>1. 排序整数数组</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led_drv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key_drv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;systick.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usb2com_drv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rtc_drv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vres_drv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usb2com_app.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hmi_app.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">DrvInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    DelayInit();</span><br><span class="line">    LedInit();</span><br><span class="line">    KeyInit();</span><br><span class="line">    Usb2ComInit();</span><br><span class="line">    RtcInit();</span><br><span class="line">    VresInit();</span><br><span class="line">    SystickInit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> id;</span><br><span class="line">    <span class="type">uint8_t</span> score;</span><br><span class="line">&#125; StuInfo_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 整数数组比较函数（降序） */</span></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">CmpCb</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *_a, <span class="type">const</span> <span class="type">void</span> *_b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> *a = (<span class="type">uint16_t</span> *)_a;</span><br><span class="line">    <span class="type">uint16_t</span> *b = (<span class="type">uint16_t</span> *)_b;</span><br><span class="line">    <span class="keyword">if</span> (*a &gt; *b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*a &lt; *b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 结构体数组比较函数（降序） */</span></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">StuCmpCb</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *_a, <span class="type">const</span> <span class="type">void</span> *_b)</span></span><br><span class="line">&#123;</span><br><span class="line">    StuInfo_t *a = (StuInfo_t *)_a;</span><br><span class="line">    StuInfo_t *b = (StuInfo_t *)_b;</span><br><span class="line">    <span class="keyword">if</span> (a-&gt;score &gt; b-&gt;score)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a-&gt;score &lt; b-&gt;score)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;	</span><br><span class="line">    DrvInit();</span><br><span class="line">    <span class="type">uint16_t</span> num[<span class="number">10</span>] = &#123;<span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">26</span>, <span class="number">52</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">14</span>, <span class="number">56</span>&#125;;</span><br><span class="line">    <span class="type">uint16_t</span> sz = <span class="keyword">sizeof</span>(num) / <span class="keyword">sizeof</span>(num[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 使用qsort对整数数组进行降序排序 */</span></span><br><span class="line">    qsort(num, sz, <span class="keyword">sizeof</span>(num[<span class="number">0</span>]), CmpCb);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint8_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;num[%d] = %d.\n&quot;</span>, i, num[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 定义并初始化结构体数组 */</span></span><br><span class="line">    StuInfo_t stuInfo[<span class="number">5</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">90</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="number">65</span>&#125;,</span><br><span class="line">        &#123;<span class="number">3</span>, <span class="number">80</span>&#125;,</span><br><span class="line">        &#123;<span class="number">4</span>, <span class="number">75</span>&#125;,</span><br><span class="line">        &#123;<span class="number">5</span>, <span class="number">70</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 使用qsort对结构体数组进行降序排序 */</span></span><br><span class="line">    qsort(stuInfo, <span class="number">5</span>, <span class="keyword">sizeof</span>(stuInfo[<span class="number">0</span>]), StuCmpCb);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint8_t</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;student id = %d, score = %d.\n&quot;</span>, stuInfo[i].id, stuInfo[i].score);</span><br><span class="line">    &#125;	</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-排序结构体数组"><a href="#2-排序结构体数组" class="headerlink" title="2. 排序结构体数组"></a><strong>2. 排序结构体数组</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;systick.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usb2com_drv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rtc_drv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vres_drv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usb2com_app.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">DrvInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    DelayInit();</span><br><span class="line">    LedInit();</span><br><span class="line">    KeyInit();</span><br><span class="line">    Usb2ComInit();</span><br><span class="line">    RtcInit();</span><br><span class="line">    VresInit();</span><br><span class="line">    SystickInit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> id;</span><br><span class="line">    <span class="type">uint8_t</span> score;</span><br><span class="line">&#125; StuInfo_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 结构体数组比较函数（降序） */</span></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">StuCmpCb</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *_a, <span class="type">const</span> <span class="type">void</span> *_b)</span></span><br><span class="line">&#123;</span><br><span class="line">    StuInfo_t *a = (StuInfo_t *)_a;</span><br><span class="line">    StuInfo_t *b = (StuInfo_t *)_b;</span><br><span class="line">    <span class="keyword">if</span> (a-&gt;score &gt; b-&gt;score)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a-&gt;score &lt; b-&gt;score)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;	</span><br><span class="line">    DrvInit();</span><br><span class="line">    <span class="type">uint16_t</span> num[<span class="number">10</span>] = &#123;<span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">26</span>, <span class="number">52</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">14</span>, <span class="number">56</span>&#125;;</span><br><span class="line">    <span class="type">uint16_t</span> sz = <span class="keyword">sizeof</span>(num) / <span class="keyword">sizeof</span>(num[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 使用qsort对整数数组进行降序排序 */</span></span><br><span class="line">    qsort(num, sz, <span class="keyword">sizeof</span>(num[<span class="number">0</span>]), CmpCb);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint8_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;num[%d] = %d.\n&quot;</span>, i, num[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 定义并初始化结构体数组 */</span></span><br><span class="line">    StuInfo_t stuInfo[<span class="number">5</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">90</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="number">65</span>&#125;,</span><br><span class="line">        &#123;<span class="number">3</span>, <span class="number">80</span>&#125;,</span><br><span class="line">        &#123;<span class="number">4</span>, <span class="number">75</span>&#125;,</span><br><span class="line">        &#123;<span class="number">5</span>, <span class="number">70</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 使用qsort对结构体数组进行降序排序 */</span></span><br><span class="line">    qsort(stuInfo, <span class="number">5</span>, <span class="keyword">sizeof</span>(stuInfo[<span class="number">0</span>]), StuCmpCb);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint8_t</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;student id = %d, score = %d.\n&quot;</span>, stuInfo[i].id, stuInfo[i].score);</span><br><span class="line">    &#125;	</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码讲解"><a href="#代码讲解" class="headerlink" title="代码讲解"></a><strong>代码讲解</strong></h3><h4 id="1-排序整数数组-1"><a href="#1-排序整数数组-1" class="headerlink" title="1. 排序整数数组"></a><strong>1. 排序整数数组</strong></h4><blockquote>
<p>在本例中，我们定义了一个<code>uint16_t</code>类型的数组<code>num</code>，包含10个元素。通过调用<code>qsort</code>函数，对该数组进行降序排序。</p>
<p><strong>关键步骤：</strong></p>
<ol>
<li><p><strong>定义比较函数<code>CmpCb</code></strong>：</p>
<ul>
<li>接受两个<code>const void *</code>类型的指针，分别指向数组中的两个元素。</li>
<li>将其转换为<code>uint16_t *</code>类型。</li>
<li>比较两个数的大小，返回<code>-1</code>（如果第一个数大于第二个数）、<code>1</code>（如果第一个数小于第二个数）或<code>0</code>（相等）。</li>
<li>该实现实现了<strong>降序排序</strong>。</li>
</ul>
</li>
<li><p><strong>调用<code>qsort</code>函数</strong>：</p>
<ul>
<li><strong>第一个参数</strong>：数组<code>num</code>的首地址。</li>
<li><strong>第二个参数</strong>：数组元素的个数（10）。</li>
<li><strong>第三个参数</strong>：数组元素所占用的内存空间大小（<code>sizeof(num[0])</code>）。</li>
<li><strong>第四个参数</strong>：比较函数的指针（<code>CmpCb</code>）。</li>
</ul>
</li>
<li><p><strong>打印排序后的数组</strong>：</p>
<ul>
<li>使用<code>for</code>循环遍历数组，并通过<code>printf</code>函数打印每个元素的值。</li>
</ul>
</li>
</ol>
<p><strong>输出结果示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">num[<span class="number">0</span>] = <span class="number">56.</span></span><br><span class="line">num[<span class="number">1</span>] = <span class="number">52.</span></span><br><span class="line">num[<span class="number">2</span>] = <span class="number">26.</span></span><br><span class="line">num[<span class="number">3</span>] = <span class="number">14.</span></span><br><span class="line">num[<span class="number">4</span>] = <span class="number">9.</span></span><br><span class="line">num[<span class="number">5</span>] = <span class="number">8.</span></span><br><span class="line">num[<span class="number">6</span>] = <span class="number">7.</span></span><br><span class="line">num[<span class="number">7</span>] = <span class="number">5.</span></span><br><span class="line">num[<span class="number">8</span>] = <span class="number">3.</span></span><br><span class="line">num[<span class="number">9</span>] = <span class="number">1.</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="2-排序结构体数组-1"><a href="#2-排序结构体数组-1" class="headerlink" title="2. 排序结构体数组"></a><strong>2. 排序结构体数组</strong></h4><blockquote>
<p>我们定义了一个结构体<code>StuInfo_t</code>，包含<code>id</code>和<code>score</code>两个成员，用于表示学生的相关信息。通过<code>qsort</code>函数，对结构体数组<code>stuInfo</code>进行降序排序，基于学生的分数。</p>
<p><strong>关键步骤：</strong></p>
<ol>
<li><p><strong>定义比较函数<code>StuCmpCb</code></strong>：</p>
<ul>
<li>接受两个<code>const void *</code>类型的指针，分别指向结构体数组中的两个元素。</li>
<li>将其转换为<code>StuInfo_t *</code>类型。</li>
<li>比较两个学生的分数，返回<code>-1</code>（如果第一个学生的分数高于第二个学生）、<code>1</code>（如果第一个学生的分数低于第二个学生）或<code>0</code>（相等）。</li>
<li>该实现实现了<strong>基于分数的降序排序</strong>。</li>
</ul>
</li>
<li><p><strong>调用<code>qsort</code>函数</strong>：</p>
<ul>
<li><strong>第一个参数</strong>：结构体数组<code>stuInfo</code>的首地址。</li>
<li><strong>第二个参数</strong>：结构体数组元素的个数（5）。</li>
<li><strong>第三个参数</strong>：结构体数组元素所占用的内存空间大小（<code>sizeof(stuInfo[0])</code>）。</li>
<li><strong>第四个参数</strong>：比较函数的指针（<code>StuCmpCb</code>）。</li>
</ul>
</li>
<li><p><strong>打印排序后的结构体数组</strong>：</p>
<ul>
<li>使用<code>for</code>循环遍历结构体数组，并通过<code>printf</code>函数打印每个学生的<code>id</code>和<code>score</code>。</li>
</ul>
</li>
</ol>
<p><strong>输出结果示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">student id = <span class="number">1</span>, score = <span class="number">90.</span></span><br><span class="line">student id = <span class="number">3</span>, score = <span class="number">80.</span></span><br><span class="line">student id = <span class="number">4</span>, score = <span class="number">75.</span></span><br><span class="line">student id = <span class="number">5</span>, score = <span class="number">70.</span></span><br><span class="line">student id = <span class="number">2</span>, score = <span class="number">65.</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="6-二分查找法"><a href="#6-二分查找法" class="headerlink" title="6.二分查找法"></a>6.二分查找法</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h3><blockquote>
<p><strong>二分查找法</strong>，也称为<strong>折半查找法</strong>，是一种在有序数组中查找某个目标值是否存在的算法。其主要优势在于相较于<strong>顺序查找</strong>（线性查找），二分查找法能够显著降低查找的时间复杂度。</p>
<h4 id="1-时间复杂度"><a href="#1-时间复杂度" class="headerlink" title="1. 时间复杂度"></a><strong>1. 时间复杂度</strong></h4><ul>
<li><strong>顺序查找</strong>的时间复杂度为O(n)，其中n是数组的元素个数。</li>
<li><strong>二分查找法</strong>的时间复杂度为O(log₂n)，大大提高了查找效率。</li>
</ul>
<p><strong>示例</strong>：</p>
<p>假设数组中有8个元素：</p>
<ul>
<li>顺序查找最多需要8次比较。</li>
<li>二分查找只需要3次比较（因为2³ = 8）。</li>
</ul>
<h4 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2. 应用场景"></a><strong>2. 应用场景</strong></h4><ul>
<li>适用于<strong>有序数组</strong>。</li>
<li>需要快速查找元素的场景，如查找温度传感器的校准值、配置表等。</li>
</ul>
</blockquote>
<h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a><strong>基本原理</strong></h3><blockquote>
<p>二分查找法通过不断将查找范围分成两半，逐步缩小查找区间，直至找到目标值或确定目标值不存在。</p>
<p><strong>步骤</strong>：</p>
<ol>
<li><strong>初始化</strong>：<ul>
<li><strong>左下标（left）</strong>：指向数组的起始位置，通常为0。</li>
<li><strong>右下标（right）</strong>：指向数组的末尾位置，通常为数组长度减1。</li>
</ul>
</li>
<li><strong>循环查找</strong>：<ul>
<li><strong>计算中间下标（middle）</strong></li>
<li><strong>比较目标值与中间元素</strong></li>
</ul>
</li>
<li><strong>终止条件</strong>：<ul>
<li>当左下标超过右下标时，查找结束，目标值不存在于数组中。</li>
</ul>
</li>
</ol>
</blockquote>
<h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a><strong>实现细节</strong></h3><blockquote>
<p>在实现二分查找法时，需要注意以下几个关键点：</p>
<ol>
<li><p><strong>防止溢出</strong>：</p>
<ul>
<li>在计算中间下标时，使用 <code>mid = left + (right - left) / 2</code> 而不是 <code>mid = left + right  / 2</code>，以避免当 <code>left</code>和 <code>right</code> 都很大时发生整型溢出。</li>
</ul>
</li>
<li><p><strong>变量类型</strong>：</p>
<ul>
<li><code>left</code>、<code>right</code> 和 <code>middle</code> 应定义为<strong>有符号整型</strong>，如 <code>int</code> 或 <code>int32_t</code>，以处理可能出现的负值。</li>
</ul>
</li>
<li><p><strong>升序与降序</strong>：</p>
<ul>
<li>根据数组的排序顺序（升序或降序），调整比较逻辑以确保正确缩小查找范围。</li>
</ul>
</li>
<li><p><strong>查找接近目标值的元素</strong>：</p>
<ul>
<li>除了查找目标值是否存在，二分查找法还可用于查找最接近目标值的元素下标。</li>
</ul>
</li>
</ol>
</blockquote>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h3><p>以下是二分查找法在C语言中的实现，包括<strong>升序查找</strong>和<strong>降序查找</strong>，以及查找最接近目标值的函数。</p>
<h4 id="1-升序二分查找"><a href="#1-升序二分查找" class="headerlink" title="1. 升序二分查找"></a><strong>1. 升序二分查找</strong></h4><p><strong>函数说明</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 升序数组的二分查找函数</span></span><br><span class="line"><span class="comment"> * @param arr 有序数组的首地址</span></span><br><span class="line"><span class="comment"> * @param size 数组的大小</span></span><br><span class="line"><span class="comment"> * @param key 目标值</span></span><br><span class="line"><span class="comment"> * @return 目标值的下标，若未找到返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">AscBinarySearch</span><span class="params">(<span class="type">int32_t</span> *arr, <span class="type">int32_t</span> size, <span class="type">int32_t</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int32_t</span> left = <span class="number">0</span>;               <span class="comment">// 左下标</span></span><br><span class="line">    <span class="type">int32_t</span> right = size - <span class="number">1</span>;       <span class="comment">// 右下标</span></span><br><span class="line">    <span class="type">int32_t</span> mid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;         <span class="comment">// 循环条件</span></span><br><span class="line">        mid = left + (right - left) / <span class="number">2</span>;   <span class="comment">// 计算中间下标</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (key &lt; arr[mid]) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;        <span class="comment">// 目标值在左半部分</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; arr[mid]) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;         <span class="comment">// 目标值在右半部分</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;             <span class="comment">// 找到目标值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;                        <span class="comment">// 未找到目标值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-降序二分查找"><a href="#2-降序二分查找" class="headerlink" title="2. 降序二分查找"></a><strong>2. 降序二分查找</strong></h4><p><strong>函数说明</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 降序数组的二分查找函数</span></span><br><span class="line"><span class="comment"> * @param arr 有序数组的首地址</span></span><br><span class="line"><span class="comment"> * @param size 数组的大小</span></span><br><span class="line"><span class="comment"> * @param key 目标值</span></span><br><span class="line"><span class="comment"> * @return 目标值的下标，若未找到返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">DescBinarySearch</span><span class="params">(<span class="type">int32_t</span> *arr, <span class="type">int32_t</span> size, <span class="type">int32_t</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int32_t</span> left = <span class="number">0</span>;               <span class="comment">// 左下标</span></span><br><span class="line">    <span class="type">int32_t</span> right = size - <span class="number">1</span>;       <span class="comment">// 右下标</span></span><br><span class="line">    <span class="type">int32_t</span> mid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;         <span class="comment">// 循环条件</span></span><br><span class="line">        mid = left + (right - left) / <span class="number">2</span>;   <span class="comment">// 计算中间下标</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (key &gt; arr[mid]) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;        <span class="comment">// 目标值在左半部分</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; arr[mid]) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;         <span class="comment">// 目标值在右半部分</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;             <span class="comment">// 找到目标值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;                        <span class="comment">// 未找到目标值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-升序查找最接近目标值的元素下标"><a href="#3-升序查找最接近目标值的元素下标" class="headerlink" title="3. 升序查找最接近目标值的元素下标"></a><strong>3. 升序查找最接近目标值的元素下标</strong></h4><p><strong>函数说明</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 升序数组中查找最接近目标值的元素下标</span></span><br><span class="line"><span class="comment"> * @param arr 有序数组的首地址</span></span><br><span class="line"><span class="comment"> * @param size 数组的大小</span></span><br><span class="line"><span class="comment"> * @param key 目标值</span></span><br><span class="line"><span class="comment"> * @return 最接近目标值的元素下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">AscNear</span><span class="params">(<span class="type">int32_t</span> *arr, <span class="type">int32_t</span> size, <span class="type">int32_t</span> key)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int32_t</span> left = <span class="number">0</span>;               <span class="comment">// 左下标</span></span><br><span class="line">    <span class="type">int32_t</span> right = size - <span class="number">1</span>;       <span class="comment">// 右下标</span></span><br><span class="line">    <span class="type">int32_t</span> mid;</span><br><span class="line">    <span class="type">int32_t</span> index = size - <span class="number">1</span>;       <span class="comment">// 初始假设为最后一个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;          <span class="comment">// 循环条件</span></span><br><span class="line">        mid = left + (right - left) / <span class="number">2</span>;   <span class="comment">// 计算中间下标</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (key &lt;= arr[mid]) &#123;</span><br><span class="line">            index = mid;             <span class="comment">// 记录当前中间下标</span></span><br><span class="line">            right = mid - <span class="number">1</span>;         <span class="comment">// 目标值在左半部分</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;          <span class="comment">// 目标值在右半部分</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;                     <span class="comment">// 返回最接近目标值的元素下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-降序查找最接近目标值的元素下标"><a href="#4-降序查找最接近目标值的元素下标" class="headerlink" title="4. 降序查找最接近目标值的元素下标"></a><strong>4. 降序查找最接近目标值的元素下标</strong></h4><p><strong>函数说明</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 降序数组中查找最接近目标值的元素下标</span></span><br><span class="line"><span class="comment"> * @param arr 有序数组的首地址</span></span><br><span class="line"><span class="comment"> * @param size 数组的大小</span></span><br><span class="line"><span class="comment"> * @param key 目标值</span></span><br><span class="line"><span class="comment"> * @return 最接近目标值的元素下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">DescNear</span><span class="params">(<span class="type">int32_t</span> *arr, <span class="type">int32_t</span> size, <span class="type">int32_t</span> key)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int32_t</span> left = <span class="number">0</span>;               <span class="comment">// 左下标</span></span><br><span class="line">    <span class="type">int32_t</span> right = size - <span class="number">1</span>;       <span class="comment">// 右下标</span></span><br><span class="line">    <span class="type">int32_t</span> mid;</span><br><span class="line">    <span class="type">int32_t</span> index = size - <span class="number">1</span>;       <span class="comment">// 初始假设为最后一个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;          <span class="comment">// 循环条件</span></span><br><span class="line">        mid = left + (right - left) / <span class="number">2</span>;   <span class="comment">// 计算中间下标</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (key &gt;= arr[mid]) &#123;</span><br><span class="line">            index = mid;             <span class="comment">// 记录当前中间下标</span></span><br><span class="line">            right = mid - <span class="number">1</span>;         <span class="comment">// 目标值在左半部分</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;          <span class="comment">// 目标值在右半部分</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;                     <span class="comment">// 返回最接近目标值的元素下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码讲解-1"><a href="#代码讲解-1" class="headerlink" title="代码讲解"></a><strong>代码讲解</strong></h3><h4 id="1-升序二分查找-1"><a href="#1-升序二分查找-1" class="headerlink" title="1. 升序二分查找"></a><strong>1. 升序二分查找</strong></h4><p><strong>功能</strong>：在一个升序排列的数组中查找目标值的下标。</p>
<p><strong>函数</strong>：<code>AscBinarySearch</code></p>
<p><strong>逻辑</strong>：</p>
<ul>
<li>如果目标值小于中间元素，则在左半部分继续查找。</li>
<li>如果目标值大于中间元素，则在右半部分继续查找。</li>
<li>如果等于中间元素，则返回该元素的下标。</li>
<li>若查找范围为空，返回-1。</li>
</ul>
<p><strong>示例</strong>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int32_t</span> arr[<span class="number">6</span>] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">20</span>&#125;;</span><br><span class="line"><span class="type">int32_t</span> index = AscBinarySearch(arr, <span class="number">6</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;20 的下标 = %d。\n&quot;</span>, index);  <span class="comment">// 输出: 5</span></span><br></pre></td></tr></table></figure></p>
<h4 id="2-降序二分查找-1"><a href="#2-降序二分查找-1" class="headerlink" title="2. 降序二分查找"></a><strong>2. 降序二分查找</strong></h4><p><strong>功能</strong>：在一个降序排列的数组中查找目标值的下标。</p>
<p><strong>函数</strong>：<code>DescBinarySearch</code></p>
<p><strong>逻辑</strong>：</p>
<ul>
<li>如果目标值大于中间元素，则在左半部分继续查找。</li>
<li>如果目标值小于中间元素，则在右半部分继续查找。</li>
<li>如果等于中间元素，则返回该元素的下标。</li>
<li>若查找范围为空，返回-1。</li>
</ul>
<p><strong>示例</strong>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int32_t</span> arr2[<span class="number">6</span>] = &#123;<span class="number">20</span>, <span class="number">14</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int32_t</span> index = DescBinarySearch(arr2, <span class="number">6</span>, <span class="number">20</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;20 的下标 = %d。\n&quot;</span>, index);  <span class="comment">// 输出: 0</span></span><br></pre></td></tr></table></figure></p>
<h4 id="3-升序查找最接近目标值的元素下标-1"><a href="#3-升序查找最接近目标值的元素下标-1" class="headerlink" title="3. 升序查找最接近目标值的元素下标"></a><strong>3. 升序查找最接近目标值的元素下标</strong></h4><p><strong>功能</strong>：在一个升序排列的数组中查找最接近目标值的元素下标。</p>
<p><strong>函数</strong>：<code>AscNear</code></p>
<p><strong>逻辑</strong>：</p>
<ul>
<li>通过二分查找法，找到第一个大于等于目标值的元素下标。</li>
<li>如果目标值存在，则返回其下标。</li>
<li>如果不存在，则返回最接近的下标。</li>
</ul>
<p><strong>示例</strong>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int32_t</span> index = AscNear(arr, <span class="number">6</span>, <span class="number">11</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;最接近 11 的元素下标 = %d，元素值 = %d。\n&quot;</span>, index, arr[index]);  <span class="comment">// 输出: 4, 元素14</span></span><br></pre></td></tr></table></figure></p>
<h4 id="4-降序查找最接近目标值的元素下标-1"><a href="#4-降序查找最接近目标值的元素下标-1" class="headerlink" title="4. 降序查找最接近目标值的元素下标"></a><strong>4. 降序查找最接近目标值的元素下标</strong></h4><p><strong>功能</strong>：在一个降序排列的数组中查找最接近目标值的元素下标。</p>
<p><strong>函数</strong>：<code>DescNear</code></p>
<p><strong>逻辑</strong>：</p>
<ul>
<li>通过二分查找法，找到第一个小于等于目标值的元素下标。</li>
<li>如果目标值存在，则返回其下标。</li>
<li>如果不存在，则返回最接近的下标。</li>
</ul>
<p><strong>示例</strong>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int32_t</span> index = DescNear(arr2, <span class="number">6</span>, <span class="number">11</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;最接近 11 的元素下标 = %d，元素值 = %d。\n&quot;</span>, index, arr2[index]);  <span class="comment">// 输出: 2, 元素10</span></span><br></pre></td></tr></table></figure></p>
<h3 id="调试与问题解决"><a href="#调试与问题解决" class="headerlink" title="调试与问题解决"></a><strong>调试与问题解决</strong></h3><blockquote>
<p>在实现和调试二分查找法时，可能会遇到以下问题：</p>
<ol>
<li><p><strong>查找结果不正确</strong>：</p>
<ul>
<li><strong>原因</strong>：比较函数逻辑错误，或者数组未正确排序。</li>
<li><strong>解决方法</strong>：确保数组已按预期顺序排序，检查比较函数的返回值逻辑是否正确。</li>
</ul>
</li>
<li><p><strong>程序进入死循环</strong>：</p>
<ul>
<li><strong>原因</strong>：计算中间下标时溢出，或者变量类型使用不当。</li>
<li><strong>解决方法</strong>：使用<code>left + (right - left) / 2</code>计算中间下标，确保<code>left</code>、<code>right</code>和<code>mid</code>为有符号整型。</li>
</ul>
</li>
<li><p><strong>未找到目标值时返回错误</strong>：</p>
<ul>
<li><strong>原因</strong>：循环终止条件设置不正确，或者函数返回值错误。</li>
<li><strong>解决方法</strong>：检查循环条件是否为<code>left &lt;= right</code>，确保在未找到目标值时返回-1。</li>
</ul>
</li>
<li><p><strong>查找最接近目标值时返回错误</strong>：</p>
<ul>
<li><strong>原因</strong>：未正确更新最接近的元素下标。</li>
<li><strong>解决方法</strong>：在比较过程中记录最接近目标值的元素下标，并在循环结束后返回。</li>
</ul>
</li>
</ol>
</blockquote>
<h2 id="7-传感器任务框架搭建"><a href="#7-传感器任务框架搭建" class="headerlink" title="7.传感器任务框架搭建"></a>7.传感器任务框架搭建</h2><h3 id="1-分层架构概述"><a href="#1-分层架构概述" class="headerlink" title="1. 分层架构概述"></a><strong>1. 分层架构概述</strong></h3><p>在本节课中，我们将实现一个<strong>两层分层的应用层和驱动层</strong>的软件架构。这种架构的主要优势在于：</p>
<ul>
<li><strong>代码可复用</strong>：不同传感器的驱动可以在不修改应用层代码的情况下进行替换。</li>
<li><strong>代码可移植</strong>：通过统一的接口设计，软件架构可以适应不同的硬件平台。</li>
</ul>
<h3 id="2-驱动层的设计"><a href="#2-驱动层的设计" class="headerlink" title="2. 驱动层的设计"></a><strong>2. 驱动层的设计</strong></h3><p>在驱动层，我们实现一个<strong>统一的传感器框架</strong>。具体步骤如下：</p>
<ul>
<li><strong>驱动文件</strong>：创建一个驱动文件<code>driver.c</code>，由驱动层对外提供接口，供应用层调用。</li>
<li><strong>暴露函数</strong>：驱动层暴露获取传感器数据的函数，供外部应用层使用。</li>
</ul>
<h3 id="3-数据结构设计"><a href="#3-数据结构设计" class="headerlink" title="3. 数据结构设计"></a><strong>3. 数据结构设计</strong></h3><p>我们设计一个结构体来存储传感器的数据，结构体成员包括各类传感器的数据，如湿度、温度等。为了未来的扩展，还可以添加PM2.5、甲醛等传感器的数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _SENSOR_DRV_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _SENSOR_DRV_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">float</span> temp;   <span class="comment">// 温度，单位：摄氏度</span></span><br><span class="line">    <span class="type">uint8_t</span> humi; <span class="comment">// 湿度，单位：%</span></span><br><span class="line">&#125; SensorData_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief 传感器驱动初始化</span></span><br><span class="line"><span class="comment">* @param</span></span><br><span class="line"><span class="comment">* @return </span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SensorDrvInit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief 获取传感器数据</span></span><br><span class="line"><span class="comment">* @param sensorData, 输出，传感器数据回写地址</span></span><br><span class="line"><span class="comment">* @return </span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GetSensorData</span><span class="params">(SensorData_t *sensorData)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief 触发驱动转换传感器数据</span></span><br><span class="line"><span class="comment">* @param</span></span><br><span class="line"><span class="comment">* @return </span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SensorDrvProc</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="4-驱动层实现"><a href="#4-驱动层实现" class="headerlink" title="4. 驱动层实现"></a><strong>4. 驱动层实现</strong></h3><p>在驱动层的源文件<code>sensor_drv.c</code>中，实现传感器驱动的初始化、数据转换和数据获取功能。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f30x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sensor_drv.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief 传感器驱动初始化</span></span><br><span class="line"><span class="comment">* @param</span></span><br><span class="line"><span class="comment">* @return </span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SensorDrvInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化相关硬件，如GPIO、ADC等</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief 触发驱动转换传感器数据</span></span><br><span class="line"><span class="comment">* @param</span></span><br><span class="line"><span class="comment">* @return </span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SensorDrvProc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 触发ADC转换，读取传感器数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief 获取传感器数据</span></span><br><span class="line"><span class="comment">* @param sensorData, 输出，传感器数据回写地址</span></span><br><span class="line"><span class="comment">* @return </span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GetSensorData</span><span class="params">(SensorData_t *sensorData)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从ADC读取数据并转换为温度和湿度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief 传感器任务处理函数</span></span><br><span class="line"><span class="comment">* @param </span></span><br><span class="line"><span class="comment">* @return </span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SensorTask</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    SensorDrvProc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-应用层的设计与实现"><a href="#5-应用层的设计与实现" class="headerlink" title="5. 应用层的设计与实现"></a><strong>5. 应用层的设计与实现</strong></h3><p>在应用层，我们实现一个<code>app.c</code>文件，负责任务调度和传感器数据的获取与处理。</p>
<h4 id="5-1-任务调度结构体"><a href="#5-1-任务调度结构体" class="headerlink" title="5.1 任务调度结构体"></a><strong>5.1 任务调度结构体</strong></h4><p>首先，定义一个任务调度结构体，用于管理任务的执行状态和时间片。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 任务调度结构体 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> run;                <span class="comment">// 调度标志，1：调度，0：挂起</span></span><br><span class="line">    <span class="type">uint16_t</span> timCount;          <span class="comment">// 时间片计数值</span></span><br><span class="line">    <span class="type">uint16_t</span> timRload;          <span class="comment">// 时间片重载值</span></span><br><span class="line">    <span class="type">void</span> (*pTaskFuncCb)(<span class="type">void</span>);  <span class="comment">// 函数指针变量，用来保存业务功能模块函数地址</span></span><br><span class="line">&#125; TaskComps_t;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> TaskComps_t g_taskComps[] = </span><br><span class="line">&#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1000</span>, <span class="number">1000</span>,  HmiTask&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1000</span>, <span class="number">1000</span>,  SensorTask&#125;</span><br><span class="line">    <span class="comment">/* 添加业务功能模块 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_NUM_MAX   (sizeof(g_taskComps) / sizeof(g_taskComps[0]))</span></span><br></pre></td></tr></table></figure>
<h4 id="5-2-任务处理与调度函数"><a href="#5-2-任务处理与调度函数" class="headerlink" title="5.2 任务处理与调度函数"></a><strong>5.2 任务处理与调度函数</strong></h4><p>实现任务处理函数<code>TaskHandler</code>和任务调度回调函数<code>TaskScheduleCb</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 任务处理函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">TaskHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint8_t</span> i = <span class="number">0</span>; i &lt; TASK_NUM_MAX; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (g_taskComps[i].run)                  <span class="comment">// 判断时间片标志</span></span><br><span class="line">        &#123;</span><br><span class="line">            g_taskComps[i].run = <span class="number">0</span>;              <span class="comment">// 标志清零</span></span><br><span class="line">            g_taskComps[i].pTaskFuncCb();        <span class="comment">// 执行调度业务功能模块</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief 在定时器中断服务函数中被间接调用，设置时间片标记，</span></span><br><span class="line"><span class="comment">         需要定时器1ms产生1次中断</span></span><br><span class="line"><span class="comment">* @param</span></span><br><span class="line"><span class="comment">* @return </span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">TaskScheduleCb</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint8_t</span> i = <span class="number">0</span>; i &lt; TASK_NUM_MAX; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (g_taskComps[i].timCount)</span><br><span class="line">        &#123;</span><br><span class="line">            g_taskComps[i].timCount--;</span><br><span class="line">            <span class="keyword">if</span> (g_taskComps[i].timCount == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                g_taskComps[i].run = <span class="number">1</span>;</span><br><span class="line">                g_taskComps[i].timCount = g_taskComps[i].timRload;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-热敏电阻"><a href="#8-热敏电阻" class="headerlink" title="8.热敏电阻"></a><strong>8.热敏电阻</strong></h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a><strong>1. 简介</strong></h3><blockquote>
<p><strong>热敏电阻（Thermistor）</strong>是一种电阻值随温度变化而显著变化的电阻器件，主要分为：</p>
<ul>
<li><strong>负温度系数（NTC）</strong>：温度升高，阻值减小。</li>
<li><strong>正温度系数（PTC）</strong>：温度升高，阻值增大。</li>
</ul>
<p>我们使用的是<strong>负温度系数（NTC）</strong>热敏电阻，其阻值随温度升高而减小，反之亦然。</p>
</blockquote>
<h4 id="1-工作原理"><a href="#1-工作原理" class="headerlink" title="1. 工作原理"></a><strong>1. 工作原理</strong></h4><blockquote>
<h4 id="2-1-电路设计"><a href="#2-1-电路设计" class="headerlink" title="2.1 电路设计"></a><strong>2.1 电路设计</strong></h4><ul>
<li><strong>分压电路</strong>：热敏电阻与一个限流电阻（通常为1kΩ）串联，形成分压电路。</li>
<li><strong>ADC采集</strong>：通过ADC采集热敏电阻两端的电压值，转换为数字信号。</li>
</ul>
<h4 id="2-2-温度与阻值关系"><a href="#2-2-温度与阻值关系" class="headerlink" title="2.2 温度与阻值关系"></a><strong>2.2 温度与阻值关系</strong></h4><ul>
<li><strong>25摄氏度时</strong>：NTC热敏电阻的阻值为10kΩ。</li>
<li><strong>阻值变化</strong>：温度升高，阻值下降；温度降低，阻值上升。</li>
<li><strong>测量范围</strong>：-55°C到100°C，分辨率为1°C，精度为±1%。</li>
</ul>
</blockquote>
<h4 id="2-电压转换"><a href="#2-电压转换" class="headerlink" title="2. 电压转换"></a><strong>2. 电压转换</strong></h4><blockquote>
<h4 id="3-1-分压公式"><a href="#3-1-分压公式" class="headerlink" title="3.1 分压公式"></a><strong>3.1 分压公式</strong></h4><script type="math/tex; mode=display">
V_{\text{adc}} = V_{\text{cc}} \times \frac{R_{\text{therm}}}{R_{\text{fixed}} + R_{\text{therm}}}</script><p>其中：</p>
<ul>
<li><code>R_therm</code>是热敏电阻的阻值。</li>
<li><code>R_fixed</code>是固定限流电阻。</li>
</ul>
<h4 id="3-2-示例计算"><a href="#3-2-示例计算" class="headerlink" title="3.2 示例计算"></a><strong>3.2 示例计算</strong></h4><ul>
<li><p><strong>25°C时</strong>：</p>
<script type="math/tex; mode=display">
R_{\text{therm}} = 10kΩ</script><script type="math/tex; mode=display">
V_{\text{adc}} = 3.3V \times \frac{10k}{10k + 10k} = 1.65V</script></li>
</ul>
<ul>
<li><p><strong>温度升高至较高温度（例如5kΩ）</strong>：</p>
<script type="math/tex; mode=display">
R_{\text{therm}} = 5kΩ</script><script type="math/tex; mode=display">
V_{\text{adc}} = 3.3V \times \frac{5k}{10k + 5k} = 1.1V</script></li>
</ul>
</blockquote>
<h4 id="3-温度计算"><a href="#3-温度计算" class="headerlink" title="3. 温度计算"></a><strong>3. 温度计算</strong></h4><blockquote>
<h4 id="4-1-直接映射"><a href="#4-1-直接映射" class="headerlink" title="4.1 直接映射"></a><strong>4.1 直接映射</strong></h4><ul>
<li><strong>阻值与温度表</strong>：通过预先测量不同温度下的阻值，建立阻值与温度的对应关系表。</li>
<li><strong>代码实现</strong>：在代码中直接将ADC读取的数值映射到相应的温度值，避免实时计算，节省CPU资源。</li>
</ul>
<h4 id="4-2-精度提升"><a href="#4-2-精度提升" class="headerlink" title="4.2 精度提升"></a><strong>4.2 精度提升</strong></h4><ul>
<li><p><strong>线性插值</strong>：为了实现更高的温度精度（如0.1°C），在相邻温度区间内进行线性插值计算。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190041723.png" alt="image-20241201203039214"></p>
<p>已知：</p>
<ul>
<li>28°C 对应 ADC 值 1913</li>
<li>29°C 对应 ADC 值 1869</li>
</ul>
<p>目标 ADC 值为 1889（写代码会用到此公式）：</p>
<script type="math/tex; mode=display">
\text{温度} = 28 + \frac{(1889 - 1869)}{(1913 - 1869)} \times 1 \approx 28.45°C</script></li>
</ul>
</blockquote>
<h3 id="2-代码实现-2"><a href="#2-代码实现-2" class="headerlink" title="2. 代码实现"></a>2. 代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f30x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NTC 热敏电阻 ADC 值查找表</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint16_t</span> g_ntcAdcTable[] = </span><br><span class="line">&#123;</span><br><span class="line">	<span class="number">3123</span>, <span class="number">3089</span>, <span class="number">3051</span>, <span class="number">3013</span>, <span class="number">2973</span>, <span class="number">2933</span>, <span class="number">2893</span>, <span class="number">2852</span>, <span class="number">2810</span>, <span class="number">2767</span>,     <span class="comment">//0   ~   9℃</span></span><br><span class="line">	<span class="number">2720</span>, <span class="number">2681</span>, <span class="number">2637</span>, <span class="number">2593</span>, <span class="number">2548</span>, <span class="number">2503</span>, <span class="number">2458</span>, <span class="number">2412</span>, <span class="number">2367</span>, <span class="number">2321</span>,     <span class="comment">//10  ~  19℃</span></span><br><span class="line">	<span class="number">2275</span>, <span class="number">2230</span>, <span class="number">2184</span>, <span class="number">2138</span>, <span class="number">2093</span>, <span class="number">2048</span>, <span class="number">2002</span>, <span class="number">1958</span>, <span class="number">1913</span>, <span class="number">1869</span>,     <span class="comment">//20  ~  29℃</span></span><br><span class="line">	<span class="number">1825</span>, <span class="number">1782</span>, <span class="number">1739</span>, <span class="number">1697</span>, <span class="number">1655</span>, <span class="number">1614</span>, <span class="number">1573</span>, <span class="number">1533</span>, <span class="number">1494</span>, <span class="number">1455</span>,     <span class="comment">//30  ~  39℃</span></span><br><span class="line">	<span class="number">1417</span>, <span class="number">1380</span>, <span class="number">1343</span>, <span class="number">1307</span>, <span class="number">1272</span>, <span class="number">1237</span>, <span class="number">1203</span>, <span class="number">1170</span>, <span class="number">1138</span>, <span class="number">1106</span>,     <span class="comment">//40  ~  49℃</span></span><br><span class="line">	<span class="number">1081</span>, <span class="number">1045</span>, <span class="number">1016</span>, <span class="number">987</span>,  <span class="number">959</span>,  <span class="number">932</span>,  <span class="number">905</span>,  <span class="number">879</span>,  <span class="number">854</span>,  <span class="number">829</span>,      <span class="comment">//50  ~  59℃</span></span><br><span class="line">	<span class="number">806</span>,  <span class="number">782</span>,  <span class="number">760</span>,  <span class="number">738</span>,  <span class="number">716</span>,  <span class="number">696</span>,  <span class="number">675</span>,  <span class="number">656</span>,  <span class="number">637</span>,  <span class="number">618</span>,      <span class="comment">//60  ~  69℃</span></span><br><span class="line">	<span class="number">600</span>,  <span class="number">583</span>,  <span class="number">566</span>,  <span class="number">550</span>,  <span class="number">534</span>,  <span class="number">518</span>,  <span class="number">503</span>,  <span class="number">489</span>,  <span class="number">475</span>,  <span class="number">461</span>,      <span class="comment">//70  ~  79℃</span></span><br><span class="line">	<span class="number">448</span>,  <span class="number">435</span>,  <span class="number">422</span>,  <span class="number">410</span>,  <span class="number">398</span>,  <span class="number">387</span>,  <span class="number">376</span>,  <span class="number">365</span>,  <span class="number">355</span>,  <span class="number">345</span>,      <span class="comment">//80  ~  89℃</span></span><br><span class="line">	<span class="number">335</span>,  <span class="number">326</span>,  <span class="number">316</span>,  <span class="number">308</span>,  <span class="number">299</span>,  <span class="number">290</span>,  <span class="number">283</span>,  <span class="number">274</span>,  <span class="number">267</span>,  <span class="number">259</span>,      <span class="comment">//90  ~  99℃</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NTC_TABLE_SIZE         (sizeof(g_ntcAdcTable) / sizeof(g_ntcAdcTable[0]))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INDEX_TO_TEMP(index)   ((int32_t)index)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFF_NUM_SIZE 11</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint16_t</span> g_temp10MplBuf[BUFF_NUM_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">float</span> g_tempData;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">GPIOInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	rcu_periph_clock_enable(RCU_GPIOC);</span><br><span class="line">	gpio_init(GPIOC, GPIO_MODE_AIN, GPIO_OSPEED_10MHZ, GPIO_PIN_3);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ADCInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 使能时钟；*/</span></span><br><span class="line">	rcu_periph_clock_enable(RCU_ADC0);</span><br><span class="line">	<span class="comment">/* 设置分频系数；*/</span></span><br><span class="line">	rcu_adc_clock_config(RCU_CKADC_CKAPB2_DIV6);  <span class="comment">// 6分频，120MHz / 6 = 20MHz</span></span><br><span class="line">	<span class="comment">/* 设置独立模式；*/</span></span><br><span class="line">	adc_mode_config(ADC_MODE_FREE);</span><br><span class="line">	<span class="comment">/* 设置连续模式；*/</span> </span><br><span class="line">	adc_special_function_config(ADC0, ADC_CONTINUOUS_MODE, ENABLE);</span><br><span class="line">	<span class="comment">/* 设置数据对齐；*/</span></span><br><span class="line">	adc_data_alignment_config(ADC0, ADC_DATAALIGN_RIGHT);</span><br><span class="line">	<span class="comment">/* 设置转换通道个数；*/</span> </span><br><span class="line">	adc_channel_length_config(ADC0, ADC_REGULAR_CHANNEL, <span class="number">1</span>);</span><br><span class="line">	<span class="comment">/* 设置转换哪一个通道以及所处序列位置；*/</span> </span><br><span class="line">	adc_regular_channel_config(ADC0, <span class="number">0</span>, ADC_CHANNEL_13, ADC_SAMPLETIME_239POINT5);  <span class="comment">// PC3对应通道13，放在序列寄存器的0序列中，239.5个周期</span></span><br><span class="line">	<span class="comment">/* 设置选择哪一个外部触发源；*/</span> </span><br><span class="line">	adc_external_trigger_source_config(ADC0, ADC_REGULAR_CHANNEL, ADC0_1_2_EXTTRIG_REGULAR_NONE);</span><br><span class="line">	<span class="comment">/* 使能外部触发；*/</span> </span><br><span class="line">	adc_external_trigger_config(ADC0, ADC_REGULAR_CHANNEL, ENABLE);</span><br><span class="line">	<span class="comment">/* 使能硬件滤波；*/</span> </span><br><span class="line">	adc_oversample_mode_config(ADC0, ADC_OVERSAMPLING_ALL_CONVERT, ADC_OVERSAMPLING_SHIFT_4B, ADC_OVERSAMPLING_RATIO_MUL16);</span><br><span class="line">	adc_oversample_mode_enable(ADC0);</span><br><span class="line">	<span class="comment">/* 使能ADC；*/</span> </span><br><span class="line">	adc_enable(ADC0);</span><br><span class="line">	<span class="comment">/* 内部校准；*/</span> </span><br><span class="line">	DelayNus(<span class="number">50</span>);</span><br><span class="line">	adc_calibration_enable(ADC0);</span><br><span class="line">	adc_software_trigger_enable(ADC0, ADC_REGULAR_CHANNEL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief 算术平均滤波</span></span><br><span class="line"><span class="comment">* @param arr，数组首地址</span></span><br><span class="line"><span class="comment">* @param len，元素个数</span></span><br><span class="line"><span class="comment">* @return 平均运算结果</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint16_t</span> <span class="title function_">ArithAvgFltr</span><span class="params">(<span class="type">uint16_t</span> *arr, <span class="type">uint32_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint32_t</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sum += arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">uint16_t</span>)(sum / len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">DescBinarySearch</span><span class="params">(<span class="type">const</span> <span class="type">uint16_t</span> *arr, <span class="type">int32_t</span> size, <span class="type">uint16_t</span> key)</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int32_t</span> left = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int32_t</span> right = size - <span class="number">1</span>;</span><br><span class="line">	<span class="type">int32_t</span> mid = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int32_t</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">	&#123;</span><br><span class="line">		mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(key &gt;= arr[mid])</span><br><span class="line">		&#123;</span><br><span class="line">			right = mid - <span class="number">1</span>;</span><br><span class="line">			index = mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			left = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief qsort函数调用的回调函数，比较规则，降序排列</span></span><br><span class="line"><span class="comment">* @param *_a，对应数组元素</span></span><br><span class="line"><span class="comment">* @param *_b，对应数组元素</span></span><br><span class="line"><span class="comment">* @return 比较结果</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">CmpCb</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *_a, <span class="type">const</span> <span class="type">void</span> *_b)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint16_t</span>* a = (<span class="type">uint16_t</span>*)_a;</span><br><span class="line">	<span class="type">uint16_t</span>* b = (<span class="type">uint16_t</span>*)_b;</span><br><span class="line">	<span class="type">int8_t</span> val = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(*a &lt; *b)</span><br><span class="line">	&#123;</span><br><span class="line">		val = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(*a &gt; *b)</span><br><span class="line">	&#123;</span><br><span class="line">		val = <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		val = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief 中位值平均滤波</span></span><br><span class="line"><span class="comment">* @param arr，数组首地址</span></span><br><span class="line"><span class="comment">* @param len，元素个数，需要大于等于3个</span></span><br><span class="line"><span class="comment">* @return 平均运算结果</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint16_t</span> <span class="title function_">MedianAvgFltr</span><span class="params">(<span class="type">uint16_t</span> *arr, <span class="type">uint32_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	qsort(arr, len, <span class="keyword">sizeof</span>(<span class="type">uint16_t</span>), CmpCb);</span><br><span class="line">	<span class="keyword">return</span> ArithAvgFltr(&amp;arr[<span class="number">1</span>], len - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">Get_ADCVal</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (!adc_flag_get(ADC0, ADC_FLAG_EOC));</span><br><span class="line">	<span class="keyword">return</span> adc_regular_data_read(ADC0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint16_t</span> <span class="title function_">ADCtoTemp10Mpl</span><span class="params">(<span class="type">uint16_t</span> ADCVal)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 二分查找 找温度（下标）</span></span><br><span class="line">	<span class="type">int32_t</span> index = DescBinarySearch(g_ntcAdcTable, NTC_TABLE_SIZE, ADCVal);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(index == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 表示温度为0</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 计算 </span></span><br><span class="line">	<span class="type">uint16_t</span> Temp10Mpl = INDEX_TO_TEMP(index - <span class="number">1</span>) * <span class="number">10</span> + (g_ntcAdcTable[index - <span class="number">1</span>] - ADCVal) / (g_ntcAdcTable[index - <span class="number">1</span>] - g_ntcAdcTable[index]);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> Temp10Mpl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PushDataToBuf</span><span class="params">(<span class="type">uint16_t</span> temp10Mpl)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">uint16_t</span> s_index = <span class="number">0</span>;</span><br><span class="line">	g_temp10MplBuf[s_index++] = temp10Mpl; </span><br><span class="line">	s_index %= BUFF_NUM_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief NTC驱动初始化</span></span><br><span class="line"><span class="comment">* @param</span></span><br><span class="line"><span class="comment">* @return </span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Temp_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIOInit();</span><br><span class="line">	ADCInit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief 触发驱动转换温度传感器数据</span></span><br><span class="line"><span class="comment">* @param</span></span><br><span class="line"><span class="comment">* @return </span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Temp_SensorProc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">uint16_t</span> s_convertNum = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 获得ADC采集数据	</span></span><br><span class="line">	<span class="type">uint16_t</span> ADCVal = Get_ADCVal();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 将ADC采集数据转换为十倍温度值</span></span><br><span class="line">	<span class="type">uint16_t</span> temp10Mpl = ADCtoTemp10Mpl(ADCVal);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 将十倍温度值放入Buffer中</span></span><br><span class="line">	PushDataToBuf(temp10Mpl);</span><br><span class="line">	</span><br><span class="line">	s_convertNum++;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 采集小于3次直接用第一次采集数据代替</span></span><br><span class="line">	<span class="keyword">if</span>(s_convertNum &lt; <span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		g_tempData = g_temp10MplBuf[<span class="number">0</span>] / <span class="number">10.0f</span>;</span><br><span class="line">		<span class="comment">//return ;// 少加return 直接触发</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(s_convertNum &gt; BUFF_NUM_SIZE)</span><br><span class="line">	&#123;</span><br><span class="line">		s_convertNum = BUFF_NUM_SIZE;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 快速排序 + 中值滤波 </span></span><br><span class="line">	g_tempData = MedianAvgFltr(g_temp10MplBuf, s_convertNum) / <span class="number">10.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief 获取温度传感器数据</span></span><br><span class="line"><span class="comment">* @param</span></span><br><span class="line"><span class="comment">* @return 温度数据，小数</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">Get_TempData</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> g_tempData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-湿敏电阻"><a href="#9-湿敏电阻" class="headerlink" title="9.湿敏电阻"></a>9.湿敏电阻</h2><h3 id="1-简介-1"><a href="#1-简介-1" class="headerlink" title="1. 简介"></a><strong>1. 简介</strong></h3><p><strong>湿敏电阻（Humidity Sensitive Resistor）</strong>是一种对湿度变化敏感的电阻器件。由于材料特性的原因，为了防止极化和电解作用，湿敏电阻需要<strong>交流电源驱动</strong>。相比于热敏电阻，湿敏电阻的驱动电路更为复杂。</p>
<h4 id="1-相对湿度与绝对湿度"><a href="#1-相对湿度与绝对湿度" class="headerlink" title="1. 相对湿度与绝对湿度"></a><strong>1. 相对湿度与绝对湿度</strong></h4><p>在日常生活中，当我们说“湿度是50”，其实指的是<strong>相对湿度</strong>。相对湿度是指在某一特定温度下，空气中实际含有的水蒸气密度与该温度下水蒸气的饱和密度之比，通常以百分比表示。因此，“50”代表<strong>50%</strong>。</p>
<p>相对湿度与绝对湿度的区别如下：</p>
<ul>
<li><strong>相对湿度</strong>：空气中水蒸气的实际密度与饱和密度之比，表示为百分比。</li>
<li><strong>绝对湿度</strong>：在一定温度和压力条件下，空气中水蒸气的最大容量，通常以克每立方米（g/m³）表示。</li>
</ul>
<h4 id="2-驱动电路设计"><a href="#2-驱动电路设计" class="headerlink" title="2. 驱动电路设计"></a><strong>2. 驱动电路设计</strong></h4><p>驱动电路简易框图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190042276.png" alt="image-20241201210622103"></p>
<p>以下是湿敏电阻的驱动电路设计要点：</p>
<ul>
<li><strong>驱动引脚</strong>：使用三个引脚，其中<code>PB0</code>和<code>PB1</code>用于交流电源驱动。具体配置如下：<ul>
<li>当<code>PB0</code>为高电平时，<code>PB1</code>为低电平。</li>
<li>当<code>PB0</code>为低电平时，<code>PB1</code>为高电平。</li>
</ul>
</li>
<li><strong>ADC采集端口</strong>：<code>PC4</code>为ADC采集端口，用于读取湿敏电阻上的电压值。</li>
<li><strong>电阻配置</strong>：<ul>
<li>湿敏电阻串联一个470Ω的电阻。</li>
<li>并联一个1MΩ的电阻。</li>
<li>使用39kΩ的分压电阻。</li>
</ul>
</li>
<li><strong>驱动频率</strong>：<strong><code>厂商建议使用1kHz的交流驱动频率</code></strong>，即每个周期1毫秒，高电平500微秒，低电平500微秒。但在实际项目中，为了降低频率需求，我们选择<strong>250Hz</strong>，即每个周期4毫秒，高电平2毫秒，低电平2毫秒。这一频率足以满足数据采集需求，同时减少定时器中断的负担。</li>
</ul>
<h4 id="3-驱动电路工作原理"><a href="#3-驱动电路工作原理" class="headerlink" title="3. 驱动电路工作原理"></a><strong>3. 驱动电路工作原理</strong></h4><p>在驱动电路中，通过<code>PB0</code>和<code>PB1</code>的高低电平交替，产生交流信号驱动湿敏电阻。<code>PC4</code>端口通过ADC采集湿敏电阻两端的电压值，并将其转换为数字信号用于后续处理。</p>
<p>湿度数据的计算</p>
<blockquote>
<h4 id="1：根据温度获取对应湿度的ADC数值"><a href="#1：根据温度获取对应湿度的ADC数值" class="headerlink" title="1：根据温度获取对应湿度的ADC数值"></a><strong>1：根据温度获取对应湿度的ADC数值</strong></h4><p>假设我们获得的温度数据是18摄氏度，正好位于15°C和20°C之间。湿度的间隔为5%，同样，温度的间隔也是5°C。</p>
<p><strong>计算过程</strong>：</p>
<ol>
<li><p>确定温度行：</p>
<ul>
<li><p>温度数据18°C位于15°C和20°C之间。</p>
</li>
<li><p>温度行索引计算：</p>
<script type="math/tex; mode=display">
text{temp\_row} = \frac{18}{5} = 3.6 \approx 3</script><p>（向下取整，索引从0开始，表示15°C对应第3行）</p>
</li>
</ul>
</li>
<li><p>获取15°C和20°C下特定湿度的ADC数值：</p>
<ul>
<li>例如，20%湿度在15°C下对应的ADC数值为154，在20°C下为168。</li>
</ul>
</li>
<li><p><strong>线性插值计算18°C下20%湿度的ADC数值</strong>：</p>
<script type="math/tex; mode=display">
\text{ADC}_{18} = \text{ADC}_{15} + \left( \frac{18 - 15}{20 - 15} \right) \times (\text{ADC}_{20} - \text{ADC}_{15}) = 154 + \left( \frac{3}{5} \right) \times (168 - 154) = 154 + 10.8 = 164.8 \approx 165</script><p>这样，我们得到18°C下20%湿度对应的ADC数值约为165。</p>
</li>
</ol>
<h4 id="2：根据ADC数值计算湿度"><a href="#2：根据ADC数值计算湿度" class="headerlink" title="2：根据ADC数值计算湿度"></a><strong>2：根据ADC数值计算湿度</strong></h4><ol>
<li><p>二分查找法定位ADC数值：</p>
<ul>
<li>使用二分查找法在对应温度行的ADC数值数组中查找目标ADC值。</li>
<li>假设目标ADC值为170，位于15°C下20%湿度（ADC=154）和20°C下20%湿度（ADC=168）之间。</li>
</ul>
</li>
<li><p>线性插值计算湿度：</p>
<script type="math/tex; mode=display">
\text{湿度} = \text{湿度}_{\text{low}} + \left( \frac{\text{ADC}_{\text{low}} - \text{ADC}_{\text{current}}}{\text{ADC}_{\text{low}} - \text{ADC}_{\text{high}}} \right) \times (\text{湿度}_{\text{high}} - \text{湿度}_{\text{low}})</script></li>
</ol>
<p>   示例：</p>
<script type="math/tex; mode=display">
\text{ADC}_{\text{low}} = 168</script><p>   20°C下20%湿度</p>
<script type="math/tex; mode=display">
   \text{ADC}_{\text{high}} = 154</script><p>   15°C下20%湿度</p>
<script type="math/tex; mode=display">
   \text{ADC}_{\text{current}} = 170</script><script type="math/tex; mode=display">
   \text{湿度} = 20\% + \left( \frac{168 - 170}{168 - 154} \right) \times (25\% - 20\%) = 20\% + \left( \frac{-2}{14} \right) \times 5\% \approx 20\% - 0.714\% \approx 19.3\%</script></blockquote>
<h3 id="2-代码实现-3"><a href="#2-代码实现-3" class="headerlink" title="2.代码实现"></a>2.代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f30x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led_drv.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint16_t</span> g_adcVal;	<span class="comment">// 全局变量，用于存储ADC转换的数值</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> g_humiData;	<span class="comment">// 全局变量，用于存储湿度值</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HUMI_LEVEL_NUM 18	<span class="comment">// 湿度等级数量</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不同温度下的湿度对应ADC值表</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint16_t</span> g_rhADCVal[][HUMI_LEVEL_NUM] = &#123;</span><br><span class="line"><span class="comment">//         10%RH  15%RH  20%RH  25%RH  30%RH  35%RH  40%RH  45%RH  50%RH  55%RH  60%RH  65%RH  70%RH  75%RH  80%RH  85%RH  90%RH  95%RH               </span></span><br><span class="line"><span class="comment">/* 0℃*/</span>  &#123;<span class="number">154</span>,   <span class="number">155</span>,   <span class="number">160</span>,   <span class="number">165</span>,   <span class="number">177</span>,   <span class="number">204</span>,   <span class="number">257</span>,   <span class="number">354</span>,   <span class="number">516</span>,   <span class="number">803</span>,   <span class="number">1189</span>,  <span class="number">1633</span>,  <span class="number">2101</span>,  <span class="number">2579</span>,  <span class="number">2919</span>,  <span class="number">3204</span>,  <span class="number">3434</span>,  <span class="number">3595</span>,&#125;,</span><br><span class="line"><span class="comment">/* 5℃*/</span>  &#123;<span class="number">154</span>,   <span class="number">155</span>,   <span class="number">161</span>,   <span class="number">168</span>,   <span class="number">186</span>,   <span class="number">223</span>,   <span class="number">296</span>,   <span class="number">429</span>,   <span class="number">650</span>,   <span class="number">985</span>,   <span class="number">1408</span>,  <span class="number">1874</span>,  <span class="number">2330</span>,  <span class="number">2796</span>,  <span class="number">3113</span>,  <span class="number">3356</span>,  <span class="number">3571</span>,  <span class="number">3702</span>,&#125;,</span><br><span class="line"><span class="comment">/*10℃*/</span>  &#123;<span class="number">154</span>,   <span class="number">156</span>,   <span class="number">164</span>,   <span class="number">175</span>,   <span class="number">199</span>,   <span class="number">250</span>,   <span class="number">342</span>,   <span class="number">508</span>,   <span class="number">775</span>,   <span class="number">1154</span>,  <span class="number">1633</span>,  <span class="number">2127</span>,  <span class="number">2540</span>,  <span class="number">2945</span>,  <span class="number">3236</span>,  <span class="number">3456</span>,  <span class="number">3619</span>,  <span class="number">3736</span>,&#125;,</span><br><span class="line"><span class="comment">/*15℃*/</span>  &#123;<span class="number">154</span>,   <span class="number">157</span>,   <span class="number">168</span>,   <span class="number">183</span>,   <span class="number">217</span>,   <span class="number">284</span>,   <span class="number">410</span>,   <span class="number">619</span>,   <span class="number">941</span>,   <span class="number">1367</span>,  <span class="number">1835</span>,  <span class="number">2330</span>,  <span class="number">2750</span>,  <span class="number">3113</span>,  <span class="number">3370</span>,  <span class="number">3555</span>,  <span class="number">3676</span>,  <span class="number">3780</span>,&#125;,</span><br><span class="line"><span class="comment">/*20℃*/</span>  &#123;<span class="number">155</span>,   <span class="number">158</span>,   <span class="number">176</span>,   <span class="number">197</span>,   <span class="number">237</span>,   <span class="number">320</span>,   <span class="number">477</span>,   <span class="number">750</span>,   <span class="number">1121</span>,  <span class="number">1604</span>,  <span class="number">2075</span>,  <span class="number">2540</span>,  <span class="number">2919</span>,  <span class="number">3236</span>,  <span class="number">3442</span>,  <span class="number">3611</span>,  <span class="number">3736</span>,  <span class="number">3825</span>,&#125;,</span><br><span class="line"><span class="comment">/*25℃*/</span>  &#123;<span class="number">155</span>,   <span class="number">160</span>,   <span class="number">183</span>,   <span class="number">210</span>,   <span class="number">264</span>,   <span class="number">375</span>,   <span class="number">579</span>,   <span class="number">901</span>,   <span class="number">1338</span>,  <span class="number">1855</span>,  <span class="number">2298</span>,  <span class="number">2727</span>,  <span class="number">3055</span>,  <span class="number">3342</span>,  <span class="number">3539</span>,  <span class="number">3676</span>,  <span class="number">3780</span>,  <span class="number">3853</span>,&#125;,</span><br><span class="line"><span class="comment">/*30℃*/</span>  &#123;<span class="number">155</span>,   <span class="number">161</span>,   <span class="number">191</span>,   <span class="number">230</span>,   <span class="number">301</span>,   <span class="number">451</span>,   <span class="number">696</span>,   <span class="number">1062</span>,  <span class="number">1537</span>,  <span class="number">2075</span>,  <span class="number">2502</span>,  <span class="number">2894</span>,  <span class="number">3204</span>,  <span class="number">3427</span>,  <span class="number">3595</span>,  <span class="number">3719</span>,  <span class="number">3807</span>,  <span class="number">3871</span>,&#125;,</span><br><span class="line"><span class="comment">/*35℃*/</span>  &#123;<span class="number">156</span>,   <span class="number">164</span>,   <span class="number">202</span>,   <span class="number">250</span>,   <span class="number">344</span>,   <span class="number">508</span>,   <span class="number">803</span>,   <span class="number">1226</span>,  <span class="number">1728</span>,  <span class="number">2238</span>,  <span class="number">2705</span>,  <span class="number">3055</span>,  <span class="number">3302</span>,  <span class="number">3501</span>,  <span class="number">3652</span>,  <span class="number">3754</span>,  <span class="number">3834</span>,  <span class="number">3899</span>,&#125;,</span><br><span class="line"><span class="comment">/*40℃*/</span>  &#123;<span class="number">156</span>,   <span class="number">166</span>,   <span class="number">214</span>,   <span class="number">284</span>,   <span class="number">397</span>,   <span class="number">619</span>,   <span class="number">985</span>,   <span class="number">1429</span>,  <span class="number">1936</span>,  <span class="number">2430</span>,  <span class="number">2820</span>,  <span class="number">3143</span>,  <span class="number">3370</span>,  <span class="number">3547</span>,  <span class="number">3685</span>,  <span class="number">3780</span>,  <span class="number">3853</span>,  <span class="number">3909</span>,&#125;,</span><br><span class="line"><span class="comment">/*45℃*/</span>  &#123;<span class="number">157</span>,   <span class="number">171</span>,   <span class="number">237</span>,   <span class="number">315</span>,   <span class="number">477</span>,   <span class="number">750</span>,   <span class="number">1154</span>,  <span class="number">1604</span>,  <span class="number">2101</span>,  <span class="number">2540</span>,  <span class="number">2945</span>,  <span class="number">3236</span>,  <span class="number">3442</span>,  <span class="number">3603</span>,  <span class="number">3728</span>,  <span class="number">3816</span>,  <span class="number">3871</span>,  <span class="number">3918</span>,&#125;,</span><br><span class="line"><span class="comment">/*50℃*/</span>  &#123;<span class="number">158</span>,   <span class="number">174</span>,   <span class="number">253</span>,   <span class="number">354</span>,   <span class="number">545</span>,   <span class="number">865</span>,   <span class="number">1328</span>,  <span class="number">1835</span>,  <span class="number">2298</span>,  <span class="number">2727</span>,  <span class="number">3055</span>,  <span class="number">3329</span>,  <span class="number">3516</span>,  <span class="number">3660</span>,  <span class="number">3762</span>,  <span class="number">3843</span>,  <span class="number">3895</span>,  <span class="number">3938</span>,&#125;,</span><br><span class="line"><span class="comment">/*55℃*/</span>  &#123;<span class="number">159</span>,   <span class="number">179</span>,   <span class="number">278</span>,   <span class="number">401</span>,   <span class="number">634</span>,   <span class="number">941</span>,   <span class="number">1524</span>,  <span class="number">2027</span>,  <span class="number">2502</span>,  <span class="number">2844</span>,  <span class="number">3173</span>,  <span class="number">3398</span>,  <span class="number">3563</span>,  <span class="number">3693</span>,  <span class="number">3789</span>,  <span class="number">3862</span>,  <span class="number">3909</span>,  <span class="number">3947</span>,&#125;,</span><br><span class="line"><span class="comment">/*60℃*/</span>  &#123;<span class="number">160</span>,   <span class="number">184</span>,   <span class="number">301</span>,   <span class="number">457</span>,   <span class="number">739</span>,   <span class="number">1035</span>,  <span class="number">1711</span>,  <span class="number">2209</span>,  <span class="number">2662</span>,  <span class="number">2999</span>,  <span class="number">3275</span>,  <span class="number">3456</span>,  <span class="number">3611</span>,  <span class="number">3728</span>,  <span class="number">3807</span>,  <span class="number">3871</span>,  <span class="number">3918</span>,  <span class="number">3957</span>,&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEMP_INTERVAL_VAL   5   <span class="comment">// 温度间隔值 (°C)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HUMI_INTERVAL_VAL   5   <span class="comment">// 湿度间隔值 (%RH)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HUMI_MAX_VAL        95  <span class="comment">// 最大湿度值 (%RH)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HUMI_MIN_VAL        10  <span class="comment">// 最小湿度值 (%RH)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEMP_MAX_VAL        60  <span class="comment">// 最大温度值 (°C)</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">GPIOInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	rcu_periph_clock_enable(RCU_GPIOC);</span><br><span class="line">	gpio_init(GPIOC, GPIO_MODE_AIN, GPIO_OSPEED_MAX, GPIO_PIN_4);    <span class="comment">// ADC通道14</span></span><br><span class="line">	</span><br><span class="line">	rcu_periph_clock_enable(RCU_GPIOB);</span><br><span class="line">	gpio_init(GPIOB, GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_0 | GPIO_PIN_1);  <span class="comment">// 交流电源激励</span></span><br><span class="line">	gpio_bit_write(GPIOB, GPIO_PIN_0, (bit_status)<span class="number">1</span>);</span><br><span class="line">	gpio_bit_write(GPIOB, GPIO_PIN_1, (bit_status)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ADCInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 使能时钟；*/</span></span><br><span class="line">	rcu_periph_clock_enable(RCU_ADC1);</span><br><span class="line">	<span class="comment">/* 设置分频系数；*/</span></span><br><span class="line">	rcu_adc_clock_config(RCU_CKADC_CKAPB2_DIV6);  <span class="comment">// 6分频，120MHz / 6 = 20MHz</span></span><br><span class="line">	<span class="comment">/* 设置独立模式；*/</span></span><br><span class="line">	adc_mode_config(ADC_MODE_FREE);</span><br><span class="line">	<span class="comment">/* 设置单次模式；*/</span> </span><br><span class="line">	adc_special_function_config(ADC1, ADC_CONTINUOUS_MODE, DISABLE);</span><br><span class="line">	<span class="comment">/* 设置数据对齐；*/</span></span><br><span class="line">	adc_data_alignment_config(ADC1, ADC_DATAALIGN_RIGHT);</span><br><span class="line">	<span class="comment">/* 设置转换通道个数；*/</span> </span><br><span class="line">	adc_channel_length_config(ADC1, ADC_REGULAR_CHANNEL, <span class="number">1</span>);</span><br><span class="line">	<span class="comment">/* 设置转换哪一个通道以及所处序列位置；*/</span> </span><br><span class="line">	adc_regular_channel_config(ADC1, <span class="number">0</span>, ADC_CHANNEL_14, ADC_SAMPLETIME_71POINT5);  <span class="comment">// PC4对应通道14，放在序列寄存器的0序列中，71.5个周期</span></span><br><span class="line">	<span class="comment">/* 设置选择哪一个外部触发源；*/</span> </span><br><span class="line">	adc_external_trigger_source_config(ADC1, ADC_REGULAR_CHANNEL, ADC0_1_2_EXTTRIG_REGULAR_NONE);</span><br><span class="line">	<span class="comment">/* 使能外部触发；*/</span> </span><br><span class="line">	adc_external_trigger_config(ADC1, ADC_REGULAR_CHANNEL, ENABLE);</span><br><span class="line">	<span class="comment">/* 使能硬件滤波；*/</span> </span><br><span class="line">	adc_oversample_mode_config(ADC1, ADC_OVERSAMPLING_ALL_CONVERT, ADC_OVERSAMPLING_SHIFT_4B, ADC_OVERSAMPLING_RATIO_MUL16);</span><br><span class="line">	adc_oversample_mode_enable(ADC1);</span><br><span class="line">	<span class="comment">/* 使能ADC；*/</span> </span><br><span class="line">	adc_enable(ADC1);</span><br><span class="line">	<span class="comment">/* 内部校准；*/</span> </span><br><span class="line">	DelayNus(<span class="number">50</span>);</span><br><span class="line">	adc_calibration_enable(ADC1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">TimerInit</span><span class="params">(<span class="type">uint32_t</span> periodUs)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 使能定时器时钟；*/</span></span><br><span class="line">	rcu_periph_clock_enable(RCU_TIMER4);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 复位定时器；*/</span></span><br><span class="line">	timer_deinit(TIMER4);</span><br><span class="line">	</span><br><span class="line">	timer_parameter_struct timerInitPara;</span><br><span class="line">	timer_struct_para_init(&amp;timerInitPara);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 设置预分频器值；*/</span></span><br><span class="line">	timerInitPara.prescaler = <span class="number">120</span> - <span class="number">1</span>;     <span class="comment">// 输入给计数器的时钟频率为1Mhz，周期1us</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 设置自动重装载值；*/</span> </span><br><span class="line">	timerInitPara.period = periodUs - <span class="number">1</span>;</span><br><span class="line">	timer_init(TIMER4, &amp;timerInitPara);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 使能定时器的计数更新中断；*/</span></span><br><span class="line">	timer_interrupt_enable(TIMER4, TIMER_INT_UP);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 使能定时器中断和优先级；*/</span></span><br><span class="line">	nvic_irq_enable(TIMER4_IRQn, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 使能定时器；*/</span> </span><br><span class="line">	timer_enable(TIMER4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief 湿度传感器驱动初始化</span></span><br><span class="line"><span class="comment">* @param</span></span><br><span class="line"><span class="comment">* @return </span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Humi_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIOInit();</span><br><span class="line">	ADCInit();</span><br><span class="line">	Timer_Init(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief 获取数据寄存器中的 ADC 值</span></span><br><span class="line"><span class="comment">* @param</span></span><br><span class="line"><span class="comment">* @return ADC值</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint16_t</span> <span class="title function_">GetAdcVal</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 中断服务函数中每调用一次，使能ADC转换 */</span></span><br><span class="line">	adc_software_trigger_enable(ADC1, ADC_REGULAR_CHANNEL);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* 等待转换完成标志 */</span></span><br><span class="line">    <span class="keyword">while</span>(!adc_flag_get(ADC1, ADC_FLAG_EOC));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 读取数据寄存器 */</span></span><br><span class="line">    <span class="keyword">return</span> (adc_regular_data_read(ADC1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief 翻转 IO 状态</span></span><br><span class="line"><span class="comment">* @param 无</span></span><br><span class="line"><span class="comment">* @return 无</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">AcPowerProc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	gpio_bit_write(GPIOB, GPIO_PIN_0, (FlagStatus)((FlagStatus)<span class="number">1</span> - gpio_output_bit_get(GPIOB, GPIO_PIN_0)));</span><br><span class="line">	gpio_bit_write(GPIOB, GPIO_PIN_1, (FlagStatus)((FlagStatus)<span class="number">1</span> - gpio_output_bit_get(GPIOB, GPIO_PIN_1)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIMER4_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">uint16_t</span> timerCount = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (timer_interrupt_flag_get(TIMER4, TIMER_INT_FLAG_UP) != RESET)</span><br><span class="line">	&#123;</span><br><span class="line">		timer_interrupt_flag_clear(TIMER4, TIMER_INT_FLAG_UP);</span><br><span class="line">		timerCount++;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (timerCount % <span class="number">2</span> == <span class="number">0</span>)     <span class="comment">// 每2ms反转IO口</span></span><br><span class="line">		&#123;</span><br><span class="line">			AcPowerProc();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (timerCount % <span class="number">400</span> == <span class="number">1</span>)  <span class="comment">// 每隔400ms，在高电平中间位置获取一次ADC的数据</span></span><br><span class="line">		&#123;</span><br><span class="line">			g_adcVal = GetAdcVal();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief 根据温度计算湿度对应的 ADC 值表</span></span><br><span class="line"><span class="comment">* @param arr 存储计算结果的数组</span></span><br><span class="line"><span class="comment">* @param temp 当前温度</span></span><br><span class="line"><span class="comment">* @return 无</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">CalcHumiAdcByTemp</span><span class="params">(<span class="type">uint16_t</span> *arr, <span class="type">uint8_t</span> temp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> tempRow = temp / TEMP_INTERVAL_VAL;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 边界值温度直接返回其ADC值即可 */</span></span><br><span class="line">	<span class="keyword">if</span> (temp % TEMP_INTERVAL_VAL == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memcpy</span>(arr, &amp;g_rhADCVal[tempRow][<span class="number">0</span>], HUMI_LEVEL_NUM * <span class="keyword">sizeof</span>(<span class="type">uint16_t</span>));</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">uint8_t</span> i = <span class="number">0</span>; i &lt; HUMI_LEVEL_NUM; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		arr[i] = g_rhADCVal[tempRow][i] + (g_rhADCVal[tempRow + <span class="number">1</span>][i] - g_rhADCVal[tempRow][i]) * (tempRow) / TEMP_INTERVAL_VAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief 使用二分法在升序数组中查找元素位置</span></span><br><span class="line"><span class="comment">* @param arr 升序数组</span></span><br><span class="line"><span class="comment">* @param size 数组大小</span></span><br><span class="line"><span class="comment">* @param key 查找的键值</span></span><br><span class="line"><span class="comment">* @return 找到的位置索引</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">AsceBinarySearch</span><span class="params">(<span class="type">const</span> <span class="type">uint16_t</span> *arr, <span class="type">int32_t</span> size, <span class="type">uint16_t</span> key)</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int32_t</span> left = <span class="number">0</span>;              			</span><br><span class="line">	<span class="type">int32_t</span> right = size - <span class="number">1</span>;       		</span><br><span class="line">	<span class="type">int32_t</span> mid;</span><br><span class="line">	<span class="type">int32_t</span> index = size - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (left &lt;= right)             		</span><br><span class="line">	&#123;</span><br><span class="line">		mid = left + (right - left) / <span class="number">2</span>; </span><br><span class="line">		<span class="keyword">if</span> (key &lt;= arr[mid])</span><br><span class="line">		&#123;</span><br><span class="line">			right = mid - <span class="number">1</span>;</span><br><span class="line">			index = mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			left = mid + <span class="number">1</span>;  		</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    	<span class="keyword">return</span> index;               				</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> <span class="title function_">ADCToHumi</span><span class="params">(<span class="type">uint16_t</span> *arr, <span class="type">uint16_t</span> adcVal)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int32_t</span> index = AsceBinarySearch(arr, HUMI_LEVEL_NUM, adcVal);</span><br><span class="line">	<span class="keyword">if</span> (index == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> HUMI_MIN_VAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">uint8_t</span> humi = HUMI_MIN_VAL + (index - <span class="number">1</span>) * HUMI_INTERVAL_VAL +  HUMI_INTERVAL_VAL * (adcVal - arr[index - <span class="number">1</span>]) / (arr[index] - arr[index - <span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">return</span> humi;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief 触发驱动转换湿度传感器数据</span></span><br><span class="line"><span class="comment">* @param</span></span><br><span class="line"><span class="comment">* @return </span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Humi_SensorProc</span><span class="params">(<span class="type">uint8_t</span> temp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (temp &gt; TEMP_MAX_VAL)</span><br><span class="line">	&#123;</span><br><span class="line">		temp = TEMP_MAX_VAL;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">uint16_t</span> humiADCBuf[HUMI_LEVEL_NUM];</span><br><span class="line">	CalcHumiAdcByTemp(humiADCBuf, temp);</span><br><span class="line">	g_humiData = ADCToHumi(humiADCBuf, g_adcVal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief 获取湿度传感器数据</span></span><br><span class="line"><span class="comment">* @param</span></span><br><span class="line"><span class="comment">* @return 湿度数据，整数</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">Get_HumiData</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> g_humiData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="RS485"><a href="#RS485" class="headerlink" title="RS485"></a>RS485</h1><h2 id="1-RS485协议解读"><a href="#1-RS485协议解读" class="headerlink" title="1.RS485协议解读"></a><strong>1.RS485协议解读</strong></h2><blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412021947729.png" alt="image-20241202194707662" style="zoom: 150%;"></p>
<p>RS485采用的是双线传输，包含A信号线和B信号线。与RS232最本质的区别在于，RS485采用了差分模式。即在同一时刻，RS485总线要么在发送数据，要么在接收数据，因此是半双工的。</p>
<p>RS232是全双工的，使用两个信号线，一个用于发送数据，另一个用于接收数据。这是它们两个的主要区别。</p>
<p>由于采用差分模式，当A-B的电压差值大于0.2伏时，RS485总线传输逻辑电平1；当A-B小于-0.2伏时，传输逻辑电平0。如果A-B的电压差在-0.2伏到0.2伏之间，则无法识别逻辑电平。</p>
<p>这种差分模式可以提高抗干扰能力。例如，遇到脉冲干扰时，干扰会叠加在A和B信号线上，但由于差分模式，A-B的差值会抵消这些脉冲干扰。因此，RS485能够实现更远的通信距离，理论上可达1200米，远超RS232，广泛应用于工业现场。</p>
<p>RS485支持一主多从的通信方式，即一个主机可以连接多个从机。这种能力取决于芯片的转换能力和软件协议。</p>
</blockquote>
<h2 id="2-RS485硬件电路两种方案"><a href="#2-RS485硬件电路两种方案" class="headerlink" title="2.RS485硬件电路两种方案"></a><strong>2.RS485硬件电路两种方案</strong></h2><blockquote>
<p><strong>常规方案:</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412021957614.png" alt="image-20241202195740526"></p>
<p>使用常见的转换芯片，如SSP485。左侧部分连接到MCU单片机，涉及三个IO口，分别对应串口的RX、TX以及一个普通的IO口。在开发板上使用的是PC5口，用于切换RS485芯片的工作模式（发送或接收）。通过一个切换开关控制，并配有三个100欧姆的限流电阻起到缓冲作用。</p>
<p>右侧是RS485相关的电路部分，包括防护电路。主要有两个自恢复保险丝，起到过流保护，防止电流过大烧毁器件；三个TVS二极管，用于防止浪涌干扰。这些都是典型的防护电路，可以参考芯片的规格书（datasheet）获取这些电路信息，实际产品中也大量使用，放在自己的项目中没有问题。</p>
<p>左侧有两个上拉和下拉电阻。A信号线接一个上拉电阻到3.3伏，B信号线接一个下拉电阻到GND。这两个上下拉电阻是必须要加的，以保证RS485总线在空闲状态下A和B信号线呈现逻辑电平1，即电压差大于0.2伏。这样在空闲状态下，A和B信号线通过上下拉电阻分别为3.3伏和0伏，确保RS485总线电平为1。</p>
<p>另外，RS485有时需要在A和B信号线之间加上120欧姆的终端电阻，具体是否需要根据实际部署环境决定。如果系统中有多个节点且总线距离较长，可以在主机侧和最后一个从机侧各加一个120欧姆的终端电阻，以起到阻抗匹配、防止信号反射的作用。</p>
<p><strong>自收发电路:</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412021957032.png" alt="image-20241202195733946"></p>
<p>第二种方案是自收发电路，相较于第一种方案，它节省了一个IO口，仅使用串口的RX和TX。</p>
<p>具体实现方式如下：</p>
<p>串口的RX接到RO管脚，DI管脚接地。单片机的TX通过一个三极管连接到RE和DE管脚。这种设计虽然节省了IO口，但不太规范，实际应用中不推荐使用。之前使用这种电路时，遇到了RS485通信异常的问题，发现电阻损坏（虽然表面未烧毁，但电阻变为无穷大），原因可能与现场环境如雷击或强干扰有关。因此，建议采用第一种常规方案。</p>
<p><strong>自收发电路的工作原理</strong></p>
<p>在自收发电路中，当工作在接收模式时，单片机的TX默认是高电平，三极管导通，使RE被使能，RS485芯片进入接收模式，可以接收外部数据。当需要发送数据时，通过三极管切换至发送模式，发送对应的逻辑电平。由于使用了三极管的开关特性，频率特性与串口的波特率相关，适用于较低的波特率（如9600），高波特率下可能不稳定。</p>
<p>这种电路的优点是节省IO口，适用于IO资源有限的项目。但由于稳定性和可靠性问题，实际应用中建议优先选择常规方案。</p>
</blockquote>
<h1 id="MODBUS"><a href="#MODBUS" class="headerlink" title="MODBUS"></a>MODBUS</h1><h2 id="1-MODBUS协议解读"><a href="#1-MODBUS协议解读" class="headerlink" title="1.MODBUS协议解读"></a><strong>1.MODBUS协议解读</strong></h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412022050180.png" alt="image-20241202205031112"></p>
<p>RS485是一种电气协议，属于硬件级别的协议。而MODBUS是一种软件协议，这种软件协议既可以运行在RS485这种电气接口上，也可以运行在RS232或者以太网电气接口上。</p>
<p><strong>RS485相当于公路，MODBUS相当于交通规则，传输的数据就是汽车。</strong></p>
<blockquote>
<p><strong>标准开放性</strong></p>
<p>MODBUS协议是标准开放的，公开发表的，没有版权要求。这一点非常重要，因此我们才能放心大胆地使用MODBUS。相比之下，许多开源软件或协议有相关的版权要求，例如Linux，它遵从GPL协议，使用Linux内核的代码也必须开源。</p>
<p><strong>协议格式与兼容性</strong></p>
<p>MODBUS协议的消息帧格式非常简单，便于厂商开发和集成。在做产品时，尽量少使用私有协议（即自己定义的协议），因为这样无法与其他厂商的产品对接，尤其是在复杂庞大的系统中，可能有许多不同厂家的设备，系统将无法正常运行。因此，在使用通信协议时，一定要选择标准开放的协议。</p>
<p><strong>传输介质与报文类型</strong></p>
<p>MODBUS协议可以在RS485、RS232和以太网上传输，支持三种报文类型，包括ASCII、RTU（Remote Terminal Unit）和TCP。对于ASCII和RTU，通常运行在RS485和RS232电气接口上；而TCP则用于以太网接口。</p>
<p>在ASCII和RTU中，RTU模式最为常用。RTU使用二进制（或16进制）数据传输，而ASCII模式使用字符数据传输。</p>
<p><strong>报文介绍</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412022054120.png" alt="image-20241202205421028"></p>
<ul>
<li>绿色的线表示以太网，传输协议报文类型为TCP。</li>
<li>蓝色的线表示RS485电气接口。主机通过RS485连接多个从机，大家都使用一套MODBUS RTU协议进行集成。</li>
</ul>
<p><strong>MODBUS报文格式</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412022057133.png" alt="image-20241202205755053"></p>
<p>在传输数据时，一包数据通常包含多个字节，我们可以称之为一帧数据。其格式如下：</p>
<ol>
<li><strong>从机地址（1字节）</strong>：每个从机都有唯一的地址（ID），相当于门牌号，主机通过地址找到对应的从机。</li>
<li><strong>功能码（1字节）</strong>：指示这一帧数据的用途，例如查询数据、读取数据、修改数据或写入数据。</li>
<li><strong>数据部分（0-252字节）</strong>：根据功能码的不同，内容也不同。</li>
<li><strong>CRC校验码（2字节）</strong>：包括低字节和高字节，用于检测接收数据的正确性。</li>
</ol>
<p><strong>功能码</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412022059166.png" alt="image-20241202205953093"></p>
<p>MODBUS协议中有多个功能码，其中最常用的功能码：</p>
<ul>
<li>03：读多个寄存器</li>
<li>06：写单个寄存器</li>
<li>16：写多个寄存器</li>
</ul>
</blockquote>
<h2 id="2-MODBUS数据格式"><a href="#2-MODBUS数据格式" class="headerlink" title="2.MODBUS数据格式"></a>2.MODBUS<strong>数据格式</strong></h2><blockquote>
<p><strong>这里的寄存器不是指单片机中的物理寄存器，而是软件中的控制项。</strong>例如，控制传感器、继电器、开关等。这些寄存器在软件设计时需要分配唯一的地址，类似于PLC系统中的控制项。</p>
<p>以某个产品为例，支持RS485 MODBUS功能。软件设计时，需要为每个传感器（如PM2.5、温度、湿度、二氧化碳、TVOC、PM10）分配唯一的寄存器地址，并定义其数据格式（通常为两个字节）。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412022107725.png" alt="image-20241202210742650" style="zoom:;"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412022102725.png" alt="image-20241202210254655"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412022106828.png" alt="image-20241202210609762"></p>
<p><strong>空闲间隔时间（3.5T）</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412031549792.png" alt="image-20241203154937731"></p>
<p>为了方便软件解析数据，MODBUS RTU协议规定两帧数据之间必须有3.5个字符时间的空闲间隔，称为3.5T。这有助于判断一帧数据是否接收完毕。具体时间计算如下：</p>
<ul>
<li>假设波特率为9600，字符时间为10位（1起始位 + 8数据位 + 1停止位）。</li>
<li>一个字符传输时间 = 10位 / 9600波特率 ≈ 1.04毫秒</li>
<li>3.5T ≈ 3.5 × 1.04 ≈ 3.64毫秒</li>
</ul>
<p>通常设计时，使用定时器来实现3.5T的检测。</p>
<p><strong>异常处理</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412022125615.png" alt="image-20241202212532544"></p>
<p>在实际应用中，可能会接收到错误的数据，此时需要进行异常处理。MODBUS定义了几种异常码，例如：</p>
<ul>
<li>01：非法功能码（从机不支持该功能码）</li>
<li>02：非法地址（地址超出范围）</li>
<li>03：非法数据值（数据值不在允许范围）</li>
<li>04：从机故障（解析数据时出错）</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412022126452.png" alt="image-20241202212635382"></p>
<p>例如，主机发送了一个非法地址，或者数据值不合法，从机会返回对应的异常码通知主机。</p>
</blockquote>
<h2 id="3-MODBUS软件架构分层"><a href="#3-MODBUS软件架构分层" class="headerlink" title="3.MODBUS软件架构分层"></a><strong>3.MODBUS软件架构分层</strong></h2><p>采用分层架构，代码清晰：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412022119111.png" alt></p>
<ol>
<li><strong>应用层</strong>：实现具体的业务逻辑，如数据处理和控制。</li>
<li><strong>中间件层</strong>：使用FreeMODBUS库，实现协议相关功能。</li>
<li><strong>驱动层</strong>：实现定时器和串口的初始化及中断功能。</li>
</ol>
<p>MODBUS协议本身格式简单，但在代码实现时涉及数据解析、异常处理和3.5T的检测，可能显得复杂。因此，建议使用开源的MODBUS库，如FreeMODBUS，来简化开发。FreeMODBUS已经实现了<strong>从机功能、异常处理和数据解析</strong>等，开发者只需实现驱动层接口，如定时器和串口中断，并编写业务逻辑代码。</p>
<h2 id="4-FREEMODBUS移植"><a href="#4-FREEMODBUS移植" class="headerlink" title="4.FREEMODBUS移植"></a>4.FREEMODBUS移植</h2><h3 id="1-库文件介绍"><a href="#1-库文件介绍" class="headerlink" title="1.库文件介绍"></a>1.库文件介绍</h3><blockquote>
<p>MODBUS文件夹：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412032034194.png" alt="QQ20241203-203437"></p>
<p> <strong>ascii</strong>：这是实现ASCII码报文的，我们不需要。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412032037696.png" alt="QQ20241203-203652"></p>
<p><strong>functions</strong>：这是实现读写线圈、读写寄存器相关的代码。通常使用功能码03、06、16这三个功能码就够了，其对应的代码文件就是 <code>MB_function_holding.c</code>和<strong><code>MB_utils.c</code></strong>，里面实现了一些通用的接口函数。</p>
<p><strong>include</strong> ：</p>
<p><strong>rtu</strong>：有CRC校验的代码以及RTU协议相关的报文。</p>
<p><strong>tcp：</strong></p>
<p><strong>mb.c：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412032044369.png" alt="QQ20241203-204445"></p>
<p><strong>demo：</strong>与驱动相关的一些参考代码，如定时器、串口初始化相关的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412032045170.png" alt="QQ20241203-204522"></p>
<p>其中，<strong>bare</strong> 这个目录里面是实现了代码模板，只有相关的一些结果函数，没有代码实现。其他的一些文件夹如 <strong>at91sam</strong>，这都是和具体单片机平台相关的一些代码参考，我们不需要。</p>
</blockquote>
<h3 id="2-代码工程配置"><a href="#2-代码工程配置" class="headerlink" title="2.代码工程配置"></a>2.代码工程配置</h3><blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412032056376.png" alt="QQ20241203-205549"></p>
<p>代码工程里面有三个文件夹是和Modbus相关的：</p>
<ul>
<li><strong>App_Modbus：</strong> 对应应用层</li>
<li><strong>Drv_Modbus</strong>： 对应驱动层</li>
<li><strong>Mid_Modbus</strong>： 对应中间件</li>
</ul>
<h3 id="文件添加"><a href="#文件添加" class="headerlink" title="文件添加"></a>文件添加</h3><ul>
<li>拷贝 <code>pot</code>里面的四个文件，放在 <strong><code>Drv_Modbus</code></strong>里，作为驱动。</li>
<li>拷贝 <code>Modbus_driver</code> 里面的 <code>functions</code>、<code>include</code>、<code>rtu</code>、<code>mb.c</code> 放在 <code>Mid_Modbus</code> 里。然后将 <code>functions</code> 里面没用的部分都删除，只保留 <code>mbfuncholding.c</code> 和 <code>mbutils.c</code>。</li>
</ul>
<p>除此之外，还有一些通用的应用代码，如 <code>hm_ia_pp_men.c3</code>，这个里面实现获取温湿度数据的一个任务，用来触发驱动去获取温湿度数据。然后 <strong>Drv_Modbus</strong>，我们放了一些延时的驱动、按键、LED灯、热敏电阻、失敏电阻、队列相关的内容。还有 <strong>gt32</strong> 库，和 ARM 内核相关的，这是整个工程目录结构的一部分。</p>
</blockquote>
<h3 id="3-编译与错误解决"><a href="#3-编译与错误解决" class="headerlink" title="3.编译与错误解决"></a>3.编译与错误解决</h3><blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412032123808.png" alt="QQ20241203-212326"></p>
<p><code>MB.c</code> 里面提示找不到这个头文件。我们看一下这个宏，它是通过宏来判断的。这些宏是在<code>MB_config.h</code> 里面定义的：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412032128929.png" alt="QQ20241203-212554"></p>
<p>将<code>MB_ASCII_ENABLED</code>改为0，<code>MB_RTU_ENABLED</code>这个宏设置为1，<code>MB_TCP_ENABLED</code>改为0。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412032128520.png" alt="QQ20241203-212657"></p>
<p>只保留<strong>读寄存器、写寄存器、写多个寄存器</strong>这三个功能码03、06、16。其他的都设置为0。</p>
<p>然后编译，提示 <code>MB_register_holding_callback</code> 这个函数没有定义实现。这个接口函数需要我们自己去实现，所以现在报错是正常的，我们先不管。</p>
</blockquote>
<h3 id="4-代码移植"><a href="#4-代码移植" class="headerlink" title="4.代码移植"></a>4.代码移植</h3><blockquote>
<h3 id="1-初始化流程"><a href="#1-初始化流程" class="headerlink" title="1.初始化流程"></a>1.初始化流程</h3><p>初始化相关代码实现要放在 <code>port_serial.c</code> 里，包含中断接收发送相关代码。定时器以及中断相关代码，放在 <code>port_timer.c</code> 里面。初始化函数是在 <code>mb.c</code> 的 <code>MB_init</code> 接口函数里面调用的。</p>
<h4 id="1-UART"><a href="#1-UART" class="headerlink" title="1.UART"></a>1.UART</h4><p>包含<strong><code>#include &quot;gd32f30x.h&quot;</code></strong>头文件</p>
<ul>
<li>硬件配置</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412061906424.png" alt="QQ20241206-190523"></p>
<p>使用串口1，对应 GPIOA 的 PA3 和 PA2。然后，传递一个参数，代表波特率，启用接收发送功能，然后使能串口中断。除了使能了内核中的 NVIC 中断，还需要使能片上外设的串口中断。其中<strong>使能串口中断</strong>要把它放在 <code>enable</code> 这个函数里面，动态地由 FreeModbus 库去控制。</p>
<ul>
<li>切换RS485工作模式</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412052127892.png" alt="QQ20241205-212635"></p>
<ul>
<li>串口初始化</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412052129243.png" alt="QQ20241205-212909"></p>
<p>为了避免警告而用<code>void</code>强转，并将关于串口的初始化部分放到<code>xMBPortSerialInit</code>里，将<code>FLASE</code>改成<code>TRUE</code>。</p>
<h4 id="2-TIMER"><a href="#2-TIMER" class="headerlink" title="2.TIMER"></a>2.TIMER</h4><p>在 <code>port_timer.c</code> 里面，<code>xMBPortTimersInit</code>有一个参数：<code>usTim1Timerout50us</code>，这个参数表示的是50微秒的倍数。</p>
<p>比如设置为1，表示1×50微秒；设置为2，表示2×50微秒，即100微秒。设置为100微秒，意味着定时器100微秒后产生中断并进入中断服务函数。</p>
<ul>
<li><p>硬件配置</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412061923924.png" alt="QQ20241206-192334"></p>
<p>使能定时器计数器放在 <code>vMBPortTimersEnable</code> 和 <code>vMBPortTimersDisable</code> 这里面从而 FreeModbus 库能动态控制，对定时器进行打开、关闭以及计数清零。</p>
</li>
<li><p>定时器初始化 &amp; 空闲间隔时间计算</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412061934149.png" alt="QQ20241206-193426"></p>
<p>定时器初始化接口函数里面的50us倍数参数与3.5T空闲间隔时间有对应关系。<code>eMBRTUInit</code> 接口函数会调用定时器初始化结构函数，传入参数 <code>usTimerT35_50us</code>。如果波特率大于19200，那么这个参数传递的数值固定是35，35×50us，对应就是1750us。当波特率大于19200时，Modbus协议要求3.5T固定为1750us。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412062014005.png" alt="image-20241206201408932"></p>
<p>若波特率小于等于19200时，要根据注释的公式和实际波特率计算出3.5T对应的空闲间隔时间。</p>
</li>
</ul>
<p>  FreeModbus库中是基于11位来计算3.5T空闲间隔时间，而在我们做串口初始化的时候，是基于10位来设置的，只差了一位，关系不大，对计时时间影响很小。</p>
<p><strong>一、整体流程概述</strong><br>FreeModbus库整体流程可分为初始化与运行两部分：  </p>
<ul>
<li><strong>初始化阶段</strong>：对Modbus协议栈进行初始化，包括设置串口、定时器以及回调函数等。  </li>
<li><strong>运行阶段</strong>：在<code>while(1)</code>主循环中持续调用<code>eMBPoll()</code>接口函数。该函数根据接收到的数据包和事件标志进行状态机调度，执行相应的读写寄存器操作，并通过相应的发送函数返回结果。</li>
</ul>
<p><strong>二、接收与处理数据的状态机流程</strong>  </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412062043659.png" alt="image-20241206203909544"></p>
<ol>
<li><strong>数据接收过程</strong>：</li>
</ol>
<p>   当接收到一完整帧的数据包后（由串口接收中断与定时器3.5T间隔判断），FreeModbus库会将事件标志<code>eEvent</code>设置为<code>EV_FRAME_RECEIVED</code>。此时在<code>eMBPoll()</code>中检测到该事件标志后，会调用对应的<code>FrameReceiveCur()</code>函数（函数指针指向<code>MBRTUReceive()</code>）从中断保存区拷贝数据至处理区，并将事件标志设置为<code>EV_EXECUTE</code>，以便后续处理。</p>
<ol>
<li><p><strong>功能码处理</strong>：<br>在<code>eMBPoll()</code>中，根据已设置的事件标志和状态机逻辑，会调用<code>pxHandler</code>（函数指针）指向的功能码处理函数（如0x03、0x06、0x10等）。这些功能码对应的处理函数会调用用户实现的回调函数（如<code>eMBRegHoldingCB()</code>），以实现寄存器数据的读写。</p>
</li>
<li><p><strong>数据发送响应</strong>：<br>当数据处理完成后，会调用<code>MBFrameSendCur()</code>（指向<code>MBRTUSend()</code>的函数指针）将处理后的数据打包通过串口发送给主机。</p>
</li>
</ol>
<p><strong>三、串口中断与定时器中断的详细说明</strong>  </p>
<ol>
<li><p><strong>串口接收中断</strong>：<br>在串口接收中断服务程序中，每接收到一个字节数据，就会调用<code>prvvUARTRxISR()</code>接口函数（最终调用<code>xMBRTUReceiveFSM()</code>）。  </p>
<ul>
<li>若是第一个字节数据，则状态机从空闲状态切换到接收状态，并启动3.5T定时器（<code>MBPortTimerEnable()</code>）。  </li>
<li>每接收一个字节数据，都重新启动定时器，确保只在接收完成后（总线空闲3.5T）才触发定时器中断。</li>
</ul>
</li>
<li><p><strong>定时器中断</strong>：<br>当3.5T定时器中断触发时（表示一帧数据已接收完毕且总线空闲），在中断服务函数中调用<code>prvvTIMERExpiredISR()</code>（最终调用<code>xMBRTUTimerT35Expired()</code>）。该函数会将事件标志设置为<code>EV_FRAME_RECEIVED</code>，告知主流程数据帧已接收完整，等待处理。</p>
</li>
<li><p><strong>串口发送中断</strong>：<br>发送采用中断方式逐字节发送。当需发送数据时，在<code>MBRTUSend()</code>中设置相关标志，并通过<code>USART</code>的发送中断服务函数<code>prvvUARTTxReadyISR()</code>（最终调用<code>xMBRTUTransmitFSM()</code>）实现一个字节一个字节的发送。  </p>
<p>需要注意的是，为确保最后一个字节数据完整发送，建议使用<code>TC</code>中断标志（发送完成标志）而不是<code>TBE</code>（发送寄存器空）标志，这样可以避免最后一个字节还未实际发送完成就过早切换485芯片至接收模式，导致数据丢失。</p>
</li>
</ol>
<p><strong>四、485收发控制与中断使能</strong><br>FreeModbus库在<code>eMBPortSerialEnable()</code>接口函数中，根据参数<code>rxEnable</code>和<code>txEnable</code>来控制串口的接收、发送中断和485收发控制端：  </p>
<ul>
<li>当<code>rxEnable = TRUE</code>时：使能接收中断，并将485收发引脚（如PC5）拉低进入接收状态。  </li>
<li>当<code>txEnable = TRUE</code>时：使能发送中断，并将485收发引脚拉高进入发送状态。当发送完成后，再恢复至接收模式。</li>
</ul>
<p>使用<code>TC</code>中断可确保在最后一个字节完全发送完成后再切换至接收状态，避免数据丢失。</p>
<p><strong>五、用户回调函数与业务逻辑实现</strong><br>FreeModbus库在处理功能码时会调用用户需要实现的回调函数，如<code>eMBRegHoldingCB()</code>。用户在该函数中根据读写请求来访问实际硬件、传感器或内存中的数据。该过程将业务层数据与Modbus协议处理分离，有利于保持代码清晰和可维护。</p>
<p><strong>六、移植与代码修改说明</strong><br>在移植FreeModbus到具体平台时，需要实现以下接口函数：  </p>
<ul>
<li>串口初始化与读写函数（<code>prvvUARTTxReadyISR()</code>、<code>prvvUARTRxISR()</code>、<code>prvvUARTTxComplete()</code>）  </li>
<li>定时器初始化与中断处理函数（<code>prvvTIMERExpiredISR()</code>）  </li>
<li>485方向控制（GPIO引脚）  </li>
<li>自定义回调函数（如<code>eMBRegHoldingCB()</code>）</li>
</ul>
<p>另外，在<code>MBFunctionHolding.c</code>中有些小错误，需要做如下修改：  </p>
<ul>
<li>去掉不必要的自增操作，以免地址偏移错误。  </li>
<li>对寄存器数量计算时应使用按字节拼接的位运算（<code>|=</code>），确保高低字节正确合并。  </li>
</ul>
<p>通过这些修正和完善，将能使FreeModbus在目标平台上稳定工作，并正确处理Modbus主机的读写请求。</p>
</blockquote>
<h1 id="IIC"><a href="#IIC" class="headerlink" title="IIC"></a>IIC</h1><h2 id="1-IIC协议解读"><a href="#1-IIC协议解读" class="headerlink" title="1.IIC协议解读"></a>1.IIC协议解读</h2><blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412131829756.png" alt="image-20241213182936683"></p>
<p>最常用的例如UART（串口）、I²C、SPI、CAN总线、USB，这些都是串行通信。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412131855012.png" alt="image-20241213185508950"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412131830718.png" alt="image-20241213183034659"></p>
<p>对于I²C总线，它是同步通信，因为它有一个时钟信号线。I²C总线一共两个信号线，一个是时钟信号线（SCL），一个是数据线（SDA）。而异步通信，比如UART（串口），没有时钟信号线。</p>
<p>对于同步通信，由于有时钟信号，接收端根据时钟信号的脉冲来检测和解析数据线上的数据是0还是1。因此，对于同步通信来说，对持续时间的要求没有那么严格，可以快一点或慢一点都没关系。</p>
<p>对于异步通信，在数据传输时，时序要求非常严格。接收端和发送端必须严格按照固定的波特率去发送和解析数据。例如9600波特率，接收端接收到数据时，会根据9600波特率对应每一个二进制位的持续时间去解析数据，是二进制的0还是1。</p>
<p><strong>I²C总线是半双工的，因为只有两个信号线（SCL和SDA），在同一时刻只能进行发送或接收。</strong></p>
<p>I²C总线和MODBUS一样，支持一主多从的通信方式，即一个主机可以连接多个从机。例如，在一个总线上，可以将单片机作为主机，挂载多个从机，如EEPROM、触摸屏芯片、温湿度传感器等。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412131540868.png" alt="image-20241213154014804"></p>
<p>在总线上，有多个节点设备要求这些设备内部需要将SDA和SCL总线配置成开漏输出模式，而不能设计成推挽输出模式。</p>
<p>设备内部设计成开漏输出模式，还需要在总线上使用两个上拉电阻，每条总线都加一个上拉电阻，阻值一般是3kΩ到10kΩ，典型值是4.7kΩ。<strong>通过开漏输出和上拉电阻能够实现限流的功能。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412131541437.png" alt="image-20241213154145377"></p>
<p>假如总线上有两个设备：</p>
<ol>
<li>第一个设备要输出高电平1，上拉电阻将总线拉高，开漏输出管不导通，总线保持高电平。</li>
<li>另一个设备要输出低电平0，它的开漏输出管导通，将总线拉低。</li>
</ol>
<p><strong>由于开漏输出模式，多个设备可以安全地连接在同一总线上，而不会像推挽输出模式那样导致短路和损坏器件。</strong></p>
</blockquote>
<h2 id="2-IIC总线的数据格式"><a href="#2-IIC总线的数据格式" class="headerlink" title="2.IIC总线的数据格式"></a><strong>2.IIC总线的数据格式</strong></h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412131906232.png" alt="image-20241213190652166"></p>
<p><strong>时钟频率与数据传输</strong></p>
<blockquote>
<p>I²C总线支持多种时钟频率，如100kHz（标准模式）、400kHz（快速模式）、1MHz（高速模式）。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412131912451.png" alt="image-20241213191225388"></p>
<p><code>主机控制SCL时钟信号，而SDA信号线由主机或从机控制。在传输数据时，SDA信号线的数据只能在SCL为低电平时变化，在SCL为高电平时保持稳定，供接收方读取。</code></p>
</blockquote>
<h3 id="1-起始、停止信号"><a href="#1-起始、停止信号" class="headerlink" title="1.起始、停止信号"></a><strong>1.起始、停止信号</strong></h3><blockquote>
<p><code>在空闲状态时，SDA和SCL信号线都保持高电平。</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412131914019.png" alt="image-20241213191453961"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412131916321.png" alt="image-20241213191612262"></p>
<p><code>当需要传输数据时，主机发起起始信号，开始数据传输；传输完成后，主机发起停止信号，返回空闲状态。</code></p>
</blockquote>
<h3 id="2-发送字节"><a href="#2-发送字节" class="headerlink" title="2.发送字节"></a><strong>2.发送字节</strong></h3><blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412131922777.png" alt="image-20241213192215715"></p>
<p><code>主机使SCL高电平时间维持周期的一半值（以上），从机才能检测到SDA数据。</code></p>
</blockquote>
<h3 id="3-读取字节"><a href="#3-读取字节" class="headerlink" title="3.读取字节"></a><strong>3.读取字节</strong></h3><blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412131928260.png" alt="image-20241213192838194"></p>
<p><code>主机读取数据时，主机必须先释放SDA线。因为在IIC协议中，SDA线是双向的，既可以由主机控制，也可以由从机控制。主机在读取数据时，必须释放SDA线，使得从机能够在该线上写入数据。如果主机没有释放SDA线而仍然保持为低电平，则无论从机在该时刻发送的是0还是1，最终都会被拉成0，因为主机仍然控制着SDA线。</code></p>
</blockquote>
<h3 id="4-发送应答"><a href="#4-发送应答" class="headerlink" title="4.发送应答"></a><strong>4.发送应答</strong></h3><blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412131944748.png" alt="image-20241213194439683"></p>
<p><code>每发送一个字节数据后，接收方需要发送一个应答位，表示是否成功接收。应答位是一个单独的位，低电平表示应答，高电平表示非应答。</code></p>
</blockquote>
<h3 id="5-接收应答"><a href="#5-接收应答" class="headerlink" title="5.接收应答"></a><strong>5.接收应答</strong></h3><blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412131938993.png" alt="image-20241213193803925"></p>
<p><strong><code>同样，从机接收应答时，主机必须先释放SDA线，将SDA线的控制权交给从机。</code></strong></p>
</blockquote>
<p><strong>异常处理</strong></p>
<p>在实际应用中，可能会遇到数据传输错误或通信中断。I²C协议本身没有定义具体的异常码，但在实现时需要考虑以下情况：</p>
<ol>
<li><strong>总线冲突</strong>：多个主机同时尝试控制总线，导致信号冲突。</li>
<li><strong>应答失败</strong>：从机未能正确应答，可能由于设备故障或地址错误。</li>
<li><strong>超时</strong>：数据传输过程中，等待应答或数据超时。</li>
</ol>
<p><strong>开发建议</strong></p>
<p>I²C协议实现相对简单，但在多从机环境下，需要注意地址分配和总线管理。建议使用开源的IIC驱动库，如Linux内核中的IIC驱动，或嵌入式系统中的I²C库，以简化开发过程，提高可靠性。</p>
<p><strong>软件架构分层</strong></p>
<p>采用分层架构，代码清晰：</p>
<ol>
<li><strong>应用层</strong>：实现具体的业务逻辑，如传感器数据读取和控制。</li>
<li><strong>中间件层</strong>：使用I²C驱动库，实现协议相关功能。</li>
<li><strong>驱动层</strong>：实现I²C硬件接口的初始化及中断功能。</li>
</ol>
<h2 id="3-EEPROM"><a href="#3-EEPROM" class="headerlink" title="3.EEPROM"></a>3.EEPROM</h2><blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412132024705.png" alt="image-20241213202400643"></p>
<p>存储器可以分为两类：</p>
<ol>
<li><strong>易失性存储器（RAM）</strong>，即内存，掉电后数据会丢失。</li>
<li><strong>非易失性存储器（ROM）</strong>，掉电后数据不会丢失。</li>
</ol>
<p>RAM进一步分为：</p>
<ul>
<li><strong>静态RAM（SRAM）</strong></li>
<li><strong>动态RAM（DRAM）</strong></li>
</ul>
</blockquote>
<h3 id="1-ROM的发展历程"><a href="#1-ROM的发展历程" class="headerlink" title="1.ROM的发展历程"></a>1.ROM的发展历程</h3><ol>
<li><strong>掩膜ROM（Mask ROM）</strong>：出厂时就写入数据，之后不可修改。</li>
<li><strong>PROM</strong>：可编程ROM，通过特殊手段可以在出厂后写入一次数据，但只能修改一次。</li>
<li><strong>EPROM</strong>：可擦除可编程ROM，采用紫外线擦除并重新写入数据，支持多次擦写。</li>
<li><strong>EEPROM（电可擦除可编程ROM）</strong>：与EPROM类似，但采用电流擦除，支持多次擦写。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412132025153.png" alt="image-20241213202541090"></p>
<h3 id="2-EEPROM与Flash的区别"><a href="#2-EEPROM与Flash的区别" class="headerlink" title="2.EEPROM与Flash的区别"></a>2.EEPROM与Flash的区别</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412132025477.png" alt="image-20241213202552418"></p>
<ul>
<li><strong>EEPROM</strong>：可以随机访问并修改任何字节，支持数据保存100年，擦写次数可达100万次。它的成本较高，容量较小，如<strong>24C02</strong>为256字节。</li>
<li><strong>Flash</strong>：闪存通常按块擦除，相比EEPROM，它可以支持更大的存储容量（如U盘使用的NAND Flash），并且具有较低的成本。</li>
</ul>
<p>Flash分为两种：</p>
<ol>
<li><strong>NOR Flash</strong>：数据线和地址线分开，支持随机寻址，适用于代码存储。</li>
<li><strong>NAND Flash</strong>：数据线和地址线复用，不能随机寻址，但擦除和写入速度较快，成本较低，适用于大容量存储（U盘）。</li>
</ol>
<h3 id="3-AT24C02的工作原理"><a href="#3-AT24C02的工作原理" class="headerlink" title="3.AT24C02的工作原理"></a>3.AT24C02的工作原理</h3><p>AT24C02是一个小容量的EEPROM，容量为256字节（2Kbits），每个字节都有唯一的地址。支持按字节或按页写入，能够在掉电后保存数据。使用IIC协议与主机通信，可以通过控制信号进行数据的读写操作。它支持多字节读取和写入，具有较高的可靠性，但容量有限，适用于小容量存储应用。</p>
<h4 id="1-写数据"><a href="#1-写数据" class="headerlink" title="1.写数据"></a>1.写数据</h4><blockquote>
<ol>
<li><p><strong><code>写入一个字节</code></strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412151225078.png" alt="image-20241215122519962"></p>
<ul>
<li><strong>起始信号</strong>：主机发送起始信号。</li>
<li><strong>设备地址和写控制位</strong>：主机发送24C02的地址及写控制位。</li>
<li><strong>数据地址</strong>：主机指定要写入数据的地址（0-255）。</li>
<li><strong>数据</strong>：主机发送要写入的数据字节。</li>
<li><strong>应答信号</strong>：24C02返回应答信号（ACK）。</li>
<li><strong>停止信号</strong>：主机发送停止信号。</li>
</ul>
</li>
<li><p><code>按页写</code></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412151226127.png" alt="image-20241215122659056"></p>
<ul>
<li>每个页包含8个字节，24C02总共有32页（256字节 ÷ 8字节/页）。</li>
<li>可以选择从任意字节地址开始写入（例如从地址1开始），但每页的最大写入字节数为8个。如果超过8个字节，会跨页，需重新发送写信号。</li>
</ul>
</li>
</ol>
</blockquote>
<h4 id="2-读数据"><a href="#2-读数据" class="headerlink" title="2.读数据"></a>2.读数据</h4><blockquote>
<ol>
<li><p><strong>单字节读取</strong>： </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412151316197.png" alt="image-20241215131603127"></p>
<ul>
<li>主机发送设备地址和写控制位，指定要读取的起始地址（假写）。</li>
<li>主机发送起始信号后，再次发送设备地址和读控制位，24C02返回指定地址的数据。</li>
<li>主机发送非应答信号，并发送停止信号。</li>
</ul>
</li>
<li><p><strong>多字节读取</strong>：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412151316341.png" alt="image-20241215131617281"></p>
<ul>
<li>与单字节读取类似，主机只需发送起始地址，24C02内部有地址计数器，可以连续返回后续地址的数据，直到主机发送非应答信号。</li>
</ul>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412151324403.png" alt="image-20241215132401331"></p>
</blockquote>
<h3 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4.代码实现"></a>4.代码实现</h3><h4 id="1-软件模拟IIC"><a href="#1-软件模拟IIC" class="headerlink" title="1.软件模拟IIC"></a>1.软件模拟IIC</h4><h5 id="1-起始信号"><a href="#1-起始信号" class="headerlink" title="1.起始信号"></a>1.起始信号</h5><blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412151324633.png" alt="image-20241215132434566"></p>
</blockquote>
<h5 id="2-停止信号"><a href="#2-停止信号" class="headerlink" title="2.停止信号"></a>2.停止信号</h5><blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412151325702.png" alt="image-20241215132539631"></p>
</blockquote>
<h5 id="3-发送字节"><a href="#3-发送字节" class="headerlink" title="3.发送字节"></a>3.发送字节</h5><blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412151326402.png" alt="image-20241215132622333"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412151326453.png" alt="image-20241215132635387"></p>
</blockquote>
<h5 id="4-读取字节"><a href="#4-读取字节" class="headerlink" title="4.读取字节"></a>4.读取字节</h5><blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412151327329.png" alt="image-20241215132703258"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412151327848.png" alt="image-20241215132722771"></p>
</blockquote>
<h5 id="5-发送应答"><a href="#5-发送应答" class="headerlink" title="5.发送应答"></a>5.发送应答</h5><blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412151328592.png" alt="image-20241215132804524"></p>
<p><strong>发送应答后，主机必须手动释放SDA线，不然从机没办法发送数据。</strong></p>
</blockquote>
<h5 id="6-接收应答"><a href="#6-接收应答" class="headerlink" title="6.接收应答"></a>6.接收应答</h5><blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412151328049.png" alt="image-20241215132809986"></p>
</blockquote>
<h4 id="2-硬件IIC"><a href="#2-硬件IIC" class="headerlink" title="2.硬件IIC"></a>2.硬件IIC</h4></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://qchilli.github.io">Chilli</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://qchilli.github.io/2024/11/29/%E5%B5%8C%E5%85%A5%E5%BC%8F/GD32/">https://qchilli.github.io/2024/11/29/%E5%B5%8C%E5%85%A5%E5%BC%8F/GD32/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://qchilli.github.io" target="_blank">Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/GD32/">GD32</a></div><div class="post_share"><div class="social-share" data-image="https://source.fomal.cc/img/default_cover_5.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/10/27/RTT/RTT%E9%97%AE%E9%A2%98%E5%90%88%E9%9B%86/" title=""><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_9.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info"></div></div></a></div><div class="next-post pull-right"><a href="/2024/12/01/%E6%9D%82%E8%B0%88/%E7%9F%A5%E8%AF%86%E7%82%B9/" title=""><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_10.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info"></div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Chilli</div><div class="author-info__description">成长</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" href="https://qchilli.github.io/"><i class="fab fa-github"></i><span>🛴前往小家...</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xxxxx" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#GPIO"><span class="toc-number">1.</span> <span class="toc-text">GPIO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-GPIO%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">1.GPIO硬件结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-GPIO%E8%BE%93%E5%87%BA%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.2.</span> <span class="toc-text">2.GPIO输出模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.输出结构分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A8%E6%8C%BD%E8%BE%93%E5%87%BA%E7%94%B5%E8%B7%AF"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">推挽输出电路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LED-%E9%A9%B1%E5%8A%A8%E5%88%86%E6%9E%90"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">LED 驱动分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BC%80%E6%BC%8F%E8%BE%93%E5%87%BA%E5%88%86%E6%9E%90"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.开漏输出分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E6%BC%8F%E8%BE%93%E5%87%BA%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">开漏输出的优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E4%B8%8E%E5%8A%9F%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">线与功能分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%80%BB%E7%BB%93"><span class="toc-number">1.2.3.</span> <span class="toc-text">3.总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-GPIO%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.</span> <span class="toc-text">3.GPIO输入模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F%E5%8A%9F%E8%83%BD"><span class="toc-number">1.3.1.</span> <span class="toc-text">输入模式功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%AE%E7%A9%BA%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">浮空输入模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E6%8B%89%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">上拉输入模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E6%8B%89%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">下拉输入模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%B8%8A%E4%B8%8B%E6%8B%89%E7%94%B5%E9%98%BB%E9%80%89%E5%8F%96"><span class="toc-number">1.4.</span> <span class="toc-text">4.上下拉电阻选取</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%8A%E6%8B%89%E7%94%B5%E9%98%BB%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">1.4.1.</span> <span class="toc-text">使用上拉电阻的情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%8B%E6%8B%89%E7%94%B5%E9%98%BB%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">1.4.2.</span> <span class="toc-text">使用下拉电阻的情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%80%83%E8%99%91%E5%9B%A0%E7%B4%A0"><span class="toc-number">1.4.3.</span> <span class="toc-text">考虑因素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E7%89%87%E6%9C%BA%E5%86%85%E9%83%A8%E7%9A%84%E4%B8%8A%E6%8B%89%E5%92%8C%E4%B8%8B%E6%8B%89%E7%94%B5%E9%98%BB%EF%BC%8C%E5%85%B8%E5%9E%8B%E5%80%BC%E4%B8%BA-40k%CE%A9%EF%BC%8C%E8%80%8C%E9%99%90%E6%B5%81%E7%94%B5%E9%98%BB%E9%80%9A%E5%B8%B8%E9%80%89%E6%8B%A9-1k%CE%A9%E3%80%82"><span class="toc-number">1.4.4.</span> <span class="toc-text">单片机内部的上拉和下拉电阻，典型值为 40kΩ，而限流电阻通常选择 1kΩ。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">使用注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-GPIO%E8%BE%93%E5%87%BA%E9%80%9F%E5%BA%A6"><span class="toc-number">1.5.</span> <span class="toc-text">5.GPIO输出速度</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CLOCKTREE"><span class="toc-number">2.</span> <span class="toc-text">CLOCKTREE</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%B3%BB%E7%BB%9F%E7%A1%AC%E4%BB%B6%E6%9E%B6%E6%9E%84%E5%9B%9E%E9%A1%BE"><span class="toc-number">2.1.</span> <span class="toc-text">1.系统硬件架构回顾</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%97%B6%E9%92%9F%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90"><span class="toc-number">2.2.</span> <span class="toc-text">2.时钟系统架构分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%97%B6%E9%92%9F%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%85%B7%E4%BD%93%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.3.</span> <span class="toc-text">3.时钟系统的具体介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%9F%BA%E4%BA%8E%E5%86%85%E6%A0%B8DWT%E7%9A%84%E5%BB%B6%E6%97%B6"><span class="toc-number">2.4.</span> <span class="toc-text">4.基于内核DWT的延时</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#NVIC"><span class="toc-number">3.</span> <span class="toc-text">NVIC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F%E7%A1%AC%E4%BB%B6%E5%92%8C%E8%BD%AF%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.</span> <span class="toc-text">1.中断系统硬件和软件结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.1.1.</span> <span class="toc-text">1.概念介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-ARM-%E5%8D%95%E7%89%87%E6%9C%BA%E4%B8%AD%E7%9A%84%E4%B8%AD%E6%96%AD"><span class="toc-number">3.1.2.</span> <span class="toc-text">2.ARM 单片机中的中断</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-ARM-%E5%8D%95%E7%89%87%E6%9C%BA%E7%9A%84%E5%BC%82%E5%B8%B8%E8%A7%A6%E5%8F%91%E6%BA%90"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">1.ARM 单片机的异常触发源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%BC%82%E5%B8%B8%E7%9A%84%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">2.异常的存储空间分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%B8%AD%E6%96%AD%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">3.1.2.3.</span> <span class="toc-text">3.中断执行流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.1.2.4.</span> <span class="toc-text">中断服务函数实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-EXTI-%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.2.</span> <span class="toc-text">2.EXTI 中断系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%A1%AC%E4%BB%B6%E8%BF%9E%E6%8E%A5%E7%BB%93%E6%9E%84"><span class="toc-number">3.2.0.1.</span> <span class="toc-text">1.硬件连接结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%AD%E6%96%AD%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">3.2.0.2.</span> <span class="toc-text">2.中断优先级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BC%98%E5%85%88%E7%BA%A7%E5%88%86%E7%BB%84"><span class="toc-number">3.2.0.3.</span> <span class="toc-text">3.优先级分组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%B8%AD%E6%96%AD%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">3.2.0.4.</span> <span class="toc-text">4.中断执行顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E7%89%B9%E6%AE%8A%E4%B8%AD%E6%96%AD%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">3.2.0.5.</span> <span class="toc-text">5.特殊中断优先级</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.3.</span> <span class="toc-text">3.代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%97%AE%E9%A2%98%E4%B8%80%EF%BC%9A%E6%B2%A1%E6%9C%89%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E5%87%BD%E6%95%B0"><span class="toc-number">3.3.1.</span> <span class="toc-text">1.问题一：没有中断服务函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%97%AE%E9%A2%98%E4%B8%80%EF%BC%9A%E6%9C%89%E4%B8%BB%E5%BE%AA%E7%8E%AF"><span class="toc-number">3.3.1.1.</span> <span class="toc-text">1.问题一：有主循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%97%AE%E9%A2%98%E4%BA%8C%EF%BC%9A%E6%B2%A1%E6%9C%89%E4%B8%BB%E5%87%BD%E6%95%B0%E5%BE%AA%E7%8E%AF"><span class="toc-number">3.3.1.2.</span> <span class="toc-text">2.问题二：没有主函数循环</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%97%AE%E9%A2%98%E4%BA%8C%EF%BC%9A%E6%9C%AA%E6%B8%85%E9%99%A4%E6%A0%87%E5%BF%97%E4%BD%8D"><span class="toc-number">3.3.2.</span> <span class="toc-text">2.问题二：未清除标志位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%97%AE%E9%A2%98%E4%B8%89%EF%BC%9A%E4%B8%AD%E6%96%AD%E6%8A%A2%E5%8D%A0%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">3.3.3.</span> <span class="toc-text">3.问题三：中断抢占优先级</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%AA%8C%E8%AF%81%E6%8A%A2%E5%8D%A0%E4%BC%98%E5%85%88%E7%BA%A7%E4%BD%9C%E7%94%A8"><span class="toc-number">3.3.3.1.</span> <span class="toc-text">1.验证抢占优先级作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%AA%8C%E8%AF%81%E5%AD%90%E4%BC%98%E5%85%88%E7%BA%A7%E4%BD%9C%E7%94%A8"><span class="toc-number">3.3.3.2.</span> <span class="toc-text">2.验证子优先级作用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94"><span class="toc-number">3.4.</span> <span class="toc-text">4.方案对比</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RTC"><span class="toc-number">4.</span> <span class="toc-text">RTC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">4.1.</span> <span class="toc-text">1.使用指针函数的注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-RTC%E5%92%8CBKP%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">4.2.</span> <span class="toc-text">2.RTC和BKP硬件结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-RTC"><span class="toc-number">4.2.1.</span> <span class="toc-text">1.RTC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-BKP"><span class="toc-number">4.2.2.</span> <span class="toc-text">2.BKP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-RTC-amp-BKP%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE"><span class="toc-number">4.2.3.</span> <span class="toc-text">3.RTC &amp; BKP初始化配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-RTC%E9%A9%B1%E5%8A%A8%E5%B1%82%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.3.</span> <span class="toc-text">3.RTC驱动层代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-RTC-%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="toc-number">4.3.1.</span> <span class="toc-text">1.RTC 初始化过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%EF%BC%9A"><span class="toc-number">4.3.1.1.</span> <span class="toc-text">解析：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E8%83%BD%E7%94%B5%E6%BA%90%E5%92%8C%E5%A4%87%E4%BB%BD%E6%8E%A5%E5%8F%A3%E6%97%B6%E9%92%9F"><span class="toc-number">4.3.1.2.</span> <span class="toc-text">使能电源和备份接口时钟</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E8%83%BD%E5%A4%87%E4%BB%BD%E5%9F%9F%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C-RTC-%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-number">4.3.1.3.</span> <span class="toc-text">使能备份域寄存器和 RTC 的访问</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E4%BD%8D%E5%90%8E%E5%A4%87%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">4.3.1.4.</span> <span class="toc-text">复位后备寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E7%94%A8%E4%BD%8E%E9%80%9F%E5%A4%96%E9%83%A8%E6%99%B6%E6%8C%AF%EF%BC%88LXTAL%EF%BC%89%E5%B9%B6%E7%AD%89%E5%BE%85%E5%85%B6%E7%A8%B3%E5%AE%9A"><span class="toc-number">4.3.1.5.</span> <span class="toc-text">启用低速外部晶振（LXTAL）并等待其稳定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE-RTC-%E6%97%B6%E9%92%9F%E6%BA%90%E4%B8%BA-LXTAL"><span class="toc-number">4.3.1.6.</span> <span class="toc-text">设置 RTC 时钟源为 LXTAL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E8%83%BD-RTC-%E6%97%B6%E9%92%9F%E5%B9%B6%E7%AD%89%E5%BE%85%E5%90%8C%E6%AD%A5"><span class="toc-number">4.3.1.7.</span> <span class="toc-text">使能 RTC 时钟并等待同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E4%B8%8A%E6%AC%A1%E5%86%99%E6%93%8D%E4%BD%9C%E5%AE%8C%E6%88%90"><span class="toc-number">4.3.1.8.</span> <span class="toc-text">等待上次写操作完成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE-RTC-%E5%88%86%E9%A2%91%E5%99%A8%E5%92%8C%E5%88%9D%E5%A7%8B%E6%97%B6%E9%97%B4"><span class="toc-number">4.3.1.9.</span> <span class="toc-text">设置 RTC 分频器和初始时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%A4%87%E4%BB%BD%E5%AF%84%E5%AD%98%E5%99%A8%E6%A0%87%E8%AE%B0%E5%B7%B2%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">4.3.1.10.</span> <span class="toc-text">设置备份寄存器标记已初始化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%AE%BE%E7%BD%AE%E6%97%B6%E9%97%B4"><span class="toc-number">4.3.2.</span> <span class="toc-text">2.设置时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%8E%B7%E5%8F%96%E6%97%B6%E9%97%B4"><span class="toc-number">4.3.3.</span> <span class="toc-text">3.获取时间</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ADC"><span class="toc-number">5.</span> <span class="toc-text">ADC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-ADC%E7%B3%BB%E7%BB%9F%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">5.1.</span> <span class="toc-text">1.ADC系统工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-ADC%E5%8D%95%E9%80%9A%E9%81%93%E8%BD%AC%E6%8D%A2%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.2.</span> <span class="toc-text">2.ADC单通道转换实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%A1%AC%E4%BB%B6%E8%BF%9E%E6%8E%A5"><span class="toc-number">5.2.1.</span> <span class="toc-text">1.硬件连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.2.2.</span> <span class="toc-text">2.代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-ADC-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE"><span class="toc-number">5.2.2.1.</span> <span class="toc-text">1.ADC 初始化配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%B0%83%E8%AF%95%E4%B8%8E%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3"><span class="toc-number">5.2.2.2.</span> <span class="toc-text">2.调试与问题解决</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AE%9E%E9%AA%8C%E4%B8%8E%E6%B5%8B%E8%AF%95"><span class="toc-number">5.2.2.3.</span> <span class="toc-text">3.实验与测试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-ADC%E5%A4%9A%E9%80%9A%E9%81%93%E9%85%8D%E5%90%88DMA%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.3.</span> <span class="toc-text">3.ADC多通道配合DMA转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%A1%AC%E4%BB%B6%E8%BF%9E%E6%8E%A5-1"><span class="toc-number">5.3.1.</span> <span class="toc-text">1.硬件连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">5.3.2.</span> <span class="toc-text">2.代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-ADC-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE-1"><span class="toc-number">5.3.2.1.</span> <span class="toc-text">1.ADC 初始化配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-DMA-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE"><span class="toc-number">5.3.2.2.</span> <span class="toc-text">2.DMA 初始化配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%B0%83%E8%AF%95%E4%B8%8E%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3"><span class="toc-number">5.3.2.3.</span> <span class="toc-text">3.调试与问题解决</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-ADC%E7%A1%AC%E4%BB%B6%E6%BB%A4%E6%B3%A2%E5%92%8C%E8%BD%AF%E4%BB%B6%E6%BB%A4%E6%B3%A2"><span class="toc-number">5.4.</span> <span class="toc-text">4.ADC硬件滤波和软件滤波</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%A1%AC%E4%BB%B6%E6%BB%A4%E6%B3%A2%E5%8E%9F%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE"><span class="toc-number">5.4.1.</span> <span class="toc-text">1.硬件滤波原理与配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%BD%AF%E4%BB%B6%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95"><span class="toc-number">5.4.2.</span> <span class="toc-text">2.软件滤波算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">5.4.3.</span> <span class="toc-text">3.代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%A1%AC%E4%BB%B6%E6%BB%A4%E6%B3%A2%E4%BB%A3%E7%A0%81"><span class="toc-number">5.4.3.1.</span> <span class="toc-text">1.硬件滤波代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%BD%AF%E4%BB%B6%E6%BB%A4%E6%B3%A2%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-number">5.4.3.2.</span> <span class="toc-text">2.软件滤波代码：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%B0%83%E8%AF%95%E4%B8%8E%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3-1"><span class="toc-number">5.4.3.3.</span> <span class="toc-text">3.调试与问题解决</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">5.5.</span> <span class="toc-text">5.快速排序的使用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E6%A6%82%E8%BF%B0"><span class="toc-number">5.5.1.</span> <span class="toc-text">快速排序概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#qsort%E5%87%BD%E6%95%B0%E7%AE%80%E4%BB%8B"><span class="toc-number">5.5.2.</span> <span class="toc-text">qsort函数简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.5.3.</span> <span class="toc-text">代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%8E%92%E5%BA%8F%E6%95%B4%E6%95%B0%E6%95%B0%E7%BB%84"><span class="toc-number">5.5.3.1.</span> <span class="toc-text">1. 排序整数数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%8E%92%E5%BA%8F%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84"><span class="toc-number">5.5.3.2.</span> <span class="toc-text">2. 排序结构体数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%AE%B2%E8%A7%A3"><span class="toc-number">5.5.4.</span> <span class="toc-text">代码讲解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%8E%92%E5%BA%8F%E6%95%B4%E6%95%B0%E6%95%B0%E7%BB%84-1"><span class="toc-number">5.5.4.1.</span> <span class="toc-text">1. 排序整数数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%8E%92%E5%BA%8F%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84-1"><span class="toc-number">5.5.4.2.</span> <span class="toc-text">2. 排序结构体数组</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95"><span class="toc-number">5.6.</span> <span class="toc-text">6.二分查找法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">5.6.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">5.6.1.1.</span> <span class="toc-text">1. 时间复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">5.6.1.2.</span> <span class="toc-text">2. 应用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">5.6.2.</span> <span class="toc-text">基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="toc-number">5.6.3.</span> <span class="toc-text">实现细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">5.6.4.</span> <span class="toc-text">代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8D%87%E5%BA%8F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">5.6.4.1.</span> <span class="toc-text">1. 升序二分查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%99%8D%E5%BA%8F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">5.6.4.2.</span> <span class="toc-text">2. 降序二分查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8D%87%E5%BA%8F%E6%9F%A5%E6%89%BE%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E5%85%83%E7%B4%A0%E4%B8%8B%E6%A0%87"><span class="toc-number">5.6.4.3.</span> <span class="toc-text">3. 升序查找最接近目标值的元素下标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%99%8D%E5%BA%8F%E6%9F%A5%E6%89%BE%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E5%85%83%E7%B4%A0%E4%B8%8B%E6%A0%87"><span class="toc-number">5.6.4.4.</span> <span class="toc-text">4. 降序查找最接近目标值的元素下标</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%AE%B2%E8%A7%A3-1"><span class="toc-number">5.6.5.</span> <span class="toc-text">代码讲解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8D%87%E5%BA%8F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-1"><span class="toc-number">5.6.5.1.</span> <span class="toc-text">1. 升序二分查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%99%8D%E5%BA%8F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-1"><span class="toc-number">5.6.5.2.</span> <span class="toc-text">2. 降序二分查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8D%87%E5%BA%8F%E6%9F%A5%E6%89%BE%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E5%85%83%E7%B4%A0%E4%B8%8B%E6%A0%87-1"><span class="toc-number">5.6.5.3.</span> <span class="toc-text">3. 升序查找最接近目标值的元素下标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%99%8D%E5%BA%8F%E6%9F%A5%E6%89%BE%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E5%85%83%E7%B4%A0%E4%B8%8B%E6%A0%87-1"><span class="toc-number">5.6.5.4.</span> <span class="toc-text">4. 降序查找最接近目标值的元素下标</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E4%B8%8E%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3"><span class="toc-number">5.6.6.</span> <span class="toc-text">调试与问题解决</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E4%BC%A0%E6%84%9F%E5%99%A8%E4%BB%BB%E5%8A%A1%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA"><span class="toc-number">5.7.</span> <span class="toc-text">7.传感器任务框架搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0"><span class="toc-number">5.7.1.</span> <span class="toc-text">1. 分层架构概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%A9%B1%E5%8A%A8%E5%B1%82%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">5.7.2.</span> <span class="toc-text">2. 驱动层的设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">5.7.3.</span> <span class="toc-text">3. 数据结构设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%A9%B1%E5%8A%A8%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.7.4.</span> <span class="toc-text">4. 驱动层实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%BA%94%E7%94%A8%E5%B1%82%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.7.5.</span> <span class="toc-text">5. 应用层的设计与实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">5.7.5.1.</span> <span class="toc-text">5.1 任务调度结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6%E5%87%BD%E6%95%B0"><span class="toc-number">5.7.5.2.</span> <span class="toc-text">5.2 任务处理与调度函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E7%83%AD%E6%95%8F%E7%94%B5%E9%98%BB"><span class="toc-number">5.8.</span> <span class="toc-text">8.热敏电阻</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AE%80%E4%BB%8B"><span class="toc-number">5.8.1.</span> <span class="toc-text">1. 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">5.8.1.1.</span> <span class="toc-text">1. 工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1"><span class="toc-number">5.8.1.2.</span> <span class="toc-text">2.1 电路设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E6%B8%A9%E5%BA%A6%E4%B8%8E%E9%98%BB%E5%80%BC%E5%85%B3%E7%B3%BB"><span class="toc-number">5.8.1.3.</span> <span class="toc-text">2.2 温度与阻值关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%94%B5%E5%8E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.8.1.4.</span> <span class="toc-text">2. 电压转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E5%88%86%E5%8E%8B%E5%85%AC%E5%BC%8F"><span class="toc-number">5.8.1.5.</span> <span class="toc-text">3.1 分压公式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E7%A4%BA%E4%BE%8B%E8%AE%A1%E7%AE%97"><span class="toc-number">5.8.1.6.</span> <span class="toc-text">3.2 示例计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%B8%A9%E5%BA%A6%E8%AE%A1%E7%AE%97"><span class="toc-number">5.8.1.7.</span> <span class="toc-text">3. 温度计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84"><span class="toc-number">5.8.1.8.</span> <span class="toc-text">4.1 直接映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E7%B2%BE%E5%BA%A6%E6%8F%90%E5%8D%87"><span class="toc-number">5.8.1.9.</span> <span class="toc-text">4.2 精度提升</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">5.8.2.</span> <span class="toc-text">2. 代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E6%B9%BF%E6%95%8F%E7%94%B5%E9%98%BB"><span class="toc-number">5.9.</span> <span class="toc-text">9.湿敏电阻</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AE%80%E4%BB%8B-1"><span class="toc-number">5.9.1.</span> <span class="toc-text">1. 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%9B%B8%E5%AF%B9%E6%B9%BF%E5%BA%A6%E4%B8%8E%E7%BB%9D%E5%AF%B9%E6%B9%BF%E5%BA%A6"><span class="toc-number">5.9.1.1.</span> <span class="toc-text">1. 相对湿度与绝对湿度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%A9%B1%E5%8A%A8%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1"><span class="toc-number">5.9.1.2.</span> <span class="toc-text">2. 驱动电路设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%A9%B1%E5%8A%A8%E7%94%B5%E8%B7%AF%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">5.9.1.3.</span> <span class="toc-text">3. 驱动电路工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%9A%E6%A0%B9%E6%8D%AE%E6%B8%A9%E5%BA%A6%E8%8E%B7%E5%8F%96%E5%AF%B9%E5%BA%94%E6%B9%BF%E5%BA%A6%E7%9A%84ADC%E6%95%B0%E5%80%BC"><span class="toc-number">5.9.1.4.</span> <span class="toc-text">1：根据温度获取对应湿度的ADC数值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%9A%E6%A0%B9%E6%8D%AEADC%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97%E6%B9%BF%E5%BA%A6"><span class="toc-number">5.9.1.5.</span> <span class="toc-text">2：根据ADC数值计算湿度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-3"><span class="toc-number">5.9.2.</span> <span class="toc-text">2.代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RS485"><span class="toc-number">6.</span> <span class="toc-text">RS485</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-RS485%E5%8D%8F%E8%AE%AE%E8%A7%A3%E8%AF%BB"><span class="toc-number">6.1.</span> <span class="toc-text">1.RS485协议解读</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-RS485%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%A1%88"><span class="toc-number">6.2.</span> <span class="toc-text">2.RS485硬件电路两种方案</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MODBUS"><span class="toc-number">7.</span> <span class="toc-text">MODBUS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-MODBUS%E5%8D%8F%E8%AE%AE%E8%A7%A3%E8%AF%BB"><span class="toc-number">7.1.</span> <span class="toc-text">1.MODBUS协议解读</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-MODBUS%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="toc-number">7.2.</span> <span class="toc-text">2.MODBUS数据格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-MODBUS%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E5%88%86%E5%B1%82"><span class="toc-number">7.3.</span> <span class="toc-text">3.MODBUS软件架构分层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-FREEMODBUS%E7%A7%BB%E6%A4%8D"><span class="toc-number">7.4.</span> <span class="toc-text">4.FREEMODBUS移植</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BA%93%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D"><span class="toc-number">7.4.1.</span> <span class="toc-text">1.库文件介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E5%B7%A5%E7%A8%8B%E9%85%8D%E7%BD%AE"><span class="toc-number">7.4.2.</span> <span class="toc-text">2.代码工程配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%B7%BB%E5%8A%A0"><span class="toc-number">7.4.3.</span> <span class="toc-text">文件添加</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BC%96%E8%AF%91%E4%B8%8E%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3"><span class="toc-number">7.4.4.</span> <span class="toc-text">3.编译与错误解决</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BB%A3%E7%A0%81%E7%A7%BB%E6%A4%8D"><span class="toc-number">7.4.5.</span> <span class="toc-text">4.代码移植</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B"><span class="toc-number">7.4.6.</span> <span class="toc-text">1.初始化流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-UART"><span class="toc-number">7.4.6.1.</span> <span class="toc-text">1.UART</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-TIMER"><span class="toc-number">7.4.6.2.</span> <span class="toc-text">2.TIMER</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IIC"><span class="toc-number">8.</span> <span class="toc-text">IIC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-IIC%E5%8D%8F%E8%AE%AE%E8%A7%A3%E8%AF%BB"><span class="toc-number">8.1.</span> <span class="toc-text">1.IIC协议解读</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-IIC%E6%80%BB%E7%BA%BF%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="toc-number">8.2.</span> <span class="toc-text">2.IIC总线的数据格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%B5%B7%E5%A7%8B%E3%80%81%E5%81%9C%E6%AD%A2%E4%BF%A1%E5%8F%B7"><span class="toc-number">8.2.1.</span> <span class="toc-text">1.起始、停止信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8F%91%E9%80%81%E5%AD%97%E8%8A%82"><span class="toc-number">8.2.2.</span> <span class="toc-text">2.发送字节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%AF%BB%E5%8F%96%E5%AD%97%E8%8A%82"><span class="toc-number">8.2.3.</span> <span class="toc-text">3.读取字节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%8F%91%E9%80%81%E5%BA%94%E7%AD%94"><span class="toc-number">8.2.4.</span> <span class="toc-text">4.发送应答</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%8E%A5%E6%94%B6%E5%BA%94%E7%AD%94"><span class="toc-number">8.2.5.</span> <span class="toc-text">5.接收应答</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-EEPROM"><span class="toc-number">8.3.</span> <span class="toc-text">3.EEPROM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-ROM%E7%9A%84%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B"><span class="toc-number">8.3.1.</span> <span class="toc-text">1.ROM的发展历程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-EEPROM%E4%B8%8EFlash%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.3.2.</span> <span class="toc-text">2.EEPROM与Flash的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-AT24C02%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">8.3.3.</span> <span class="toc-text">3.AT24C02的工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%86%99%E6%95%B0%E6%8D%AE"><span class="toc-number">8.3.3.1.</span> <span class="toc-text">1.写数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%AF%BB%E6%95%B0%E6%8D%AE"><span class="toc-number">8.3.3.2.</span> <span class="toc-text">2.读数据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.3.4.</span> <span class="toc-text">4.代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%BD%AF%E4%BB%B6%E6%A8%A1%E6%8B%9FIIC"><span class="toc-number">8.3.4.1.</span> <span class="toc-text">1.软件模拟IIC</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%B5%B7%E5%A7%8B%E4%BF%A1%E5%8F%B7"><span class="toc-number">8.3.4.1.1.</span> <span class="toc-text">1.起始信号</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%81%9C%E6%AD%A2%E4%BF%A1%E5%8F%B7"><span class="toc-number">8.3.4.1.2.</span> <span class="toc-text">2.停止信号</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%8F%91%E9%80%81%E5%AD%97%E8%8A%82"><span class="toc-number">8.3.4.1.3.</span> <span class="toc-text">3.发送字节</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E8%AF%BB%E5%8F%96%E5%AD%97%E8%8A%82"><span class="toc-number">8.3.4.1.4.</span> <span class="toc-text">4.读取字节</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E5%8F%91%E9%80%81%E5%BA%94%E7%AD%94"><span class="toc-number">8.3.4.1.5.</span> <span class="toc-text">5.发送应答</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E6%8E%A5%E6%94%B6%E5%BA%94%E7%AD%94"><span class="toc-number">8.3.4.1.6.</span> <span class="toc-text">6.接收应答</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%A1%AC%E4%BB%B6IIC"><span class="toc-number">8.3.4.2.</span> <span class="toc-text">2.硬件IIC</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://source.fomal.cc/img/default_cover_5.webp')"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By Chilli</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><script defer src="/js/cursor.js"></script><script defer src="/js/light.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="30" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://ts1.cn.mm.bing.net/th/id/R-C.06ac7d7e5f4f81229e8c7eaf79bd0fef?rik=6dPa67mO8Xo88g&amp;riu=http%3a%2f%2fwww.faceui.com%2fapps%2fupload%2fimage%2f20200113%2f1578920626569170.jpg&amp;ehk=r2TM6AGvXY%2biZcXlEyyueiblv5fcSgYkC%2f2YJiGP3bE%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0);"> <a class="categoryBar-list-link" href="categories/嵌入式/">嵌入式</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr">嵌入式</span></li><li class="categoryBar-list-item" style="background:url(https://assets.akilar.top/image/cover2.webp);"> <a class="categoryBar-list-link" href="categories/数据结构/">数据结构</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">杂谈</span></li><li class="categoryBar-list-item" style="background:url(https://img-blog.csdnimg.cn/20200403105223468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzE1MTcx,size_16,color_FFFFFF,t_70);"> <a class="categoryBar-list-link" href="categories/杂谈/">杂谈</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr">蓝桥杯51</span></li><li class="categoryBar-list-item" style="background:url(https://img-blog.csdnimg.cn/194297a5d3f0433cadb188c17459bfcf.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBARXBpcGhhbnnmmpbpo44=,size_17,color_FFFFFF,t_70,g_se,x_16);"> <a class="categoryBar-list-link" href="categories/蓝桥杯51/">蓝桥杯51</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">蓝桥杯32</span></li><li class="categoryBar-list-item" style="background:url(https://assets.akilar.top/image/cover5.webp);"> <a class="categoryBar-list-link" href="categories/蓝桥杯32/">蓝桥杯32</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">杂谈</span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v6.2.0" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.3.1" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" data-title="本站采用多线部署，主线路托管于Vercel" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Vercel-brightgreen?style=flat&amp;logo=Vercel" alt=""/></a><a class="github-badge" target="_blank" href="https://dashboard.4everland.org/" style="margin-inline:5px" data-title="本站采用多线部署，备用线路托管于4EVERLAND" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-4EVERLAND-22DDDD?style=flat&amp;logo=IPFS" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="https://www.fomal.cc/static/js/runtime.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '1s');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '2');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>