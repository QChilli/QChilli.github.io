<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Blog | Blog</title><meta name="author" content="Chilli"><meta name="copyright" content="Chilli"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="title: GD32date: 2024 11-29 20:45:56type: “嵌入式”categories: 嵌入式tag: GD32 GPIO1.硬件结构1.工作原理 ​    单片机内部主要包括 CPU、Flash 存储器、RAM 内存和片上的外设。我们可以简单地将工作过程划分为四个步骤：  单片机上电后，CPU 从 Flash 中读取并响应代码指令。 根据指令，从片上的外设（例如光照">
<meta property="og:type" content="article">
<meta property="og:title" content="Blog">
<meta property="og:url" content="https://qchilli.github.io/2024/11/29/%E5%B5%8C%E5%85%A5%E5%BC%8F/GD32/index.html">
<meta property="og:site_name" content="Blog">
<meta property="og:description" content="title: GD32date: 2024 11-29 20:45:56type: “嵌入式”categories: 嵌入式tag: GD32 GPIO1.硬件结构1.工作原理 ​    单片机内部主要包括 CPU、Flash 存储器、RAM 内存和片上的外设。我们可以简单地将工作过程划分为四个步骤：  单片机上电后，CPU 从 Flash 中读取并响应代码指令。 根据指令，从片上的外设（例如光照">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://source.fomal.cc/img/default_cover_47.webp">
<meta property="article:published_time" content="2024-11-29T11:41:12.365Z">
<meta property="article:modified_time" content="2025-03-14T05:21:51.980Z">
<meta property="article:author" content="Chilli">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://source.fomal.cc/img/default_cover_47.webp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://qchilli.github.io/2024/11/29/%E5%B5%8C%E5%85%A5%E5%BC%8F/GD32/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Chilli","link":"链接: ","source":"来源: Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-right"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Blog',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2025-03-14 13:21:51'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/universe.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-butterfly-categories-card/lib/categorybar.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://www.fomal.cc/static/css/runtime.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw icon--article"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw icon-guidang1"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw icon-sekuaibiaoqian"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw icon-fenlei"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://source.fomal.cc/img/default_cover_47.webp')"><nav id="nav"><span id="blog-info"><a href="/" title="Blog"><span class="site-name">Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw icon--article"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw icon-guidang1"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw icon-sekuaibiaoqian"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw icon-fenlei"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">无题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-29T11:41:12.365Z" title="发表于 2024-11-29 19:41:12">2024-11-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-14T05:21:51.980Z" title="更新于 2025-03-14 13:21:51">2025-03-14</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">32.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>116分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>title: GD32<br>date: 2024 11-29 20:45:56<br>type: “嵌入式”<br>categories: 嵌入式<br>tag: GD32</p>
<h1 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h1><h2 id="1-硬件结构"><a href="#1-硬件结构" class="headerlink" title="1.硬件结构"></a>1.硬件结构</h2><h3 id="1-工作原理"><a href="#1-工作原理" class="headerlink" title="1.工作原理"></a>1.工作原理</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501182330703.png" alt></p>
<p>​    单片机内部主要包括 CPU、Flash 存储器、RAM 内存和片上的外设。我们可以简单地将工作过程划分为四个步骤：</p>
<ul>
<li>单片机上电后，CPU 从 Flash 中读取并响应代码指令。</li>
<li>根据指令，从片上的外设（例如光照强度传感器）获取数据。这些数据需要先保存在 RAM 内存中，然后进行进一步的数据处理。</li>
<li>经过加减乘除的运算，根据运算结果控制片上的外设（GPIO）来点亮或熄灭 LED 灯。</li>
<li>CPU 负责执行和响应代码指令，进行数学运算，往 RAM 内存里读写数据；Flash 存储器（ ROM 的一种实现方式）负责保存代码指令；RAM 内存负责在程序运行过程中保存变量数据；而片上外设则用来控制单片机外部的器件。</li>
</ul>
<h3 id="2-概念理解"><a href="#2-概念理解" class="headerlink" title="2.概念理解"></a>2.概念理解</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501191128046.png" alt></p>
<p>​    GPIO 是指芯片的通用输入输出管脚可将 GPIO 配置为输出模式，控制点亮发光二极管（LED）。也可作为输出控制打开或关闭继电器，配    置为输入模式来检测外部按键，甚至配置为模拟输入模式来检测热敏电阻，以获取温度数据。</p>
<p>​    因此，GPIO 既可以作为普通的 IO 口，也可以作为模拟输入，甚至作为 I²C 、SPI 、USART 的管脚。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501182340597.png" alt="-17328844853232"></p>
<p>​    CPU 是基于总线来进行工作，总线可以理解为高速公路，CPU 通过它与片上外设通信。外设内部会有寄存器，CPU 可以向寄存器写入或    读取数据，从而控制片上外设的状态。根据寄存器中的数据，GPIO 会相应地输出高低电平。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501182341051.png" alt="-17328844853233"></p>
<p>​    一个 GPIO 口的内部硬件结构可以分为两部分：上半部分对应输出，下半部分对应输入。</p>
<p>​    <strong>输出可以配置为四种模式：</strong></p>
<ul>
<li><p>推挽输出</p>
</li>
<li><p>开漏输出</p>
</li>
<li><p>推挽复用输出</p>
</li>
<li><p>开漏复用输出</p>
<p><strong>输入可以配置为四种模式：</strong></p>
</li>
<li><p>模拟输入</p>
</li>
<li><p>浮空输入</p>
</li>
<li><p>上拉输入</p>
</li>
<li><p>下拉输入</p>
</li>
</ul>
<h2 id="2-输出模式"><a href="#2-输出模式" class="headerlink" title="2.输出模式"></a>2.输出模式</h2><h3 id="1-输出结构"><a href="#1-输出结构" class="headerlink" title="1.输出结构"></a>1.输出结构</h3><p>数据来源有两种：<strong>普通的 GPIO 寄存器数据或备用功能寄存器的数据</strong>（即复用功能，例如 I²C、SPI 等）。</p>
<p>推挽输出和推挽复用输出的输出控制部分相同，只是数据来源可能不同。经过输出控制后，会有一个取反的效果后面是两个 MOS管，上面是 PMOS 管，下面是 NMOS 管。这两个 MOS 组成的电路就是推挽输出电路。</p>
<h4 id="1-推挽输出"><a href="#1-推挽输出" class="headerlink" title="1.推挽输出"></a>1.推挽输出</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501182341913.png" alt="-17328844853234"></p>
<p>​    假设寄存器的数据输出高电平，取反后为低电平。此时，NMOS 管截止，PMOS 管导通，连接到 VCC。输出高电平，LED 熄灭。</p>
<p>​    假设寄存器的数据输出低电平，取反后为高电平。此时， PMOS 管截止，NMOS 管导通，电流流向地，输出低电平，LED 亮。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501182341597.png" alt="-17328844853235"></p>
<p>​    假设寄存器输出高电平，取反后为低电平，PMOS 管导通，输出为高电平，LED 灯亮。此时电流由外部流向单片机的内部，再到 GND 。</p>
<p>​    假设寄存器输出低电平，取反后为高电平， NMOS 管导通，输出为低电平，LED 灯熄灭。</p>
<blockquote>
<p>​    对于 ARM 32 位单片机，GPIO 能够输出的最大电流为 25 毫安，因此驱动发光二极管是绰绰有余的。一般发光二极管需要的电流    约为 5 毫安左右。需要注意的是，并不是所有 GPIO 口都能输出 25 毫安电流，因为单片机本身也需要考虑功耗。对于单片机整体    输出电流一般在 200 毫安左右。</p>
</blockquote>
<h4 id="2-开漏输出"><a href="#2-开漏输出" class="headerlink" title="2.开漏输出"></a>2.开漏输出</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501182345744.png" alt="-17328844853236"></p>
<p>​    开漏输出的电路设计与推挽输出不同。在开漏输出中，去掉了上面的 PMOS 管，只留下 NMOS 管。这种设计称为开漏输出。</p>
<p>​    当寄存器输出为高电平，取反后为低电平，此时 NMOS 管截止，状态为高阻态，LED 灯熄灭。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501182346077.png" alt="-17328844853237"></p>
<p>​    当寄存器输出低电平，经过取反后为高电平，NMOS 导通，电流从 Vcc 流过，LED 灯被点亮。</p>
<p>​    因此，开漏输出的特点是只能提供低电平，而不能提供高电平。</p>
<h5 id="1-开漏输出优点"><a href="#1-开漏输出优点" class="headerlink" title="1.开漏输出优点"></a>1.开漏输出优点</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501182346951.png" alt="-17328844853238"></p>
<p>​    由开漏输出的特点可知，要提供高电平，必须在单片机的外部增加一个上拉电阻。</p>
<p>​    开漏输出的主要优点在于可以实现电平转换和线与功能。我们先来分析电平转换的过程：</p>
<p>​    假设负载需要 5V 供电，而单片机系统为 3.3V 时，可以将 Vcc 直接连接到 5V。如果单片机输出高电平，变为低电平，此时 NMOS 管截</p>
<p>​    止，Vcc 的电流通过上拉电阻拉高，输出为高电平。</p>
<h5 id="2-线与功能"><a href="#2-线与功能" class="headerlink" title="2.线与功能"></a>2.线与功能</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501182347799.png" alt="-17328844853239"></p>
<p>​    对于 I²C 协议，可以挂载多个 I²C 设备，如 EEPROM、触摸屏驱动芯片等。I²C 总线要求实现线与功能。根据逻辑，同一线上只要有一个设    备输出低电平，整个总线电平就会变为低。</p>
<p>​    <strong>推挽输出的结构无法实现线与功能，因其可能造成短路。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501182347796.png" alt="-173288448532310"></p>
<p>​    <strong>相反，开漏输出可以实现线与功能。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501182347805.png" alt="-173288448532311"></p>
<p>​    <strong>假设单片机输出高电平，取反后变为低电平，NMOS 管截止，此时总线电平为高电平。如果任何一个设备输出低电平，NMOS 管导通，</strong></p>
<p>​    <strong>电流流入地，整个总线电平则变为低电平。</strong></p>
<h3 id="3-地址分配"><a href="#3-地址分配" class="headerlink" title="3.地址分配"></a>3.地址分配</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501182352964.png" alt="-173288448532312"></p>
<p>​    这是寄存器的地址范围，以及 ARM 32 位单片机（如 STM32、GD32）的片上外设寄存器的基本信息。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501182348454.png" alt="-173288448532313"></p>
<p>​    对于 GPIO，有配置寄存器、数据寄存器和复用寄存器。配置寄存器用于设置 GPIO 口为输入或输出模式，数据寄存器用于在输入</p>
<p>​    模式下获取电平，在输出模式下控制电平。</p>
<h2 id="3-输入模式"><a href="#3-输入模式" class="headerlink" title="3.输入模式"></a>3.输入模式</h2><h3 id="1-硬件框架"><a href="#1-硬件框架" class="headerlink" title="1.硬件框架"></a>1.硬件框架</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501182349584.png" alt="-173288448532315"></p>
<ul>
<li>模拟输入：模拟输入是将外部的模拟信号通过 ADC 转换为数字量。</li>
<li>浮空输入</li>
<li>下拉输入</li>
<li>上拉输入</li>
</ul>
<h3 id="2-输入结构"><a href="#2-输入结构" class="headerlink" title="2.输入结构"></a>2.输入结构</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501182349542.png" alt="-173288448532316"></p>
<p>​    这三种输入模式可以将外部的数字信号转换为数字量 0 和 1。在输入驱动单元中包含上拉电阻、下拉电阻和施密特触发器。其中，施密特    触发器用于将外部的数字信号转换为 0 和 1。</p>
<p>​    转换后的信号有两个输出方向：</p>
<ul>
<li>可以输出给复用功能，比如串口的 RX 引脚。</li>
<li>可以输出给普通 GPIO 口的输入状态寄存器，通过读取寄存器中的数据来获取高低电平状态。</li>
</ul>
<blockquote>
<h6 id="对于-ARM-Cortex-M3-单片机，在转换过程中有以下特性："><a href="#对于-ARM-Cortex-M3-单片机，在转换过程中有以下特性：" class="headerlink" title="对于 ARM Cortex-M3 单片机，在转换过程中有以下特性："></a>对于 ARM Cortex-M3 单片机，在转换过程中有以下特性：</h6><ul>
<li>当外部信号电压大于等于 0.7 倍 VDD 时，认为是高电平（逻辑 1）。</li>
<li>当外部信号电压小于等于 0.3 倍 VDD 时，认为是低电平（逻辑 0）。</li>
</ul>
</blockquote>
<h4 id="1-浮空输入"><a href="#1-浮空输入" class="headerlink" title="1.浮空输入"></a>1.浮空输入</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202502212149653.png" alt="image-20250221214958597"></p>
<p>​    浮空输入模式下，输入驱动单元中的上拉电阻和下拉电阻是关闭的（没有使能），此时端口在单片机内部呈现为高阻态。这种模式的应用    场景，比如 GPIO 作为单片机串口的 RX 引脚时，就需要配置为浮空输入模式，外部连接其他器件的 TX 引脚。这样，端口的电平状态完全    取决于外部器件的 TX 引脚。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501182353305.png" alt="-173288448532318"></p>
<p>​    如果使用浮空输入模式来检测一个按键，假设按键的一端连接到 IO 口，另一端连接到地。当按键按下时，端口被拉低，通过施密特触发    器转换为数字量 0，输入状态寄存器通过读取寄存器数据判断为低电平，进而执行业务逻辑，这部分没有问题。但是当按键没有被按下</p>
<p>​    时，端口是悬空的，此时电平状态不确定，可能因为外部干扰而被误判为低电平，从而错误地执行业务逻辑。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501182354524.png" alt="-173288448532321"></p>
<p>​    上拉输入和下拉输入模式的使用频率相对较低，更多时候使用浮空输入模式。</p>
<p>​    采用浮空输入检测按键，需要在单片机外部额外加上上拉或下拉电阻，以确保在悬空时有明确的电平状态。通常，上拉电阻选择 2kΩ 到 </p>
<p>​    10kΩ 之间。</p>
<p>​    例如，开发板上使用浮空输入模式并在外部加上了上拉电阻来稳定电平。此外，有时在端口处串联一个限流电阻来保护端口。</p>
<h4 id="2-上拉输入"><a href="#2-上拉输入" class="headerlink" title="2.上拉输入"></a>2.上拉输入</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501182354019.png" alt="-173288448532319"></p>
<p>​    针对上述问题，可以采用上拉输入模式，将输入驱动单元的上拉电阻打开，使能。当按键没有按下时，端口通过上拉电阻被拉为高电平，    这样可以避免浮空输入模式下电平不确定的问题。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501182354019.png" alt="-173288448532319"></p>
<p>​    针对上述问题，可以采用上拉输入模式，将输入驱动单元的上拉电阻打开，使能。当按键没有按下时，端口通过上拉电阻被拉为高电平，    这样可以避免浮空输入模式下电平不确定的问题。</p>
<ul>
<li><strong>开关或按钮输入</strong>：当按钮未被按下时，输入状态为高电平。当按钮被按下时，输入状态被直接连接到地，变为低电平。</li>
<li><strong>防止悬空状态</strong>：在没有其他信号源时，上拉电阻确保输入端始终有一个已定义的高电平状态。</li>
<li><strong>开漏输出</strong>：在使用开漏（open-drain）输出的设备中，需要通过上拉电阻将信号拉高。</li>
</ul>
<h4 id="3-下拉输入"><a href="#3-下拉输入" class="headerlink" title="3.下拉输入"></a>3.下拉输入</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501182359434.png" alt="-173288448532320"></p>
<p>​    另一种按键驱动电路是按键连接到限流电阻，再连接到 VCC。对于这种电路，需使用下拉输入模式，也就是打开驱动单元中的下拉电阻，    使能。当按键没有按下时，端口通过下拉电阻被拉到低电平；当按键按下时，电流从外部流入单片机内部，端口电平被拉高。</p>
<ul>
<li><strong>开关或按钮输入</strong>：当按钮未被按下时，输入状态为低电平。当按钮被按下时，输入状态被直接连接到电源，变为高电平。</li>
<li><strong>防止悬空状态</strong>：在没有其他信号源时，下拉电阻确保输入端始终有一个已定义的低电平状态。</li>
<li><strong>反相输入</strong>：当输入信号需要反转时，使用下拉电阻可使高电平输入对应低电平输出。</li>
</ul>
<blockquote>
<p>单片机内部的上拉和下拉电阻，典型值为 40 kΩ ，而限流电阻通常选择 1kΩ 。</p>
</blockquote>
<h2 id="4-输出速度"><a href="#4-输出速度" class="headerlink" title="4.输出速度"></a>4.输出速度</h2><h3 id="1-输出速度定义"><a href="#1-输出速度定义" class="headerlink" title="1.输出速度定义"></a>1.输出速度定义</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501182355812.png" alt="-173288448532322"></p>
<p>​    如果用<code>t</code>来表示周期，那么<code>f = 1/t</code>。假设我们将输出速度设置为10MHz，那么周期<code>t</code>就等于：十的九次方除以10M，也就是十的七    次方纳秒，即100纳秒。</p>
<h3 id="2-输出速度影响"><a href="#2-输出速度影响" class="headerlink" title="2.输出速度影响"></a>2.输出速度影响</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501182355364.png" alt="-173288448532323"></p>
<p>​    理想情况下，单片机输出高低电平应该是一个方波，但实际上这个过程是有上升时间（<code>tr</code>）和下降时间（<code>tf</code>）过程的。在单片机的</p>
<p>​    手册中明确说明了，为了保证输出有效的高低电平，<code>tr + tf</code>必须小于等于周期<code>t</code>的三分之二。</p>
<ul>
<li>输出速度设置输出速度为10MHz，那么周期<code>t</code>是100纳秒，则：<code>tr + tf &lt;  2 * t / 3 = 67</code>。</li>
</ul>
<p>​    所以，<code>tr</code>和<code>tf</code>的总和需要小于67纳秒，通常每个时间段大约是 33 ~ 34 纳秒。</p>
<ul>
<li>输出速度设置为50MHz，那么周期<code>t</code>是20纳秒，则：<code>tr + tf &lt; 2 * t / 3 = 13</code>。</li>
</ul>
<p>​    这样，<code>tr</code>和<code>tf</code>每个大约是6-7纳秒左右。因此，设置GPIO口的输出速度越高，<code>tr</code>和<code>tf</code>就要控制得越小，上升和下降的过程    越陡峭。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501182356110.png" alt="-173288448532324"></p>
<p>​    单片机的GPIO口输出信号去控制一个外设负载，这个负载可以等效为一个电容<code>CL</code>，因为电容会影响电压变化的速率。</p>
<p>​    输出高低电平的过程，其实就是对电容的充放电过程，我们可以用电容充电公式来表示：</p>
<p>​    其中，<code>dv/dt</code>表示电压变化的速率。因此，在负载电容值<code>CL</code>一定的情况下，电压变化速率越快，所需电流<code>I</code>越大，电流越大</p>
<p>​    就会导致单片机的功耗增加。此外，输出频率越高，还会涉及到EMI（电磁干扰）的问题。</p>
<p>​    </p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501182356278.png" alt="-173288448532325"></p>
<ul>
<li>当输出速度为 2MHz ，负载电容<code>Cl</code>为 50pF 时，通过输出一定电流，<code>tr</code>和<code>tf</code>可以控制在 125 纳秒以下。</li>
<li>当输出速度为 10MHz ，负载电容<code>Cl</code>为 50pF 时，通过输出一定电流，<code>tr</code>和<code>tf</code>可以控制在 25 纳秒以下。</li>
<li>当输出速度为 50MHz ，负载电容<code>Cl</code>为 30pF 时，<code>tr</code>和<code>tf</code>大约是 5纳秒；而当<code>Cl</code>为 50pF 时，<code>tr</code>和<code>tf</code>大约是 8 纳秒。</li>
</ul>
<blockquote>
<ul>
<li>如果我们要控制一个简单的发光二极管，配置成 2MHz 的输出速度即可。</li>
<li>如果我们要驱动 SD 卡，则需要配置 50MHz 的输出速度。</li>
</ul>
</blockquote>
<h1 id="CLOCKTREE"><a href="#CLOCKTREE" class="headerlink" title="CLOCKTREE"></a>CLOCKTREE</h1><p>时钟对于单片机来说就像是人的心脏，非常重要。时钟为单片机提供心跳节拍，<strong>CPU 根据时钟的跳动来执行代码指令</strong>。</p>
<p>时钟频率越高，代码指令执行得越快，系统性能也越高；反之，时钟越慢，执行也越慢。</p>
<h2 id="1-单片机架构"><a href="#1-单片机架构" class="headerlink" title="1.单片机架构"></a>1.单片机架构</h2><h3 id="1-51-单片机"><a href="#1-51-单片机" class="headerlink" title="1. 51 单片机"></a>1. 51 单片机</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190003993.png" alt="-173288448532426"></p>
<p>​    单片机内部有很多组件，包 CPU 、片上外设 (如 Flash、RAM、定时器、串口等)。CPU 通过总线访问这些片上外设。</p>
<h3 id="2-32-单片机"><a href="#2-32-单片机" class="headerlink" title="2. 32 单片机"></a>2. 32 单片机</h3><h4 id="1-架构设计"><a href="#1-架构设计" class="headerlink" title="1.架构设计"></a>1.架构设计</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190003699.png" alt="-173288448532427"></p>
<p>​    ARM Cortex M4 有三个总线接口，即 ICode 总线、DCode 总线和系统总线接口。</p>
<ul>
<li>ICode 总线接口用于连接并访问 Flash 获取代码指令</li>
<li>DCode 总线接口连接并访问 Flash 获取数据</li>
<li>系统总线接口则用于连接并访问 RAM 和片上外设。</li>
</ul>
<h4 id="2-外设分布"><a href="#2-外设分布" class="headerlink" title="2.外设分布"></a>2.外设分布</h4><p>ICode 和 DCode 总线对应的分别是 IBus 和 DBus，它们从 Flash 中获取代码指令和数据。系统总线接口对应的是 AHB 总线，用于连接访问片上外设，如 FMC、SDIO、CRC、RCU 等。</p>
<p>基于 AHB 总线，派生出两个 APB 总线：APB1 和 APB2。APB1 总线连接看门狗、定时器、串口、SPI 等外设， APB2 总线连接串口 0、SPI 0、ADC 等外设。</p>
<h2 id="2-时钟系统架构"><a href="#2-时钟系统架构" class="headerlink" title="2.时钟系统架构"></a>2.时钟系统架构</h2><blockquote>
<h6 id="时钟树简易框图如下："><a href="#时钟树简易框图如下：" class="headerlink" title="时钟树简易框图如下："></a>时钟树简易框图如下：</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190004761.png" alt="-173288448532429"></p>
<ul>
<li>振荡器 (黄色)：内部有 3 个振荡器，外部有 2 个。</li>
<li>锁相环 (PLL)：对输入时钟进行倍频。</li>
<li>分频器 (绿色)：对输入时钟进行分频。</li>
<li>片上外设 (蓝色)：例如 USB、SDIO、FMC 等。</li>
</ul>
</blockquote>
<h2 id="3-时钟系统分布"><a href="#3-时钟系统分布" class="headerlink" title="3.时钟系统分布"></a>3.时钟系统分布</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190004165.png" alt="-173288448532430"></p>
<ul>
<li><strong>系统时钟：</strong>对于 GD32F303 MCU，其主频最高为 120MHz，经过 AHB 分频器后，生成 AHB 时钟，供给 AHB 外设，如 EXMC、SDIO 等。</li>
<li><strong>APB 时钟：</strong>经过 APB1 分频器，生成 APB1 时钟，最大为 60MHz，供给 APB1 外设。类似地，APB2 时钟最大为 120MHz，供给 APB2 外设。</li>
<li><strong>USB 外设：</strong>USB 是一种高速串行接口，需要精确的时钟。其时钟来源可以是 PLL 输出的时钟，也可以是内部的 IRC 48MHz 振荡器，经过分频器生成固定的 48MHz 时钟，供给 USB 外设。</li>
<li><strong>PLL 锁相环：</strong>其输入时钟来源可以是内部的 IRC 8MHz 振荡器，也可以是外部的高速晶振。内部的 IRC 8MHz 振荡器精度较低，适用于一些简单的控制任务，而对通信有要求的应用通常使用外部晶振以提高精度。</li>
<li><strong>RTC 实时时钟：</strong>输入来源有 3 个：外部高速晶振（需分频）、外部低速晶振（32.768kHz）以及内部的 IRC 40kHz 振荡器。通常选择低速晶振，以降低功耗。内部的 40kHz 振荡器则用于独立看门狗提供时钟。</li>
</ul>
<h2 id="4-内核-DWT-延时"><a href="#4-内核-DWT-延时" class="headerlink" title="4.内核 DWT 延时"></a>4.内核 DWT 延时</h2><h3 id="1-延时原理"><a href="#1-延时原理" class="headerlink" title="1.延时原理"></a>1.延时原理</h3><h3 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2.代码实现"></a>2.代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="NVIC"><a href="#NVIC" class="headerlink" title="NVIC"></a>NVIC</h1><h2 id="1-中断系统"><a href="#1-中断系统" class="headerlink" title="1.中断系统"></a>1.中断系统</h2><h3 id="1-概念理解"><a href="#1-概念理解" class="headerlink" title="1.概念理解"></a>1.概念理解</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190009507.png" alt="-173288448532431"></p>
<p>​    假设我正在看书，突然有人敲门，那么我需要放下书去开门查看情况，处理完后再回到座位继续看书。过一会儿，水烧开了，我又需要放    下书去关火、倒水。在这个过程中，敲门声和水开了的提示都会打断我正在执行的任务（看书），去处理更紧急、更高优先级的事情（开    门、关火倒水）。</p>
<p>​    <strong>类比单片机中断系统：</strong></p>
<ul>
<li>看书是单片机系统执行的主流程任务。</li>
<li>敲门声、水开了是中断触发源。</li>
<li>开门、关火倒水是中断服务函数。</li>
<li>中断处理之所以发生，是因为这些事件的优先级比当前任务（看书）更高。</li>
</ul>
<h3 id="2-单片机中断概念"><a href="#2-单片机中断概念" class="headerlink" title="2.单片机中断概念"></a>2.单片机中断概念</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190010567.png" alt="-173288448532432"></p>
<p>​    在 ARM 单片机中，中断的统称是异常，中断只是异常的一个子集。</p>
<ul>
<li>系统异常：由内核产生，比如系统复位异常、总线访问异常、硬错误异常、SysTick（滴答定时器）异常等。</li>
<li>中断：由片上外设产生，比如串口中断、定时器中断、ADC 中断、GPIO 引脚对应的 EXTI 外部中断等。</li>
</ul>
<h4 id="1-异常触发源"><a href="#1-异常触发源" class="headerlink" title="1.异常触发源"></a>1.异常触发源</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190010635.png" alt="-173288448532433"></p>
<ul>
<li>系统复位异常：比如手动复位或掉电都会触发系统复位异常。</li>
<li>硬件故障异常（HardFault）：比如代码中存在除数为零的错误就会触发硬错误异常。</li>
<li>总线访问异常：例如访问内存时没有按 4 字节对齐，就会触发总线访问异常。</li>
<li>SysTick 异常：滴答定时器的异常。</li>
<li>外设中断：比如 ADC、串口、定时器、EXTI 等。</li>
</ul>
<h4 id="2-异常空间分配"><a href="#2-异常空间分配" class="headerlink" title="2.异常空间分配"></a>2.异常空间分配</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190010313.png" alt="-173288448532434"></p>
<p>​    这些异常触发源在 Flash 中需要分配存储空间，每个触发源对应 4 个字节的存储空间。</p>
<p>​    <strong>例如：</strong></p>
<ul>
<li>系统复位异常的存储空间是 0x04 到 0x07。</li>
<li>NMI（非屏蔽中断）的存储空间是 0x08 到 0x0B。</li>
<li>SysTick 的存储空间是 0x3C 到 0x3F。</li>
</ul>
<p>​    <strong>例如：</strong></p>
<ul>
<li>系统复位异常的编号是 1，它的起始地址就是 1 × 4 = 0x04。</li>
<li>SysTick 的编号是 15，起始地址是 15 × 4 = 0x3C。</li>
</ul>
<blockquote>
<p><strong>存储器映射将 Flash 的地址空间从 0x00000000 映射到 0x08000000，目的是实现 ARM 单片机的几种启动模式：从 Flash 启动、从 RAM 启动、以及从预置的 Bootloader 启动。不同的启动模式下地址映射不同。</strong></p>
</blockquote>
<h4 id="3-中断执行流程"><a href="#3-中断执行流程" class="headerlink" title="3.中断执行流程"></a>3.中断执行流程</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190010261.png" alt="-173288448532435"></p>
<ul>
<li>当我们手动复位或单片机掉电，会触发系统复位异常。</li>
<li>NVIC 首先通过系统复位异常的编号（1），计算出其对应的存储空间（0x04 到 0x07），然后从该存储空间中获取中断服务函数的地址，最终调用该中断服务函数。</li>
</ul>
<h2 id="2-EXTI-中断"><a href="#2-EXTI-中断" class="headerlink" title="2. EXTI 中断"></a>2. EXTI 中断</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190012522.png" alt="-173288448532436"></p>
<p>​    EXTI 可以用来检测 GPIO 口作为输入模式时的高低电平变化，进而触发上升沿或下降沿中断。</p>
<p>​    <strong>例如：</strong></p>
<p>​    利用它来检测按键按下动作。当按键未按下时是高电平，按下时发生跳变为低电平，这是一个下降沿，可以触发 EXTI 中断。环境传感器     AP3216C ，可感知是否有物体靠近，当达到一定阈值时会从高电平跳变到低电平，这也是一个下降沿，同样可以产生 EXTI 中断。</p>
<blockquote>
<p><strong>GPIO 并不是直接连接到 NVIC 中断控制器的，而是通过 EXTI 控制器中转。EXTI 控制器和 NVIC 都包含了一些寄存器，用于控制中断触发和管理。</strong></p>
</blockquote>
<h3 id="1-硬件连接结构"><a href="#1-硬件连接结构" class="headerlink" title="1.硬件连接结构"></a>1.硬件连接结构</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190012593.png" alt="-173288448532437"></p>
<p>​    EXTI 控制器位于 GPIO 和 NVIC 之间。以 EXTI 线 0 为例，它可以连接到 PA0 到 PG0 中的任意一个 GPIO 口。在 EXTI 控制器中有一个选择    器，用于选择哪个 GPIO 口连接到 EXTI 线。可以配置为上升沿、下降沿或上升沿和下降沿同时触发中断。</p>
<p>​    <strong>同一时刻 EXTI 线只能连接一个 GPIO 。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190012880.png" alt="-173288448532438"></p>
<p>​    <strong>如果配置 PA0 连接到 EXTI 线 0，随后再配置 PB0 连接到 EXTI 线 0，那么 PA0 的连接会失效。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190012231.png" alt="-173288448532439"></p>
<p>​    EXTI 线 9-5 和 15-10 的中断源与前面的 EXTI 线 0-4 不同，前者共用一个中断触发源和中断服务函数。</p>
<h3 id="2-中断优先级"><a href="#2-中断优先级" class="headerlink" title="2.中断优先级"></a>2.中断优先级</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190013120.png" alt="-173288448532440"></p>
<p>​    优先级主要应用在两个场景中：</p>
<ul>
<li>多个中断同时触发时，决定先处理哪个中断。 例如，我正在看书，同时听到敲门声和水烧开的声音，我需要决定是先去开门还是先关火。</li>
<li>中断抢占：当一个中断服务函数正在执行时，另一个中断到来，决定是否打断当前中断去处理新的中断。</li>
</ul>
<blockquote>
<p>在 ARM 单片机中，通过配置 NVIC 控制器的寄存器来实现中断优先级控制。涉及的寄存器有两个：IP 和 AIRCR。</p>
<ul>
<li>IP 寄存器：每个中断源对应一个 8 位宽度的 IP 寄存器，单片机只使用高 4 位（Bit 4 到 Bit 7），数值范围是 0 到 15。</li>
<li>AIRCR 寄存器：用于配置优先级分组，一共有 5 组（0 到 4），通过配置 AIRCR 的第 8 到第 10 位实现。</li>
</ul>
</blockquote>
<h4 id="1-优先级分组"><a href="#1-优先级分组" class="headerlink" title="1.优先级分组"></a>1.优先级分组</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190013253.png" alt="-173288448532441"></p>
<ul>
<li>第 0 组：0 位用于抢占优先级，4 位用于子优先级。</li>
<li>第 4 组：4 位用于抢占优先级，0 位用于子优先级。</li>
</ul>
<p>​    目的是为了灵活设置优先级，使得不同场景下的中断处理更为有效。</p>
<blockquote>
<p><strong>有些异常中断的优先级是固定的，例如复位、NMI（非屏蔽中断）、硬件错误中断等，它们的优先级分别为 -3、-2、-1，复位中断的优先级最高。其他异常中断则可以根据需要进行优先级配置。</strong></p>
</blockquote>
<h4 id="2-执行顺序"><a href="#2-执行顺序" class="headerlink" title="2.执行顺序"></a>2.执行顺序</h4><blockquote>
<p>实际开发中，通常<strong>先配置优先级分组</strong>，<strong>再设置抢占优先级和子优先级</strong>。</p>
<ul>
<li>如果两个中断同时发生，首先判断抢占优先级，数值越小优先级越高。如果抢占优先级相同，则判断子优先级，数值越小优先级越高。</li>
<li>如果一个中断正在执行，另一个中断到来，是否抢占取决于抢占优先级。</li>
<li>例如，如果中断 A 正在执行，中断 B 到来，B 的抢占优先级高（数值小于）于 A，则 B 会打断 A。</li>
<li>例如，如果中断 A 正在执行，中断 B 到来，B 的抢占优先级与 A相同，则 B 不会打断 A。</li>
</ul>
<p>优先级的配置会影响中断的嵌套关系，例如分组为 2 时支持 4 级中断嵌套，分组为 4 时支持 16 级中断嵌套。</p>
</blockquote>
<h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3.代码实现"></a>3.代码实现</h2><p>​    通过 EXTI 中断方式检测 K1 按键。对应的引脚是 PA0，与 EXTI 线 0 相连接。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190014548.png" alt="-173288448532443"></p>
<p>​    <strong>配置和初始化过程</strong>可以分为两部分：</p>
<ul>
<li>第一部分是初始化 GPIO，包括使能 GPIO 的时钟，并配置为输入模式。</li>
<li>第二部分是初始化 EXTI，分为五个步骤：<ul>
<li>使能 EXTI 外设的时钟。</li>
<li>配置引脚连接到 EXTI 线，并设置上升沿或下降沿触发。</li>
<li>清除中断标志位。</li>
<li>使能中断。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f30x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led_drv.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">GPIOInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	rcu_periph_clock_enable(RCU_GPIOA);</span><br><span class="line">	gpio_init(GPIOA, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_2MHZ, GPIO_PIN_0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">EXTIInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 使能EXTI时钟 */</span></span><br><span class="line">	rcu_periph_clock_enable(RCU_AF);</span><br><span class="line">	<span class="comment">/* I/O连接到EXTI线 */</span></span><br><span class="line">	gpio_exti_source_select(GPIO_PORT_SOURCE_GPIOA, GPIO_PIN_SOURCE_0);</span><br><span class="line">	<span class="comment">/* 配置下降沿 */</span></span><br><span class="line">	exti_init(EXTI_0, EXTI_INTERRUPT, EXTI_TRIG_FALLING);</span><br><span class="line">	<span class="comment">/* 清除标志 */</span></span><br><span class="line">	exti_interrupt_flag_clear(EXTI_0);</span><br><span class="line">	<span class="comment">/* 使能中断 */</span></span><br><span class="line">	nvic_irq_enable(EXTI0_IRQn, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief 按键硬件初始化</span></span><br><span class="line"><span class="comment">* @param</span></span><br><span class="line"><span class="comment">* @return </span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">KeyInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIOInit();</span><br><span class="line">	EXTIInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在实现使能中断时，使用 NVIC 的接口函数 <code>nvic_irq_enable</code>，其参数为中断源、抢占优先级和子优先级。默认情况下，优先级分组设置为抢占优先级 2 位，子优先级 2 位，范围为 0 到 3。</p>
<p>仿真调试时，可以通过 J-Link 连接进行单步跟踪，了解 NVIC IRQ Enable 函数的执行过程。在寄存器中，可以看到优先级分组的配置和变化。</p>
<blockquote>
<p><strong>初始化外部中断时，清除 EXTI 中断标志位就是清除对应 EXTI 中断线的标志位。</strong></p>
<p>清除对应的中断线原因：</p>
<ul>
<li><strong>避免中断干扰</strong></li>
</ul>
<p>在中断控制器配置期间，如果不清除先前的中断状态，可能会导致意外的中断触发。这会影响系统的稳定性和可靠性，甚至可能导致错误的处理流程。因此，清除中断线可以确保在配置新中断时，不会被之前未处理的中断干扰。</p>
<ul>
<li><strong>保证中断服务程序的正确执行</strong></li>
</ul>
<p>如果不清除中断线，系统可能会在配置过程中立即响应旧的中断信号，从而触发中断服务例程（ISR）。这可能导致中断服务例程执行时，硬件资源尚未正确配置，进而引发不可预期的错误。因此，清除中断线可以确保只有在配置完成后，新的中断才会被响应。</p>
<ul>
<li><strong>提高中断处理的效率</strong></li>
</ul>
<p>通过清除中断线，系统能够更快速地识别和响应新的中断信号。当中断控制器检测到一个中断请求时，它将检查相应的中断线状态。如果这些中断线在配置期间被清除，系统可以在收到新的中断请求时更加高效地进行处理。</p>
<ul>
<li><strong>避免误判和重复触发</strong></li>
</ul>
<p>如果中断线未被清除，可能导致系统误判当前的中断状态，重复触发同一个中断。这不仅浪费了处理资源，还可能导致数据损坏或系统崩溃。因此，清除中断线是一种防范机制，可以帮助确保中断处理的准确性。</p>
</blockquote>
<h3 id="1-问题一：没有中断服务函数"><a href="#1-问题一：没有中断服务函数" class="headerlink" title="1.问题一：没有中断服务函数"></a><strong>1.问题一：没有中断服务函数</strong></h3><h4 id="1-问题一：有主循环"><a href="#1-问题一：有主循环" class="headerlink" title="1.问题一：有主循环"></a>1.问题一：有主循环</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f30x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key_drv.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	DelayInit();</span><br><span class="line">	LedInit();</span><br><span class="line">	KeyInit();</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/11/29/%E5%B5%8C%E5%85%A5%E5%BC%8F/GD32/Users/Administrator/Desktop/202412121521569.png" alt="QQ20241212-151901"></p>
<p><strong>如果此时运行程序，由于初始化了 EXTI 并使能了中断，但没有实现中断服务函数，会导致程序进入汇编代码里面默认的中断服务函数，即死循环。</strong></p>
<h4 id="2-问题二：没有主函数循环"><a href="#2-问题二：没有主函数循环" class="headerlink" title="2.问题二：没有主函数循环"></a><strong>2.问题二：没有主函数循环</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f30x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led_drv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key_drv.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	DelayInit();</span><br><span class="line">	LedInit();</span><br><span class="line">	KeyInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/11/29/%E5%B5%8C%E5%85%A5%E5%BC%8F/GD32/Users/Administrator/Desktop/202412121527992.png" alt="QQ20241212-152728"></p>
<p>在程序执行完 <code>main()</code> 后，如果没有 <code>while(1)</code> 并且刚好触发了外部中断，程序的行为和有 <code>while(1)</code> 的情况是类似的，都会进入汇编启动文件的 <code>B .</code> 死循环，而不会直接执行硬件错误中断。</p>
<blockquote>
<p>如果没有 <code>while(1)</code>，并且程序执行完 <code>main()</code> 后，控制流会进入未定义区域。若此时发生外部中断，处理器会尝试跳转到 ISR，但如果 ISR 未定义或中断处理机制不完善，可能导致错误（如程序跳转到非法地址），从而触发 <code>HardFault</code>中断。</p>
<p><strong>没有为外部中断编写相应的服务函数（ISR）</strong> 是导致 <strong>HardFault</strong> 的 <strong>主要原因</strong>，而 <strong>while(1)</strong> 只是一个 <strong>次要原因</strong>。</p>
</blockquote>
<h3 id="2-问题二：未清除标志位"><a href="#2-问题二：未清除标志位" class="headerlink" title="2.问题二：未清除标志位"></a>2.问题二：未清除标志位</h3><p>验证一个问题：GPIO 口连接到 EXTI 线时，同一时刻只能有一个 IO 口连接。</p>
<blockquote>
<p><strong>现在连接的是 PA0，如果再配置 PC0 连接到 EXTI 线：</strong></p>
<p>复位后按下 K1 没有反应，去掉 PC0 配置后，按下 K1，LED 灯亮，再按下灭。</p>
</blockquote>
<p>如果在 EXTI 中断服务函数中不清除标志位会发生什么情况。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief EXTI0中断服务函数，对应PA0</span></span><br><span class="line"><span class="comment">* @param</span></span><br><span class="line"><span class="comment">* @return </span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI0_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (exti_interrupt_flag_get(EXTI_0) != RESET)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 清除外部中断线 */</span></span><br><span class="line">		<span class="comment">//exti_interrupt_flag_clear(EXTI_0);</span></span><br><span class="line">		ToggleLed(LED1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在中断服务函数中设置一个断点，全速运行，按下 K1。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/11/29/%E5%B5%8C%E5%85%A5%E5%BC%8F/GD32/Users/Administrator/Desktop/202412121826256.png" alt="QQ20241212-182625"></p>
<p>可以看到程序停在断点处，再次全速执行并按下K1，程序不断进入中断服务函数。</p>
<p><strong>因此，对于 EXTI 中断服务函数，必须清除中断标志位。</strong></p>
<blockquote>
<p>编写中断服务函数之前，加入管理所有中断的<code>gd32f30x_it.c</code>文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f30x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led_drv.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">GPIOInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	rcu_periph_clock_enable(RCU_GPIOA);</span><br><span class="line">	gpio_init(GPIOA, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_2MHZ, GPIO_PIN_0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">EXTIInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 使能EXTI时钟 */</span></span><br><span class="line">	rcu_periph_clock_enable(RCU_AF);</span><br><span class="line">	<span class="comment">/* I/O连接到EXTI线 */</span></span><br><span class="line">	gpio_exti_source_select(GPIO_PORT_SOURCE_GPIOA, GPIO_PIN_SOURCE_0);</span><br><span class="line">	<span class="comment">/* 配置下降沿 */</span></span><br><span class="line">	exti_init(EXTI_0, EXTI_INTERRUPT, EXTI_TRIG_FALLING);</span><br><span class="line">	<span class="comment">/* 清除标志 */</span></span><br><span class="line">	exti_interrupt_flag_clear(EXTI_0);</span><br><span class="line">	<span class="comment">/* 使能中断 */</span></span><br><span class="line">	nvic_irq_enable(EXTI0_IRQn, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief 按键硬件初始化</span></span><br><span class="line"><span class="comment">* @param</span></span><br><span class="line"><span class="comment">* @return </span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">KeyInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIOInit();</span><br><span class="line">	EXTIInit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief EXTI0中断服务函数，对应PA0</span></span><br><span class="line"><span class="comment">* @param</span></span><br><span class="line"><span class="comment">* @return </span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI0_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (exti_interrupt_flag_get(EXTI_0) != RESET)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 清除外部中断线 */</span></span><br><span class="line">		exti_interrupt_flag_clear(EXTI_0);</span><br><span class="line">		ToggleLed(LED1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="3-问题三：中断抢占优先级"><a href="#3-问题三：中断抢占优先级" class="headerlink" title="3.问题三：中断抢占优先级"></a>3.问题三：中断抢占优先级</h3><p>在EXTI0的中断服务函数中加上一个无限循环：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f30x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led_drv.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">GPIOInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	rcu_periph_clock_enable(RCU_GPIOA);</span><br><span class="line">	gpio_init(GPIOA, GPIO_MODE_IPU, GPIO_OSPEED_2MHZ, GPIO_PIN_0);</span><br><span class="line">	</span><br><span class="line">	rcu_periph_clock_enable(RCU_GPIOG);</span><br><span class="line">	gpio_init(GPIOG, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_2MHZ, GPIO_PIN_13);</span><br><span class="line">	gpio_init(GPIOG, GPIO_MODE_IN_FLOATING, GPIO_OSPEED_2MHZ, GPIO_PIN_14);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">EXTIInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 使能EXTI时钟 */</span></span><br><span class="line">	rcu_periph_clock_enable(RCU_AF);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* I/O连接到EXTI线 */</span></span><br><span class="line">	gpio_exti_source_select(GPIO_PORT_SOURCE_GPIOA, GPIO_PIN_SOURCE_0);</span><br><span class="line">	<span class="comment">/* 配置下降沿 */</span></span><br><span class="line">	exti_init(EXTI_0, EXTI_INTERRUPT, EXTI_TRIG_FALLING);</span><br><span class="line">	<span class="comment">/* 清除标志 */</span></span><br><span class="line">	exti_interrupt_flag_clear(EXTI_0);</span><br><span class="line">	<span class="comment">/* 使能中断 */</span></span><br><span class="line">	nvic_irq_enable(EXTI0_IRQn, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* I/O连接到EXTI线 */</span></span><br><span class="line">	gpio_exti_source_select(GPIO_PORT_SOURCE_GPIOG, GPIO_PIN_SOURCE_13);</span><br><span class="line">	<span class="comment">/* 下降沿 */</span></span><br><span class="line">	exti_init(EXTI_13, EXTI_INTERRUPT, EXTI_TRIG_FALLING);</span><br><span class="line">	<span class="comment">/* 清除标志 */</span></span><br><span class="line">	exti_interrupt_flag_clear(EXTI_13);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* I/O连接到EXTI线 */</span></span><br><span class="line">	gpio_exti_source_select(GPIO_PORT_SOURCE_GPIOG, GPIO_PIN_SOURCE_14);</span><br><span class="line">	<span class="comment">/* 下降沿 */</span></span><br><span class="line">	exti_init(EXTI_14, EXTI_INTERRUPT, EXTI_TRIG_FALLING);</span><br><span class="line">	<span class="comment">/* 清除标志 */</span></span><br><span class="line">	exti_interrupt_flag_clear(EXTI_14);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 使能中断 */</span></span><br><span class="line">	nvic_irq_enable(EXTI10_15_IRQn, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief 按键硬件初始化</span></span><br><span class="line"><span class="comment">* @param</span></span><br><span class="line"><span class="comment">* @return </span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">KeyInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIOInit();</span><br><span class="line">	EXTIInit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief EXTI0中断服务函数，对应PA0</span></span><br><span class="line"><span class="comment">* @param</span></span><br><span class="line"><span class="comment">* @return </span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI0_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (exti_interrupt_flag_get(EXTI_0) != RESET)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 清除外部中断线 */</span></span><br><span class="line">		exti_interrupt_flag_clear(EXTI_0);</span><br><span class="line">		ToggleLed(LED1);</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief EXTI10_15中断服务函数，对应PG13 PG14</span></span><br><span class="line"><span class="comment">* @param</span></span><br><span class="line"><span class="comment">* @return </span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EXTI10_15_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (exti_interrupt_flag_get(EXTI_13) != RESET)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 清除外部中断线 */</span></span><br><span class="line">		exti_interrupt_flag_clear(EXTI_13);</span><br><span class="line">		ToggleLed(LED2);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (exti_interrupt_flag_get(EXTI_14) != RESET)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 清除外部中断线 */</span></span><br><span class="line">		exti_interrupt_flag_clear(EXTI_14);</span><br><span class="line">		ToggleLed(LED3);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后，按下k1、k2和k3按键，验证LED灯是否正常亮灭。按下k1时，LED1亮灭；按下k2时，LED2亮灭；按下k3时，LED3亮灭。</p>
<h4 id="1-验证抢占优先级"><a href="#1-验证抢占优先级" class="headerlink" title="1.验证抢占优先级"></a>1.验证抢占优先级</h4><blockquote>
<p>设置EXTI15的抢占优先级为0，即高优先级。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 使能中断 */</span></span><br><span class="line">nvic_irq_enable(EXTI0_IRQn, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">/* 使能中断 */</span></span><br><span class="line">nvic_irq_enable(EXTI10_15_IRQn, <span class="number">0</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>按下k1按键，进入EXTI0的中断服务函数，点亮LED并停留在<code>while(1)</code>位置。此时，再按下k1按键，LED无法熄灭，因为EXTI0的中断服务函数没有结束，无法响应新的中断。</p>
<p><strong>如果此时按下k2或k3，LED2或LED3亮，说明本来程序停留在EXTI0的服务函数循环中，当EXTI15的中断发生时，由于EXTI15的抢占优先级较高，它会打断EXTI0的执行，先执行EXTI15的中断服务函数。</strong></p>
</blockquote>
<h4 id="2-验证子优先级"><a href="#2-验证子优先级" class="headerlink" title="2.验证子优先级"></a>2.验证子优先级</h4><blockquote>
<p>设置抢占优先级都为相同数值，并将子优先级设置为更高。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 使能中断 */</span></span><br><span class="line">nvic_irq_enable(EXTI0_IRQn, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">/* 使能中断 */</span></span><br><span class="line">nvic_irq_enable(EXTI10_15_IRQn, <span class="number">1</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>按下k1按键，进入EXTI0的中断服务函数，点亮LED并停留在<code>while(1)</code>位置。此时再按下k1后，LED1不会熄灭，因为EXTI0的中断服务函数没有结束，无法响应新的中断。</p>
<p><strong>如果此时按下k2或k3，也没有反应，说明抢占优先级相同，无法打断当前的中断服务函数，即发生不会发送抢占中断。</strong></p>
</blockquote>
<h1 id="USART"><a href="#USART" class="headerlink" title="USART"></a>USART</h1><h2 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1.基础知识"></a>1.基础知识</h2><h3 id="1-通信方式"><a href="#1-通信方式" class="headerlink" title="1.通信方式"></a>1.通信方式</h3><blockquote>
<h6 id="并行通信："><a href="#并行通信：" class="headerlink" title="并行通信："></a>并行通信：</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202502221048584.png" alt="image-20250222104812511"></p>
<p>​    同一时刻可传输多个二进制位（如 8 / 16 / 32 位）。    </p>
<p>​    典型应用：51 单片机的 P0 并口；GD32F303 / STM32 的 EXMC / FSMC接口（驱动 SRAM、NAND Flash 等）。</p>
<p>​    特点：效率高但占用引脚资源多。</p>
<h6 id="串行通信："><a href="#串行通信：" class="headerlink" title="串行通信："></a>串行通信：</h6><p>​    同一时刻只能传输一个二进制位。</p>
<p>​    特点：逐位传输数据，抗干扰能力更强。</p>
</blockquote>
<h3 id="2-常见标准"><a href="#2-常见标准" class="headerlink" title="2.常见标准"></a>2.常见标准</h3><blockquote>
<h6 id="通信接口："><a href="#通信接口：" class="headerlink" title="通信接口："></a>通信接口：</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202502221103239.png" alt="image-20250222110349177"></p>
<p>​    <strong>UART、I²C、SPI、CAN、USB</strong> 等。</p>
</blockquote>
<h3 id="3-通信机制"><a href="#3-通信机制" class="headerlink" title="3.通信机制"></a><strong>3.通信机制</strong></h3><blockquote>
<h6 id="同步通信："><a href="#同步通信：" class="headerlink" title="同步通信："></a>同步通信：</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202502221106888.png" alt="image-20250222110635837"></p>
<p>​    依赖时钟信号（如I²C的SCL、SPI的SCLK），接收端按时钟采样数据。</p>
<h6 id="异步通信："><a href="#异步通信：" class="headerlink" title="异步通信："></a>异步通信：</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202502221116770.png" alt="image-20250222111651713"></p>
<p>​    无时钟信号（如 UART、CAN 、USB ），通过预设波特率与数据格式解析信号。</p>
<p>​    <strong>数据帧结构：</strong></p>
<ul>
<li><strong>空闲态</strong>：高电平</li>
<li><strong>起始位</strong>：高→低跳变</li>
<li><strong>数据位</strong>：8 位（普遍）</li>
<li><strong>停止位</strong>：恢复高电平</li>
</ul>
<p>​    收发双方需预设相同波特率（单位：bps ），确保时序同步。标准UART协议<strong>仅在位的中心点采样一次</strong>。</p>
<h6 id="双工模式"><a href="#双工模式" class="headerlink" title="双工模式:"></a>双工模式:</h6><p>​    <strong>全双工</strong>：设备能同时收发数据（如 UART 、SPI ）</p>
<p>​    <strong>半双工</strong>：设备同一时刻只能发送或接收（如I²C 、RS-485 、CAN 总线）</p>
<p>​    <strong>CAN总线</strong>虽然有两条数据线，但仍属于半双工（采用差分信号）；而<strong>SPI</strong>有两条独立数据线（MOSI/MISO），支持全双工。</p>
</blockquote>
<p><strong>三、常见串口电气标准</strong></p>
<blockquote>
<h6 id="TTL："><a href="#TTL：" class="headerlink" title="TTL："></a>TTL：</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202502221126252.png" alt="image-20250222112639189"></p>
<h6 id="RS-232："><a href="#RS-232：" class="headerlink" title="RS-232："></a>RS-232：</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202502221126331.png" alt="image-20250222112654276"></p>
<h6 id="RS-485"><a href="#RS-485" class="headerlink" title="RS-485:"></a>RS-485:</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202502221127812.png" alt="image-20250222112716763"></p>
<p>​    <strong>RS-485优势</strong>：差分信号抵消共模干扰（如雷击脉冲），适合工业环境。</p>
<p>​    <strong>USART扩展</strong>：ARM单片机串口支持同步模式（含 CLK 引脚），但异步模式更常用。</p>
</blockquote>
<h2 id="2-结构"><a href="#2-结构" class="headerlink" title="2.结构"></a>2.结构</h2><h3 id="1-硬件结构-1"><a href="#1-硬件结构-1" class="headerlink" title="1.硬件结构"></a>1.硬件结构</h3><blockquote>
<h6 id="结构框图："><a href="#结构框图：" class="headerlink" title="结构框图："></a>结构框图：</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202502221135730.png" alt="image-20250222113506663"></p>
<h6 id="其中："><a href="#其中：" class="headerlink" title="其中："></a>其中：</h6><p>​    <strong>数据寄存器（DR）：</strong>32位寄存器<strong>（仅低9位有效）</strong>。<strong>读操作访问接收缓冲区，写操作加载发送缓冲区</strong>。</p>
<p>​    <strong>移位寄存器：</strong>发送时自动将并行数据转为串行位流（TX引脚），接收时重组串行数据为并行格式（RX引脚）。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>标志位</th>
<th>功能描述</th>
<th>应用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>TBE</td>
<td>发送缓冲区空</td>
<td>允许加载新数据（数据寄存器）</td>
</tr>
<tr>
<td>TC</td>
<td>发送完成</td>
<td>检测帧结束（移位寄存器）</td>
</tr>
<tr>
<td>RBNE</td>
<td>接收缓冲区非空</td>
<td>读取接收数据（数据寄存器）</td>
</tr>
<tr>
<td>IDLE</td>
<td>总线空闲</td>
<td>检测通信超时</td>
</tr>
</tbody>
</table>
</div>
<p>单片机向数据寄存器写入（发送）数据，数据会从数据寄存器搬移到发送移位寄存器。若<strong>数据寄存器空</strong>，<code>TBE</code> 就会置位为 <code>1</code> 。</p>
<p>移位寄存器没有数据时，<code>TC</code> 就会置位为 <code>1</code>；移位寄存器有数据时，<code>TC</code> 就会置位为 <code>0</code>。</p>
</blockquote>
<h3 id="2-数据帧结构"><a href="#2-数据帧结构" class="headerlink" title="2.数据帧结构"></a>2.数据帧结构</h3><blockquote>
<h6 id="结构框图：-1"><a href="#结构框图：-1" class="headerlink" title="结构框图："></a>结构框图：</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202502221145756.png" alt="image-20250222114504692"></p>
<p>​    <strong>典型配置：1 起始位 + 8 数据位 + 1 停止位（无校验）</strong>。</p>
<h6 id="奇偶校验："><a href="#奇偶校验：" class="headerlink" title="奇偶校验："></a>奇偶校验：</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202502221156268.png" alt="image-20250222115651205"></p>
<h6 id="异或校验："><a href="#异或校验：" class="headerlink" title="异或校验："></a>异或校验：</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202502221157371.png" alt="image-20250222115751300"></p>
<h6 id="冗余校验："><a href="#冗余校验：" class="headerlink" title="冗余校验："></a>冗余校验：</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202502221158781.png" alt="image-20250222115826729"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202502221145315.png" alt="image-20250222114522249"></p>
</blockquote>
<h3 id="3-板载设备"><a href="#3-板载设备" class="headerlink" title="3.板载设备"></a>3.板载设备</h3><blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202502221154909.png" alt="image-20250222115423847"></p>
</blockquote>
<h2 id="3-代码实现-1"><a href="#3-代码实现-1" class="headerlink" title="3.代码实现"></a>3.代码实现</h2><h3 id="1-串口普通输出"><a href="#1-串口普通输出" class="headerlink" title="1.串口普通输出"></a>1.串口普通输出</h3><h4 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1.初始化"></a>1.初始化</h4><h5 id="1-串口软件信息结构体："><a href="#1-串口软件信息结构体：" class="headerlink" title="1.串口软件信息结构体："></a>1.串口软件信息结构体：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">uint32_t</span> uartNo;			<span class="comment">// 串口号</span></span><br><span class="line">	rcu_periph_enum rcuUart;	<span class="comment">// 串口外设时钟</span></span><br><span class="line">	rcu_periph_enum rcuGpio;	<span class="comment">// 串口GPIO时钟</span></span><br><span class="line">	<span class="type">uint32_t</span> gpio;				<span class="comment">// GPIO组号</span></span><br><span class="line">	<span class="type">uint32_t</span> txPin;				<span class="comment">// Tx对应Pin</span></span><br><span class="line">	<span class="type">uint32_t</span> rxPin;				<span class="comment">// Rx对应Pin</span></span><br><span class="line">&#125; UartHwInfo_t;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> UartHwInfo_t g_uartHwInfo = &#123;USART0, RCU_USART0, RCU_GPIOA, GPIOA, GPIO_PIN_9, GPIO_PIN_10&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="2-串口-GPIO-配置："><a href="#2-串口-GPIO-配置：" class="headerlink" title="2.串口 GPIO 配置："></a>2.串口 GPIO 配置：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Usb2ComGpioInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 使能 GPIO 时钟 */</span></span><br><span class="line">	rcu_periph_clock_enable(g_uartHwInfo.rcuGpio);</span><br><span class="line">	<span class="comment">/* 配置 TX 对应管脚为推挽输出模式 */</span></span><br><span class="line">	gpio_init(g_uartHwInfo.gpio, GPIO_MODE_AF_PP, GPIO_OSPEED_10MHZ, g_uartHwInfo.txPin);</span><br><span class="line">	<span class="comment">/* 配置 RX 对应管脚为浮空输入/上拉输入模式（串口信号线空闲时为高电平） */</span></span><br><span class="line">	gpio_init(g_uartHwInfo.gpio, GPIO_MODE_IPU, GPIO_OSPEED_10MHZ, g_uartHwInfo.rxPin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-串口外设配置："><a href="#3-串口外设配置：" class="headerlink" title="3.串口外设配置："></a>3.串口外设配置：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Usb2ComUartInit</span><span class="params">(<span class="type">uint32_t</span> baudRate)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 使能 UART 时钟 */</span></span><br><span class="line">	rcu_periph_clock_enable(g_uartHwInfo.rcuUart);</span><br><span class="line">	<span class="comment">/* 复位 UART 外设 */</span></span><br><span class="line">	usart_deinit (g_uartHwInfo.uartNo);</span><br><span class="line">	<span class="comment">/* 通过 USART_CTL0 寄存器的 WL 设置字长( 8 位) */</span> </span><br><span class="line">	usart_word_length_set(g_uartHwInfo.uartNo, USART_WL_8BIT);</span><br><span class="line">	<span class="comment">/* 通过 USART_CTL0 寄存器的 PCEN 设置校验位（ 0 位） */</span> </span><br><span class="line">	usart_parity_config(g_uartHwInfo.uartNo, USART_PM_NONE);</span><br><span class="line">	<span class="comment">/* 在 USART_CTL1 寄存器中写 STB[1:0] 位来设置停止位的长度 */</span> </span><br><span class="line">	usart_stop_bit_set(g_uartHwInfo.uartNo, USART_STB_1BIT);</span><br><span class="line">	<span class="comment">/* 在 USART_BAUD 寄存器中设置波特率 */</span> </span><br><span class="line">	usart_baudrate_set(g_uartHwInfo.uartNo, baudRate);</span><br><span class="line">	<span class="comment">/* 在 USART_CTL0 寄存器中设置 TEN 位，使能发送功能 */</span></span><br><span class="line">	usart_transmit_config(g_uartHwInfo.uartNo, USART_TRANSMIT_ENABLE);</span><br><span class="line">	<span class="comment">/* 在 USART_CTL0 寄存器中置位 UEN 位，使能 UART 外设 */</span> </span><br><span class="line">	usart_enable(g_uartHwInfo.uartNo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-逻辑编写"><a href="#2-逻辑编写" class="headerlink" title="2.逻辑编写"></a>2.逻辑编写</h4><h5 id="1-输出数据："><a href="#1-输出数据：" class="headerlink" title="1.输出数据："></a>1.输出数据：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Usb2ComTest</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">uint8_t</span> i = <span class="number">0</span>; i &lt;= <span class="number">250</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		usart_data_transmit(g_uartHwInfo.uartNo, i);</span><br><span class="line">		<span class="keyword">while</span> (RESET == usart_flag_get(g_uartHwInfo.uartNo, USART_FLAG_TBE));</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 只有移位寄存器为空才说明数据发送完毕</span></span><br><span class="line">	<span class="keyword">while</span> (RESET == usart_flag_get(g_uartHwInfo.uartNo, USART_FLAG_TC));</span><br><span class="line">   	<span class="comment">// 关闭串口发送</span></span><br><span class="line">	usart_transmit_config(g_uartHwInfo.uartNo, USART_TRANSMIT_DISABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>如果代码里面不需要关闭串口发送，则没必要去判断 TC 标志位状态。</strong></p>
</blockquote>
<h5 id="2-Printf-发送："><a href="#2-Printf-发送：" class="headerlink" title="2. Printf 发送："></a>2. Printf 发送：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief printf函数默认打印输出到显示器，如果要输出到串口，</span></span><br><span class="line"><span class="comment">		 必须重新实现fputc函数，将输出指向串口，称为重定向</span></span><br><span class="line"><span class="comment">* @param</span></span><br><span class="line"><span class="comment">* @return </span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> ch, FILE *f)</span></span><br><span class="line">&#123;</span><br><span class="line">	usart_data_transmit(g_uartHwInfo.uartNo, (<span class="type">uint8_t</span>)ch);</span><br><span class="line">	<span class="keyword">while</span> (RESET == usart_flag_get(g_uartHwInfo.uartNo, USART_FLAG_TBE));</span><br><span class="line">	<span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Printf 默认将数据打印到 <strong>标准输出（stdout）</strong>，通常是终端或控制台窗口（如Windows 的 CMD、Linux 的 Shell ）。</p>
</blockquote>
<h3 id="2-串口中断接收"><a href="#2-串口中断接收" class="headerlink" title="2.串口中断接收"></a>2.串口中断接收</h3><blockquote>
<h6 id="串口交互数据："><a href="#串口交互数据：" class="headerlink" title="串口交互数据："></a>串口交互数据：</h6><ul>
<li>MCU 只发送不接收：printf 输出 。</li>
<li>MCU 只接收不发送：传感器周期性主动发送数据 。</li>
<li>MCU 发送命令并接收响应 ：AT 指令驱动WIFI模组 。</li>
<li>MCU 接收命令并发送响应：MODBUS RTU 。</li>
</ul>
<h6 id="串口接收数据处理复杂："><a href="#串口接收数据处理复杂：" class="headerlink" title="串口接收数据处理复杂："></a>串口接收数据处理复杂：</h6><ul>
<li>不知道什么时候接收到数据。</li>
<li>数据包的长度有时候是不定长的。</li>
<li>接收到的数据频率很快，有时候可能来不及处理，引入问题。</li>
</ul>
<p>处理串口接收数据时，都会采用串口中断来实现，再配合DMA、环形队列、定时器等方法来解决上面的问题。</p>
</blockquote>
<h4 id="1-初始化-1"><a href="#1-初始化-1" class="headerlink" title="1.初始化"></a>1.初始化</h4><h5 id="1-串口软件信息结构体：-1"><a href="#1-串口软件信息结构体：-1" class="headerlink" title="1.串口软件信息结构体："></a>1.串口软件信息结构体：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">uint32_t</span> uartNo;			<span class="comment">// 串口号</span></span><br><span class="line">	rcu_periph_enum rcuUart;	<span class="comment">// 串口外设时钟</span></span><br><span class="line">	rcu_periph_enum rcuGpio;	<span class="comment">// 串口GPIO时钟</span></span><br><span class="line">	<span class="type">uint32_t</span> gpio;				<span class="comment">// GPIO组号</span></span><br><span class="line">	<span class="type">uint32_t</span> txPin;				<span class="comment">// Tx对应Pin</span></span><br><span class="line">	<span class="type">uint32_t</span> rxPin;				<span class="comment">// Rx对应Pin</span></span><br><span class="line">    <span class="type">uint8_t</span> irq;				<span class="comment">// 串口中断号</span></span><br><span class="line">&#125; UartHwInfo_t;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> UartHwInfo_t g_uartHwInfo = &#123;USART0, RCU_USART0, RCU_GPIOA, GPIOA, GPIO_PIN_9, GPIO_PIN_10, USART0_IRQn&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="2-串口-GPIO-配置：-1"><a href="#2-串口-GPIO-配置：-1" class="headerlink" title="2.串口 GPIO 配置："></a>2.串口 GPIO 配置：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Usb2ComGpioInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 使能 GPIO 时钟; */</span></span><br><span class="line">	rcu_periph_clock_enable(g_uartHwInfo.rcuGpio);</span><br><span class="line">	<span class="comment">/* 配置 TX 对应管脚为推挽输出模式; */</span></span><br><span class="line">	gpio_init(g_uartHwInfo.gpio, GPIO_MODE_AF_PP, GPIO_OSPEED_10MHZ, g_uartHwInfo.txPin);</span><br><span class="line">	<span class="comment">/* 配置 RX 对应管脚为浮空输入/上拉输入模式（串口信号线空闲时为高电平）; */</span></span><br><span class="line">	gpio_init(g_uartHwInfo.gpio, GPIO_MODE_IPU, GPIO_OSPEED_10MHZ, g_uartHwInfo.rxPin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-串口外设配置：-1"><a href="#3-串口外设配置：-1" class="headerlink" title="3.串口外设配置："></a>3.串口外设配置：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Usb2ComUartInit</span><span class="params">(<span class="type">uint32_t</span> baudRate)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 使能 UART 时钟 */</span></span><br><span class="line">	rcu_periph_clock_enable(g_uartHwInfo.rcuUart);</span><br><span class="line">	<span class="comment">/* 复位 UART 外设 */</span></span><br><span class="line">	usart_deinit (g_uartHwInfo.uartNo);</span><br><span class="line">	<span class="comment">/* 通过 USART_CTL0 寄存器的 WL 设置字长( 8 位) */</span> </span><br><span class="line">	usart_word_length_set(g_uartHwInfo.uartNo, USART_WL_8BIT);</span><br><span class="line">	<span class="comment">/* 通过 USART_CTL0 寄存器的 PCEN 设置校验位（ 0 位） */</span> </span><br><span class="line">	usart_parity_config(g_uartHwInfo.uartNo, USART_PM_NONE);</span><br><span class="line">	<span class="comment">/* 在 USART_CTL1 寄存器中写 STB[1:0] 位来设置停止位的长度 */</span> </span><br><span class="line">	usart_stop_bit_set(g_uartHwInfo.uartNo, USART_STB_1BIT);</span><br><span class="line">	<span class="comment">/* 在 USART_BAUD 寄存器中设置波特率 */</span> </span><br><span class="line">	usart_baudrate_set(g_uartHwInfo.uartNo, baudRate);</span><br><span class="line">	<span class="comment">/* 在 USART_CTL0 寄存器中设置 TEN 位，使能发送功能 */</span></span><br><span class="line">	usart_transmit_config(g_uartHwInfo.uartNo, USART_TRANSMIT_ENABLE);</span><br><span class="line">    <span class="comment">/* 在 USART_CTL0 寄存器中设置 TEN 位，使能接收功能 */</span></span><br><span class="line">	usart_receive_config(g_uartHwInfo.uartNo, USART_RECEIVE_ENABLE);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* 使能串口接收空闲中断 */</span></span><br><span class="line">	usart_interrupt_enable(g_uartHwInfo.uartNo, USART_INT_IDLE);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* 使能串口中断 */</span></span><br><span class="line">	nvic_irq_enable(g_uartHwInfo.irq, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">/* 在 USART_CTL0 寄存器中置位 UEN 位，使能 UART 外设 */</span> </span><br><span class="line">	usart_enable(g_uartHwInfo.uartNo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-逻辑编写-1"><a href="#2-逻辑编写-1" class="headerlink" title="2.逻辑编写"></a>2.逻辑编写</h4><p>代码全放入 usb2com_drv.c 里！</p>
<h5 id="1-中断服务函数"><a href="#1-中断服务函数" class="headerlink" title="1.中断服务函数"></a>1.中断服务函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">USART0_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (usart_interrupt_flag_get(g_uartHwInfo.uartNo, USART_INT_FLAG_RBNE) != RESET)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">/* 软件清除中断标志位 */</span></span><br><span class="line">		usart_interrupt_flag_clear(g_uartHwInfo.uartNo, USART_INT_FLAG_RBNE);</span><br><span class="line">		<span class="type">uint8_t</span> uData = (<span class="type">uint8_t</span>)usart_data_receive(g_uartHwInfo.uartNo);</span><br><span class="line">		ProcUartData(uData);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-数据解析"><a href="#2-数据解析" class="headerlink" title="2.数据解析"></a>2.数据解析</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BUF_SIZE 20</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> g_rcvDataBuf[MAX_BUF_SIZE];</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> g_pktRcvd = <span class="literal">false</span>;<span class="comment">//pkt Packet（数据包）的缩写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************************</span></span><br><span class="line"><span class="comment">包格式： 帧头0   帧头1   数据长度    功能字   LED编号   亮/灭   异或校验数据</span></span><br><span class="line"><span class="comment">        0x55   0xAA    0x03      0x06     0x00     0x01      0xFB</span></span><br><span class="line"><span class="comment">***********************************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FRAME_HEAD_0        0x55  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FRAME_HEAD_1        0xAA</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CTRL_DATA_LEN       3     					<span class="comment">// 数据域长度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PACKET_DATA_LEN     (CTRL_DATA_LEN + 4)  	<span class="comment">// 包长度</span></span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LED_CTRL_CODE       0x06  					<span class="comment">// 功能字</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FUNC_DATA_IDX       3     					<span class="comment">// 功能字数组下标</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ProcUartData</span><span class="params">(<span class="type">uint8_t</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">	<span class="type">static</span> <span class="type">uint8_t</span> index = <span class="number">0</span>;</span><br><span class="line">	g_rcvDataBuf[index++] = data;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">switch</span> (index)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 1</span></span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			<span class="keyword">if</span> (g_rcvDataBuf[<span class="number">0</span>] != FRAME_HEAD_0)</span><br><span class="line">			&#123;</span><br><span class="line">				index = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			<span class="keyword">if</span> (g_rcvDataBuf[<span class="number">1</span>] != FRAME_HEAD_1)</span><br><span class="line">			&#123;</span><br><span class="line">				index = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">		<span class="keyword">case</span> PACKET_DATA_LEN: </span><br><span class="line">            <span class="comment">/* 成功接收数据 */</span></span><br><span class="line">			g_pktRcvd = <span class="literal">true</span>;</span><br><span class="line">			index = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-校验数据"><a href="#3-校验数据" class="headerlink" title="3.校验数据"></a>3.校验数据</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> <span class="title function_">CalXorSum</span><span class="params">(<span class="type">const</span> <span class="type">uint8_t</span> *data, <span class="type">uint32_t</span> len)</span><span class="comment">// Xor 异或 缩写</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> xorSum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		xorSum ^= data[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> xorSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4-控制逻辑"><a href="#4-控制逻辑" class="headerlink" title="4.控制逻辑"></a>4.控制逻辑</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">uint8_t</span> ledNo;</span><br><span class="line">	<span class="type">uint8_t</span> ledState;</span><br><span class="line">&#125; LedCtrlInfo_t;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">CtrlLed</span><span class="params">(LedCtrlInfo_t *ctrlData)</span></span><br><span class="line">&#123;</span><br><span class="line">	ctrlData-&gt;ledState != <span class="number">0</span> ? TurnOnLed(ctrlData-&gt;ledNo) : TurnOffLed(ctrlData-&gt;ledNo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Usb2ComTask</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">	<span class="keyword">if</span> (!g_pktRcvd)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">/* 数据接收失败 */</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	g_pktRcvd = <span class="literal">false</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">	<span class="keyword">if</span> (CalXorSum(g_rcvDataBuf, PACKET_DATA_LEN - <span class="number">1</span>) != g_rcvDataBuf[PACKET_DATA_LEN - <span class="number">1</span>])</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">/* 校验失败 */</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> (g_rcvDataBuf[FUNC_DATA_IDX] == LED_CTRL_CODE)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 4</span></span><br><span class="line">        <span class="comment">/* 传入LED编号地址，同时也是LED控制结构体的首地址 */</span></span><br><span class="line">		CtrlLed((LedCtrlInfo_t *)(&amp;g_rcvDataBuf[FUNC_DATA_IDX + <span class="number">1</span>]));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-逻辑优化"><a href="#3-逻辑优化" class="headerlink" title="3.逻辑优化"></a>3.逻辑优化</h4><blockquote>
<p>凡是与业务相关的逻辑代码，放到 App.c 中。</p>
<p>上层调用下层，不可反之。</p>
</blockquote>
<h5 id="1-usb2com-drv-c"><a href="#1-usb2com-drv-c" class="headerlink" title="1.usb2com_drv.c"></a>1.usb2com_drv.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="title function_">void</span> <span class="params">(*pProcUartDataFunc)</span><span class="params">(<span class="type">uint8_t</span> data)</span>;   <span class="comment">//函数指针变量，保存应用层回调函数地址</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">regUsb2ComCb</span><span class="params">(<span class="type">void</span> (*pFunc)(<span class="type">uint8_t</span> data))</span></span><br><span class="line">&#123;</span><br><span class="line">	pProcUartDataFunc = pFunc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数指针变量，接收传入的回调函数地址 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">regUsb2ComCb</span><span class="params">(<span class="type">void</span> (*pFunc)(<span class="type">uint8_t</span> data))</span></span><br><span class="line">&#123;</span><br><span class="line">	pProcUartDataFunc = pFunc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-usb2com-app-c"><a href="#2-usb2com-app-c" class="headerlink" title="2.usb2com_app.c"></a>2.usb2com_app.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* USB转串口应用初始化函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Usb2ComAppInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	regUsb2ComCb(ProcUartData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-main-c"><a href="#3-main-c" class="headerlink" title="3.main.c"></a>3.main.c</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">AppInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	Usb2ComAppInit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;	</span><br><span class="line">	AppInit();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Usb2ComTask();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-环形队列收发"><a href="#3-环形队列收发" class="headerlink" title="3.环形队列收发"></a>3.环形队列收发</h3><h3 id="4-IDLE-DMA"><a href="#4-IDLE-DMA" class="headerlink" title="4. IDLE + DMA"></a>4. IDLE + DMA</h3><p><strong>数据包长度越大，每次进入串口中断的次数越多，CPU 被打断越频繁，因此，配合 DMA 一次性接收数据包，再解析，方为正解。</strong></p>
<blockquote>
<h6 id="产生空闲中断："><a href="#产生空闲中断：" class="headerlink" title="产生空闲中断："></a>产生空闲中断：</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202502221507487.png" alt="image-20250222150706403"></p>
<p>​    同一个数据包内的数据之间空闲几乎不计，上一个字节的停止位后紧跟着下一个字节的起始位。</p>
<p>​    数据包与数据包之间的空闲时间不可忽略！</p>
<h6 id="DMA-能一次性将一包数据放入内存中："><a href="#DMA-能一次性将一包数据放入内存中：" class="headerlink" title="DMA 能一次性将一包数据放入内存中："></a>DMA 能一次性将一包数据放入内存中：</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202502221514110.png" alt="image-20250222151432048"></p>
<p>​    DMA 框图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202502221515914.png" alt="image-20250222151534853"></p>
</blockquote>
<h4 id="1-初始化-2"><a href="#1-初始化-2" class="headerlink" title="1.初始化"></a>1.初始化</h4><h5 id="1-串口软件信息结构体：-2"><a href="#1-串口软件信息结构体：-2" class="headerlink" title="1.串口软件信息结构体："></a>1.串口软件信息结构体：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">uint32_t</span> uartNo;			<span class="comment">// 串口编号</span></span><br><span class="line">	rcu_periph_enum rcuUart;	<span class="comment">// 串口外设时钟</span></span><br><span class="line">	rcu_periph_enum rcuGpio;	<span class="comment">// 串口GPIO时钟</span></span><br><span class="line">	<span class="type">uint32_t</span> gpio;				<span class="comment">// GPIO组号</span></span><br><span class="line">	<span class="type">uint32_t</span> txPin;				<span class="comment">// Tx对应Pin</span></span><br><span class="line">	<span class="type">uint32_t</span> rxPin;				<span class="comment">// Rx对应Pin</span></span><br><span class="line">    <span class="type">uint8_t</span> irq;				<span class="comment">// 串口中断号</span></span><br><span class="line">    <span class="type">uint32_t</span> dmaNo;				<span class="comment">// DMA编号</span></span><br><span class="line">	rcu_periph_enum rcuDma;		<span class="comment">// DMA时钟</span></span><br><span class="line">	dma_channel_enum dmaCh;     <span class="comment">// DMA通道号</span></span><br><span class="line">&#125; UartHwInfo_t;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> UartHwInfo_t g_uartHwInfo = &#123;USART0, RCU_USART0, RCU_GPIOA, GPIOA, GPIO_PIN_9, GPIO_PIN_10, USART0_IRQn DMA0, RCU_DMA0, DMA_CH4&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="2-串口外设配置："><a href="#2-串口外设配置：" class="headerlink" title="2.串口外设配置："></a>2.串口外设配置：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Usb2ComUartInit</span><span class="params">(<span class="type">uint32_t</span> baudRate)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 使能UART时钟；*/</span></span><br><span class="line">	rcu_periph_clock_enable(g_uartHwInfo.rcuUart);</span><br><span class="line">	<span class="comment">/* 复位UART；*/</span></span><br><span class="line">	usart_deinit (g_uartHwInfo.uartNo);</span><br><span class="line">	<span class="comment">/* 通过USART_CTL0寄存器的WL设置字长；*/</span> </span><br><span class="line">	<span class="comment">//usart_word_length_set(g_uartHwInfo.uartNo, USART_WL_8BIT);</span></span><br><span class="line">	<span class="comment">/* 通过USART_CTL0寄存器的PCEN设置校验位；*/</span> </span><br><span class="line">	<span class="comment">//usart_parity_config(g_uartHwInfo.uartNo, USART_PM_NONE);</span></span><br><span class="line">	<span class="comment">/* 在USART_CTL1寄存器中写STB[1:0]位来设置停止位的长度；*/</span> </span><br><span class="line">	<span class="comment">//usart_stop_bit_set(g_uartHwInfo.uartNo, USART_STB_1BIT);</span></span><br><span class="line">	<span class="comment">/* 在USART_BAUD寄存器中设置波特率；*/</span> </span><br><span class="line">	usart_baudrate_set(g_uartHwInfo.uartNo, baudRate);</span><br><span class="line">	<span class="comment">/* 在USART_CTL0寄存器中设置TEN位，使能发送功能；*/</span></span><br><span class="line">	usart_transmit_config(g_uartHwInfo.uartNo, USART_TRANSMIT_ENABLE);</span><br><span class="line">	<span class="comment">/* 在USART_CTL0寄存器中设置TEN位，使能接收功能；*/</span></span><br><span class="line">	usart_receive_config(g_uartHwInfo.uartNo, USART_RECEIVE_ENABLE);</span><br><span class="line">	<span class="comment">/* 使能串口接收空闲中断；*/</span></span><br><span class="line">	usart_interrupt_enable(g_uartHwInfo.uartNo, USART_INT_IDLE);</span><br><span class="line">	<span class="comment">/* 使能串口中断；*/</span></span><br><span class="line">	nvic_irq_enable(g_uartHwInfo.irq, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">/* 在USART_CTL0寄存器中置位UEN位，使能UART；*/</span> </span><br><span class="line">	usart_enable(g_uartHwInfo.uartNo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-串口-DMA-配置："><a href="#3-串口-DMA-配置：" class="headerlink" title="3.串口 DMA 配置："></a>3.串口 DMA 配置：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BUF_SIZE 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USART0_DATA_ADDR      (USART0 + 0x04)   <span class="comment">//串口 0 数据寄存器十六进制地址值</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Usb2ComDmaInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 使能 DMA 时钟 */</span></span><br><span class="line">	rcu_periph_clock_enable(g_uartHwInfo.rcuDma);</span><br><span class="line">	<span class="comment">/* 复位 DMA 通道 */</span></span><br><span class="line">	dma_deinit(g_uartHwInfo.dmaNo, g_uartHwInfo.dmaCh);</span><br><span class="line">	dma_parameter_struct dmaStruct;</span><br><span class="line">	<span class="comment">/* 配置传输方向 */</span> </span><br><span class="line">	dmaStruct.direction = DMA_PERIPHERAL_TO_MEMORY;</span><br><span class="line">	<span class="comment">/* 配置数据源地址 */</span> </span><br><span class="line">	dmaStruct.periph_addr = USART0_DATA_ADDR; <span class="comment">// 基地址 + 偏移量 </span></span><br><span class="line">	<span class="comment">/* 配置源地址 固定 Or 增长 */</span> </span><br><span class="line">	dmaStruct.periph_inc = DMA_PERIPH_INCREASE_DISABLE;</span><br><span class="line">	<span class="comment">/* 配置源数据传输位宽 */</span> </span><br><span class="line">	dmaStruct.periph_width = DMA_PERIPHERAL_WIDTH_8BIT;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* 配置数据目的地址 */</span></span><br><span class="line">	dmaStruct.memory_addr = (<span class="type">uint32_t</span>)g_rcvDataBuf;<span class="comment">// 定义的存储数组地址</span></span><br><span class="line">	<span class="comment">/* 配置目的地址 固定 Or 增长 */</span> </span><br><span class="line">	dmaStruct.memory_inc = DMA_MEMORY_INCREASE_ENABLE;</span><br><span class="line">	<span class="comment">/* 配置目的数据传输位宽 */</span> </span><br><span class="line">	dmaStruct.memory_width = DMA_MEMORY_WIDTH_8BIT;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* 配置数据传输最大次数 */</span> </span><br><span class="line">	dmaStruct.number = MAX_BUF_SIZE; <span class="comment">// MAX：65536 次</span></span><br><span class="line">	<span class="comment">/* 配置DMA通道优先级 */</span> </span><br><span class="line">	dmaStruct.priority = DMA_PRIORITY_HIGH;</span><br><span class="line">	dma_init(g_uartHwInfo.dmaNo, g_uartHwInfo.dmaCh, &amp;dmaStruct);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 使能UART接收数据使用DMA */</span> </span><br><span class="line">	usart_dma_receive_config(g_uartHwInfo.uartNo, USART_RECEIVE_DMA_ENABLE);</span><br><span class="line">	<span class="comment">/* 使能DMA通道 */</span> </span><br><span class="line">	dma_channel_enable(g_uartHwInfo.dmaNo, g_uartHwInfo.dmaCh);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-逻辑编写-2"><a href="#2-逻辑编写-2" class="headerlink" title="2.逻辑编写"></a>2.逻辑编写</h4><h5 id="1-中断服务函数-1"><a href="#1-中断服务函数-1" class="headerlink" title="1.中断服务函数"></a>1.中断服务函数</h5><blockquote>
<h6 id="清除空闲中断标志位："><a href="#清除空闲中断标志位：" class="headerlink" title="清除空闲中断标志位："></a>清除空闲中断标志位：</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202502221534849.png" alt="image-20250222153434770"></p>
<h6 id="计算-DMA-搬运数据量（dma-transfer-number-get）："><a href="#计算-DMA-搬运数据量（dma-transfer-number-get）：" class="headerlink" title="计算 DMA 搬运数据量（dma_transfer_number_get）："></a>计算 DMA 搬运数据量（dma_transfer_number_get）：</h6><p>​    功能描述：获取 <strong>DMAx</strong> <strong>通道 y</strong> 还有多少数据要传输，即获取<strong>剩余</strong>数据长度。</p>
<p>​    内部实现：读取 <strong>CNT</strong> 寄存器里的数值。</p>
<h6 id="通道-x-计数寄存器-DMA-CHxCNT-："><a href="#通道-x-计数寄存器-DMA-CHxCNT-：" class="headerlink" title="通道 x 计数寄存器 (DMA_CHxCNT)："></a>通道 x 计数寄存器 (DMA_CHxCNT)：</h6><p>​    该寄存器表明还有多少数据等待被传输。一旦通道使能，<strong>该寄存器为只读的，并在每个DMA传输之后值减 1</strong> 。如果该寄存器的值    为 0，无论通道开启与否，都不会有数据传输。如果该通道工作在循环模式下，一旦通道的传输任务完成，该寄存器会被自动</p>
<p>​    重装载为初始设置值。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BUF_SIZE 20</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART0_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (usart_interrupt_flag_get(g_uartHwInfo.uartNo, USART_INT_FLAG_IDLE) != RESET)</span><br><span class="line">	&#123;</span><br><span class="line">		usart_interrupt_flag_clear(g_uartHwInfo.uartNo, USART_INT_FLAG_IDLE);  <span class="comment">//第一步，读取stat0寄存器，清除IDLE标志位</span></span><br><span class="line">		usart_data_receive(g_uartHwInfo.uartNo);                               <span class="comment">//第二步，读取数据寄存器，清除IDLE标志位</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (PACKET_DATA_LEN == (MAX_BUF_SIZE - dma_transfer_number_get(g_uartHwInfo.dmaNo, g_uartHwInfo.dmaCh)))</span><br><span class="line">		&#123;</span><br><span class="line">            <span class="comment">/* 成功获取一包数据 */</span></span><br><span class="line">			g_pktRcvd = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">/* 必须关闭DMA，否则设置 CNT 无法生效 */</span></span><br><span class="line">		dma_channel_disable(g_uartHwInfo.dmaNo, g_uartHwInfo.dmaCh);</span><br><span class="line">        <span class="comment">/* 重新设置 DMA通道 x 计数寄存器 */</span></span><br><span class="line">		dma_transfer_number_config(g_uartHwInfo.dmaNo, g_uartHwInfo.dmaCh, MAX_BUF_SIZE);</span><br><span class="line">        <span class="comment">/* 使能 DMA 相应通道 */</span></span><br><span class="line">		dma_channel_enable(g_uartHwInfo.dmaNo, g_uartHwInfo.dmaCh);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-数据解析-1"><a href="#2-数据解析-1" class="headerlink" title="2.数据解析"></a>2.数据解析</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Usb2ComTask</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (!g_pktRcvd)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	g_pktRcvd = <span class="literal">false</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (g_rcvDataBuf[<span class="number">0</span>] != FRAME_HEAD_0 || g_rcvDataBuf[<span class="number">1</span>] != FRAME_HEAD_1)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">if</span> (CalXorSum(g_rcvDataBuf, PACKET_DATA_LEN - <span class="number">1</span>) != g_rcvDataBuf[PACKET_DATA_LEN - <span class="number">1</span>])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 逻辑功能 */</span></span><br><span class="line">	<span class="keyword">if</span> (g_rcvDataBuf[FUNC_DATA_IDX] == LED_CTRL_CODE)</span><br><span class="line">	&#123;</span><br><span class="line">		CtrlLed((LedCtrlInfo_t *)(&amp;g_rcvDataBuf[FUNC_DATA_IDX + <span class="number">1</span>]));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="RTC"><a href="#RTC" class="headerlink" title="RTC"></a>RTC</h1><h2 id="1-RTC-amp-BKP"><a href="#1-RTC-amp-BKP" class="headerlink" title="1. RTC &amp; BKP"></a>1. RTC &amp; BKP</h2><h3 id="1-RTC"><a href="#1-RTC" class="headerlink" title="1.RTC"></a>1.RTC</h3><blockquote>
<h6 id="RTC-简易硬件结构框图如下："><a href="#RTC-简易硬件结构框图如下：" class="headerlink" title="RTC 简易硬件结构框图如下："></a>RTC 简易硬件结构框图如下：</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190016858.png" alt="image-20241130123025264"></p>
<p>​    GD32F303 单片机的 RTC 硬件结构与 STM32F103 相同，RTC 有三个时钟源：</p>
<ul>
<li>外部高速时钟：4~32 MHz（如开发板上的 8 MHz，可进行 128 分频），主电源掉电后将停止工作。</li>
<li>外部低速时钟：32.768 kHz，通常选用此时钟，因为在主电源掉电后，它可由纽扣电池供电，RTC 仍能持续计时。</li>
<li>内部时钟：单片机内部的 40 kHz 时钟，主电源掉电后将停止工作。</li>
</ul>
<h6 id="原理框图如下："><a href="#原理框图如下：" class="headerlink" title="原理框图如下："></a>原理框图如下：</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190018504.png" alt="QQ20241130-123121"></p>
<p>​    供电部分使用 BAT54C，它里面有两个二极管，阴极相连。当主电源有电且电压高于纽扣电池电压时，主电源侧的二极管导通，</p>
<p>​    主电源供电。当主电源掉电后，主电源电压下降，纽扣电池侧的二极管导通，由纽扣电池供电。这样实现了供电的自动切换。</p>
<h6 id="原理框图如下：-1"><a href="#原理框图如下：-1" class="headerlink" title="原理框图如下："></a>原理框图如下：</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190018726.png" alt="QQ20241130-123457"></p>
<p>​    晶振部分使用 32.768 kHz 晶振和两个起振电容。</p>
<h6 id="RTC硬件结构框图如下："><a href="#RTC硬件结构框图如下：" class="headerlink" title="RTC硬件结构框图如下："></a>RTC硬件结构框图如下：</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190019024.png" alt="image-20241130123542930"></p>
<p>​    RTC输入通过预分频器（PRL 和 DIV 寄存器）实现分频。将预分频值 32767 写入 PRL，对 32.768 kHz 的时钟进行分频，DIV 寄存</p>
<p>​    器作为向下递减计数器，生成 1 Hz 的时钟信号，用于计数器 CNT，每记一个数值，也就是一秒钟。</p>
<p>​    RTC 还有闹钟寄存器 RTC_Alarm，可产生秒中断、计数溢出中断、闹钟中断等。APB1 时钟（PCLK）用于提供 APB1 读写接口。    </p>
<p>​    当主电源掉电时，PCLK 1停止工作，但 RTCCLK 可继续工作。因为外部有这个纽扣电池。当然，如果没有纽扣电池，它也就没办</p>
<p>​    法工作了。</p>
</blockquote>
<h3 id="2-BKP"><a href="#2-BKP" class="headerlink" title="2.BKP"></a>2.BKP</h3><blockquote>
<h6 id="RTC简易硬件结构框图如下："><a href="#RTC简易硬件结构框图如下：" class="headerlink" title="RTC简易硬件结构框图如下："></a>RTC简易硬件结构框图如下：</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202502221751308.png" alt="image-20250222175109230"></p>
<p>​    RTC 寄存器位于备份区域（后备区），涉及片上外设 BKP（备份寄存器）。VDD 主电源掉电后，可由 Vbat（如纽扣电池）供电。    BKP 内除了 RTC 的寄存器外，还有 42 个 16 位的寄存器（DR1~DR42），可用于存储用户数据。需要注意：如果没有纽扣电池供    电，掉电后数据将丢失。这些寄存器和内存一样，在完全掉电时数据会丢失，并不像 Flash 那样是非易失性的存储器。如果没有</p>
<p>​    主电源供电，必须要有纽扣电池供电才可以保持数据。当设备从待机模式唤醒或者是复位后，只要有纽扣电池供电，BKP 寄存器    中的数据就不会丢失。</p>
</blockquote>
<h4 id="1-信号校准"><a href="#1-信号校准" class="headerlink" title="1.信号校准"></a>1.信号校准</h4><blockquote>
<h6 id="信号校准寄存器："><a href="#信号校准寄存器：" class="headerlink" title="信号校准寄存器："></a>信号校准寄存器：</h6><p>可配置，将RTC的时钟通过一个管脚，此管脚是PC13是复用的，通过这个管脚将信号输出。然后去监测，如果发现这个时钟偏差比较大，我们可以去配置这个校准寄存器用来校准，就是这个功能。</p>
</blockquote>
<h4 id="2-侵入检测"><a href="#2-侵入检测" class="headerlink" title="2.侵入检测"></a>2.侵入检测</h4><blockquote>
<h6 id="侵入检测寄存器："><a href="#侵入检测寄存器：" class="headerlink" title="侵入检测寄存器："></a>侵入检测寄存器：</h6><p>比如说我们的产品啊，这个安全性要求比较高，不想让别人去分析，我们就可以使用侵入检测。它使用的这个PC13引脚的复用功能。要想实现侵入检测，我们可以对这个管脚，比如说加上一个上拉电阻。然后可以再通过一个导线连接一个开关，这个开关再连接到外壳上，外壳是接地的。当有人拆卸外壳时，会触发开关状态改变，PC13 引脚的电平从高电平变为低电平，检测到这种电平变化后，产生侵入检测事件。这个事件又会进一步地触发去清除BKP寄存器里面的数据。我们可以在这个寄存器里面保存一些核心的关键的参数。这样的话，别人就没有办法去完整地分析整个系统了。另外，即使设备的主电源断电了，因为有纽扣电池，通过Vbat还可以给它供电。这样的话，侵入检测的功能还是可以继续工作的。</p>
</blockquote>
<h3 id="3-Init-Config"><a href="#3-Init-Config" class="headerlink" title="3. Init Config"></a>3. Init Config</h3><blockquote>
<p>​    RTC配置框图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190021394.png" alt="image-20241130125614864"></p>
<p><strong>使能对RTC的访问，使能PMU和BKP：</strong></p>
<p>即后备区域的时钟，还有电源管理的时钟。</p>
<p><strong>使能对后备寄存器和RTC的写权限：</strong></p>
<p>来看一下用户手册。这个功能是在PMU电源管理这个章节，PMU_CTL这个寄存器第八位，在这儿BKPWEN写使能。设置为1的时候，允许对这个寄存器啊进行写访问，也包括对RTC写访问。</p>
<p><strong>复位后备寄存器：</strong></p>
<p>通过这个操作可以对后备区域的这些寄存器的数据啊，全部给它复位清零。这是我们首次初始化配置的时候啊，可以去做的一个操作。</p>
<p><strong>使能外部低速时钟LXTAL，然后等待稳定：</strong></p>
<p><strong>设置RTC的时钟输入源为LXTAL：</strong></p>
<p>使能外部低速时钟并等待其稳定，设置 RTC 的时钟源为外部低速时钟（32.768 kHz）。</p>
<p><strong>使能 RTC 时钟并等待APB1和RTC时钟同步：</strong></p>
<p>涉及到了两个时钟：一个是PCLK，这就是APB1时钟，然后还有一个RTC的时钟。那么，这两个时钟在系统复位或者是待机唤醒以后，可能会存在着不同步的问题，因此我们在代码里面，要等待两个时钟同步。</p>
<p><strong>等待上次对RTC寄存器写操作完成：</strong></p>
<p>我们要去查询一个标志位，然后才能去写一些寄存器，包括分频寄存器，包括设置计数值。</p>
<p>来看一下用户手册。在RTC配置这里面，当写操作完成以后RTC_CTL寄存器当中的RWOF位会变为1。那么，下一次写操作之前，必须要等待上次写操作完成之后才能进行，就是通过查询这个标志来判断的，判断它为1后才能去进行写操作。每一次写操作都要去判断。</p>
<p>在这个描述里面还看到，说是要将RTC设置为配置模式，才能对寄存器进行写操作。对应的是RTC_CTL的CMF位。但是，通过实际写代码验证啊，发现即使没有对这个寄存器的CMF位进行配置，也是可以写操作的。这个是RWOF，判断上次RTC写操作是否已经完成。然后这个CMF用来退出配置，或者是进入配置。那么，在代码当中啊，我们发现，只需要实现这个环节就可以了，使能对后备寄存器RTC的写权限就可以了。不配置这个CMF也没问题。</p>
<p><strong>设置预分频值：</strong></p>
<p>例如32767。这样的话，分频以后生成的这个时钟信号就是1Hz，一秒钟。</p>
<p><strong>等待上次对RTC寄存器写操作完成：</strong></p>
<p><strong>设置计数值：</strong></p>
<p>在初始化的时候，我们也可以设置一个初始的计数值假设为0，那么对应的这个日历时间就是1970年1月1号零点零分零秒。</p>
</blockquote>
<h2 id="2-代码实现-1"><a href="#2-代码实现-1" class="headerlink" title="2.代码实现"></a>2.代码实现</h2><h3 id="1-初始化-3"><a href="#1-初始化-3" class="headerlink" title="1.初始化"></a>1.初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RtcDrvInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (bkp_read_data(BKP_DATA_0) != MAGIC_CODE)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 使能对RTC的访问，使能PMU和BKP时钟 */</span></span><br><span class="line">		rcu_periph_clock_enable(RCU_PMU);</span><br><span class="line">		rcu_periph_clock_enable(RCU_BKPI);</span><br><span class="line">        </span><br><span class="line">		<span class="comment">/* 使能对后备寄存器和RTC的写权限 */</span></span><br><span class="line">		pmu_backup_write_enable();</span><br><span class="line">        </span><br><span class="line">		<span class="comment">/* 复位后备寄存器 */</span></span><br><span class="line">		bkp_deinit();</span><br><span class="line">        </span><br><span class="line">		<span class="comment">/* 使能LXTAL，并等待其稳定 */</span></span><br><span class="line">		rcu_osci_on(RCU_LXTAL);</span><br><span class="line">		rcu_osci_stab_wait(RCU_LXTAL);</span><br><span class="line">        </span><br><span class="line">		<span class="comment">/* 设置RTC时钟源为LXTAL */</span></span><br><span class="line">		rcu_rtc_clock_config(RCU_RTCSRC_LXTAL);</span><br><span class="line">        </span><br><span class="line">		<span class="comment">/* 使能RTC时钟 */</span></span><br><span class="line">		rcu_periph_clock_enable(RCU_RTC);</span><br><span class="line">        </span><br><span class="line">		<span class="comment">/* 等待APB1接口时钟和RTC时钟同步 */</span></span><br><span class="line">		rtc_register_sync_wait();</span><br><span class="line">        </span><br><span class="line">		<span class="comment">/* 等待上次对 RTC 寄存器写操作完成 */</span></span><br><span class="line">		rtc_lwoff_wait();</span><br><span class="line">        </span><br><span class="line">		<span class="comment">/* 设置分频值32767 */</span></span><br><span class="line">		rtc_prescaler_set(<span class="number">32767</span>);</span><br><span class="line">        </span><br><span class="line">		<span class="comment">/* 等待上次对 RTC 寄存器写操作完成 */</span></span><br><span class="line">		rtc_lwoff_wait();</span><br><span class="line">        </span><br><span class="line">		<span class="comment">/* 设置时间2023-02-28 23:59:50 */</span></span><br><span class="line">		rtc_counter_set(<span class="number">1677599990</span>);</span><br><span class="line">		bkp_write_data(BKP_DATA_0, MAGIC_CODE);</span><br><span class="line">        </span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/* 使能对RTC的访问，使能PMU和BKP时钟 */</span></span><br><span class="line">	rcu_periph_clock_enable(RCU_PMU);</span><br><span class="line">	rcu_periph_clock_enable(RCU_BKPI);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* 使能对后备寄存器和RTC的写权限 */</span></span><br><span class="line">	pmu_backup_write_enable();</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* 等待APB1接口时钟和RTC时钟同步 */</span></span><br><span class="line">	rtc_register_sync_wait();</span><br><span class="line">    </span><br><span class="line">	<span class="comment">/* 等待上次对 RTC 寄存器写操作完成 */</span></span><br><span class="line">	rtc_lwoff_wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-设置时间"><a href="#2-设置时间" class="headerlink" title="2.设置时间"></a>2.设置时间</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SetRtcTime</span><span class="params">(RtcTime_t *time)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">time_t</span> timeStamp;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tm</span> <span class="title">tmInfo</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;tmInfo, <span class="number">0</span>, <span class="keyword">sizeof</span>(tmInfo));</span><br><span class="line">	</span><br><span class="line">	tmInfo.tm_year = time-&gt;year - <span class="number">1900</span>;</span><br><span class="line">	tmInfo.tm_mon = time-&gt;month - <span class="number">1</span>;</span><br><span class="line">	tmInfo.tm_mday = time-&gt;day;</span><br><span class="line">	tmInfo.tm_hour = time-&gt;hour;</span><br><span class="line">	tmInfo.tm_min = time-&gt;minute;</span><br><span class="line">	tmInfo.tm_sec = time-&gt;second;</span><br><span class="line">	</span><br><span class="line">	timeStamp = mktime(&amp;tmInfo) - <span class="number">8</span> * <span class="number">60</span> * <span class="number">60</span>;</span><br><span class="line">	</span><br><span class="line">	rtc_lwoff_wait();</span><br><span class="line">	rtc_counter_set(timeStamp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>SetRtcTime</code> 函数用于设置 RTC 的当前时间。</p>
<ul>
<li><p><strong>步骤解析：</strong></p>
<ul>
<li><p>创建一个 <code>tm</code> 结构体 (<code>struct tm tmInfo</code>) 用于存储时间信息。</p>
</li>
<li><p>将输入的结构体 <code>RtcTime_t</code> 中的年、月、日、小时、分钟、秒分别赋值给 <code>tmInfo</code>。</p>
</li>
<li><p>将年、月的值进行偏移，<code>tm_year</code> 是从 1900 年开始计数，而 <code>tm_mon</code> 是从 0 开始计数，所以分别做了对应的减法处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tmInfo.tm_year = time-&gt;year - <span class="number">1900</span>;</span><br><span class="line">tmInfo.tm_mon = time-&gt;month - <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用 <code>mktime()</code> 将时间转换为 Unix 时间戳（自 1970-01-01 00:00:00 以来的秒数），并减去 8 小时的偏移量，这是为了调整为 UTC 时间：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timeStamp = mktime(&amp;tmInfo) - <span class="number">8</span> * <span class="number">60</span> * <span class="number">60</span>;</span><br></pre></td></tr></table></figure>
<p>因为 <code>mktime()</code> 返回的是本地时间戳，假设本地时区为 UTC+8，所以这里需要减去 8 小时，将其转换为 UTC 时间。</p>
</li>
<li><p>等待 RTC 寄存器解锁，然后将时间戳设置到 RTC计数器：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rtc_lwoff_wait();</span><br><span class="line">rtc_counter_set(timeStamp);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="3-获取时间"><a href="#3-获取时间" class="headerlink" title="3.获取时间"></a>3.获取时间</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">GetRtcTime</span><span class="params">(RtcTime_t *time)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">time_t</span> timeStamp;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">tmInfo</span>;</span></span><br><span class="line">	</span><br><span class="line">	timeStamp = rtc_counter_get() + <span class="number">8</span> * <span class="number">60</span> * <span class="number">60</span>;</span><br><span class="line">	tmInfo = localtime(&amp;timeStamp);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">	time-&gt;year = tmInfo-&gt;tm_year + <span class="number">1900</span>;</span><br><span class="line">	time-&gt;month = tmInfo-&gt;tm_mon + <span class="number">1</span>;</span><br><span class="line">	time-&gt;day = tmInfo-&gt;tm_mday;</span><br><span class="line">	time-&gt;hour = tmInfo-&gt;tm_hour;</span><br><span class="line">	time-&gt;minute = tmInfo-&gt;tm_min;</span><br><span class="line">	time-&gt;second = tmInfo-&gt;tm_sec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>GetRtcTime</code> 函数用于从 RTC 中获取当前时间并将其转换为日历时间。</p>
<ul>
<li><p><strong>步骤解析：</strong></p>
<ul>
<li><p>从 RTC 中读取当前计数器的值，即获取 Unix 时间戳：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timeStamp = rtc_counter_get() + <span class="number">8</span> * <span class="number">60</span> * <span class="number">60</span>;</span><br></pre></td></tr></table></figure>
<p>读取到的时间是 UTC 时间，所以这里加上 8 小时的偏移量，将其转换为本地时间<strong>（UTC+8）</strong>。</p>
</li>
<li><p>调用 <code>localtime()</code> 将时间戳转换为 <code>struct tm</code> 结构体。</p>
</li>
<li><p>将 <code>struct tm</code> 结构体中的值赋回到 <code>RtcTime_t</code> 结构体中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">time-&gt;year = tmInfo-&gt;tm_year + <span class="number">1900</span>;</span><br><span class="line">time-&gt;month = tmInfo-&gt;tm_mon + <span class="number">1</span>;</span><br><span class="line">time-&gt;day = tmInfo-&gt;tm_mday;</span><br><span class="line">time-&gt;hour = tmInfo-&gt;tm_hour;</span><br><span class="line">time-&gt;minute = tmInfo-&gt;tm_min;</span><br><span class="line">time-&gt;second = tmInfo-&gt;tm_sec;</span><br></pre></td></tr></table></figure>
<p>对年和月的值做了相应的调整，<code>tm_year</code> 需要加上 1900，<code>tm_mon</code> 需要加上 1。</p>
</li>
</ul>
</li>
</ul>
<h1 id="ADC"><a href="#ADC" class="headerlink" title="ADC"></a>ADC</h1><h2 id="1-工作原理-1"><a href="#1-工作原理-1" class="headerlink" title="1.工作原理"></a>1.工作原理</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190026875.png" alt="image-20241130132029534"></p>
<p>GT32F303ZET6 MCU 内置三个 ADC 模块，分别是 ADC0 、ADC1 和 ADC2 。这些 ADC 的分辨率是可以配置的，支持 12 位、10 位、8 位或 6 位。此外，ADC 还支持自校准功能，以提高采样的精度。采样时间和周期是可编程的，包括 1.5 个周期、7.5 个周期等选项，转换结果可以配置为左对齐或右对齐的方式。</p>
<p>对于规则组数据转换，可以使用 DMA 配合搬移数据，从而减轻 CPU 的负担。ADC0 和 ADC1 各自拥有 16 路外部模拟输入通道，而 ADC2 的通道数较少。ADC0 还集成了一个内部温度传感器输入通道和一个内部参考电压输入通道。需要注意的是，内部温度传感器只能测量 MCU芯片的温度，无法测量环境温度。</p>
<p><strong>ADC支持多种转换模式，包括单次模式、连续模式、扫描模式、间断模式和同步模式。</strong></p>
<p><strong>ADC转换完成后，会产生EOC（End Of Conversion）标志</strong>，这一标志可以进一步触发NVIC中断。ADC的供电电源为VDD_A和VSSA，支持2.6V到3.6V，通常直接使用板子上的主电源3.3V。参考电源VREFP和VREFN通常将VREFP连接到VDD_A上，因此模拟输入通道的信号源输入电压范围为0V到3.3V。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190026005.png" alt="image-20241130132207744"></p>
<p>​    ADC 硬件结构包括 16 个外部模拟信号输入通道（通过 GPIO 复用）、一路温度传感器输入通道和一路参考电压输入通道，共18个 ADC </p>
<p>​    通道。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190028408.png" alt="image-20241130133726461"></p>
<p>在ADC转换之前，需要外部触发源进行触发，触发源包括<strong>定时器触发</strong>（如每秒或几百毫秒）、<strong>EXTI外部中断触发</strong>、<strong>软件触发</strong>（通过代码控制）。</p>
<p>GT32F303 MCU的ADC时钟频率最高为40MHz，由120MHz主时钟分频得到。在ADC转换器中，有规则组和注入组两种数据处理方式。规则组类似于程序的主流程，通常满足大部分需求，而注入组类似于程序中的中断，可以打断规则组的转换，优先执行注入组的任务，完成后再继续规则组的转换。转换完成的结果会存放在ADC数据寄存器中，规则组的16个通道共用一个数据寄存器，而注入组有四个独立的数据寄存器。</p>
<p>关于中断，使能ADC中断需要在初始化配置时分为两部分：</p>
<ul>
<li>单片机片上外设中打开中断输出控制。</li>
<li>内核（NVIC）中打开相应的中断开关，例如定时器的更新溢出中断。</li>
</ul>
<p>ADC通道框图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190029343.png" alt="image-20241130132431616"></p>
<p>ADC0、ADC1和ADC2的外部模拟输入通道通过GPIO口连接。ADC0和ADC1各有16个外部输入通道，分别对应PA0到PA7、PB0和PB1、PC0到PC5；而ADC2的通道数较少。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190029829.png" alt="image-20241130132504351"></p>
<p>转换模式包括</p>
<ul>
<li><p>单次模式：</p>
<p>每次ADC转换都需要外部触发源触发。</p>
</li>
<li><p>连续模式：</p>
<p>只需第一次触发，ADC将自动连续进行转换。</p>
</li>
<li><p>扫描模式：</p>
<p>针对单个ADC的多个通道，将通道号按序列放入转换序列寄存器，适用于多通道数据采集。</p>
</li>
<li><p>同步模式：</p>
<p>用于多个ADC模块同时使用的场景，如交替触发ADC0和ADC1，实现多个ADC的协同工作。相比之下，独立模式则仅单独使用某一个ADC模块，无需与其他ADC配合，适用于无需复杂协同的应用场景。常用的部分主要基于独立模式，结合单次、连续和扫描模式。</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190030614.png" alt="image-20241130132727258"></p>
<p>单次转换模式对应规则组，通过转换序列寄存器配置要转换的通道号。</p>
<p>例如，将PA2对应的通道2放在序列1中，由外部触发源触发ADC开始采集、量化和编码转换。转换完成后产生EOC标志位，下一次转换需再次触发源触发。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190030216.png" alt="image-20241130132748339"></p>
<p>连续转换模式则只需首次触发一次，ADC会自动进行后续转换，产生标志位后可读取数据寄存器内容。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190030883.png" alt="image-20241130132820364"></p>
<p>扫描模式适用于单个ADC的多通道转换，将多个通道号按序列寄存器配置后，外部触发源一次触发后，ADC依次转换各通道，完成后产生EOC标志位。</p>
<p>由于规则组只有一个数据寄存器，且每转换一个通道后数据都会移入数据寄存器中，多个通道的数据可能会被覆盖，因此需要配合DMA自动搬移数据到内存数组中，以防数据丢失。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190031476.png" alt="image-20241130133154078"></p>
<p>规则组与注入组的关系类似于程序主流程与中断。规则组按序列执行转换任务，注入组可以打断规则组的转换，优先处理注入组的转换任务，完成后再继续规则组的转换。通常项目中只需使用规则组即可，注入组的使用较为少见，具体可参考芯片用户手册和官方示例程序。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190031706.png" alt="image-20241130133740418"></p>
<p>ADC的数据对齐支持右对齐和左对齐。右对齐（默认）高位填充0，左对齐低位填充0。以12位分辨率为例，参考电压为3.3伏，对应数值范围为0到4095，每步最小电压变化约为0.8mV。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190032952.png" alt="image-20241130133843955"></p>
<p>ADC转换时间包括采样和保持、量化和编码两个步骤。转换时间等于采样时间加上固定的12.5个ADC周期。采样时间可配置，根据信号源的输出阻抗（RAIN）调整。例如，ADC时钟为30MHz，采样周期设置为1.5个周期，则转换时间为14个ADC周期，即0.467微秒。</p>
<p>ADC采集原理包括信号源通过输出阻抗<strong>R_AIN</strong>连接到采样电阻<strong>R_ADC</strong>和采样电容<strong>C_ADC</strong>。外部触发源触发转换后，采集开关SW闭合，通过<strong>R_AIN</strong>和<strong>R_ADC</strong>对<strong>C_ADC</strong>进行充电，电压达到信号源当前电压后采集开关SW抬起，保持电容两端的电压进行量化和编码转换。开关SW闭合断开的间隔时间即为采样时间周期（采样+保持）。</p>
<p>采样时间的设置依据电容充电公式：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190032982.png" alt="image-20241130135112526"></p>
<p>不同信号源的输出阻抗不同，需根据实际情况配置采样时间。</p>
<p>案例分析：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190032993.png" alt="image-20241130135347841"></p>
<p>校准与硬件滤波：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190032742.png" alt="image-20241130135759180"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190033927.png" alt="image-20241130135810508"></p>
<h2 id="2-单通道采集"><a href="#2-单通道采集" class="headerlink" title="2.单通道采集"></a>2.单通道采集</h2><p>开发板上有三个器件使用到了ADC（模数转换器）：</p>
<ul>
<li>可调电阻</li>
<li>热敏电阻</li>
<li>湿敏电阻</li>
</ul>
<p>本次重点使用可调电阻，并对应使用ADC的通道。</p>
<h3 id="1-硬件连接"><a href="#1-硬件连接" class="headerlink" title="1.硬件连接"></a><strong>1.硬件连接</strong></h3><blockquote>
<p>原理框图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190036162.png" alt="QQ20241201-173522"></p>
<p><strong>通道选择：</strong></p>
<ul>
<li>使用的通道：ADC0</li>
<li>对应GPIO口：PC2</li>
<li>通道编号：12</li>
</ul>
<p><strong>电源与电压范围：</strong></p>
<ul>
<li>供电电压：3.3V</li>
<li>电压范围：0V 到 3.3V</li>
</ul>
<p><strong>限流电阻说明：</strong></p>
<p>限流电阻不会用于分压。<strong>当GPIO口配置为模拟输入模式时，GPIO口呈现高阻态，因此限流电阻不会分压。</strong></p>
<p><strong>可调电阻调节：</strong></p>
<ul>
<li>调节到最上面时，采集到的电压为3.3V，对应数字量为4095。</li>
<li>调节到最下面时，采集到的电压为0V，对应数字量为0。</li>
</ul>
</blockquote>
<h3 id="2-代码实现-2"><a href="#2-代码实现-2" class="headerlink" title="2.代码实现"></a><strong>2.代码实现</strong></h3><h4 id="1-ADC-初始化配置"><a href="#1-ADC-初始化配置" class="headerlink" title="1.ADC 初始化配置"></a><strong>1.ADC 初始化配置</strong></h4><p><strong>初始化步骤：</strong></p>
<ol>
<li><p><strong>使能GPIO时钟并配置GPIO口：</strong></p>
<ul>
<li>使能GPIOC的时钟。</li>
<li>将PC2配置为模拟输入模式，速度为10MHz。</li>
</ul>
</li>
<li><p><strong>配置ADC部分：</strong></p>
<ul>
<li>使能ADC0的时钟。</li>
<li>设置ADC时钟分频系数为6分频，得到20MHz的ADC时钟。</li>
<li>设置ADC为独立模式，不与其他ADC协同工作。</li>
<li>配置ADC为单次转换模式，每次转换需要外部触发。</li>
<li>设置数据对齐为右对齐。</li>
<li>设置转换通道的个数为1。</li>
<li>配置转换通道为12，并放在序列寄存器的第0序列位置，采样时间为239.5个周期。</li>
<li>选择软件触发作为外部触发源，并使能外部触发。</li>
<li>使能ADC。</li>
<li>进行内部校准，延时50微秒后启动校准。</li>
</ul>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190036385.png" alt="image-20241201173325251"></p>
<p>以下是参考代码，用于初始化GPIO和ADC，并实现获取ADC值及测试函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f30x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* GPIO初始化 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">GPIOInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    rcu_periph_clock_enable(RCU_GPIOC);</span><br><span class="line">    gpio_init(GPIOC, GPIO_MODE_AIN, GPIO_OSPEED_10MHZ, GPIO_PIN_2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ADC初始化 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ADCInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 使能ADC时钟 */</span></span><br><span class="line">    rcu_periph_clock_enable(RCU_ADC0);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置ADC时钟分频系数为6分频（120MHz / 6 = 20MHz） */</span></span><br><span class="line">    rcu_adc_clock_config(RCU_CKADC_CKAPB2_DIV6);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置ADC为独立模式 */</span></span><br><span class="line">    adc_mode_config(ADC_MODE_FREE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置ADC为单次转换模式 */</span></span><br><span class="line">    adc_special_function_config(ADC0, ADC_CONTINUOUS_MODE, DISABLE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置数据对齐为右对齐 */</span></span><br><span class="line">    adc_data_alignment_config(ADC0, ADC_DATAALIGN_RIGHT);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置转换通道个数为1 */</span></span><br><span class="line">    adc_channel_length_config(ADC0, ADC_REGULAR_CHANNEL, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置转换通道12，放在序列寄存器的第0序列，采样时间239.5个周期 */</span></span><br><span class="line">    adc_regular_channel_config(ADC0, <span class="number">0</span>, ADC_CHANNEL_12, ADC_SAMPLETIME_239POINT5);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 选择软件触发作为外部触发源 */</span></span><br><span class="line">    adc_external_trigger_source_config(ADC0, ADC_REGULAR_CHANNEL, ADC0_1_2_EXTTRIG_REGULAR_NONE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 使能外部触发 */</span></span><br><span class="line">    adc_external_trigger_config(ADC0, ADC_REGULAR_CHANNEL, ENABLE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 使能ADC */</span></span><br><span class="line">    adc_enable(ADC0);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 内部校准 */</span></span><br><span class="line">    DelayNus(<span class="number">50</span>);</span><br><span class="line">    adc_calibration_enable(ADC0);</span><br><span class="line">    adc_software_trigger_enable(ADC0, ADC_REGULAR_CHANNEL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief ADC硬件初始化</span></span><br><span class="line"><span class="comment">* @param</span></span><br><span class="line"><span class="comment">* @return </span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">VresInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIOInit();</span><br><span class="line">    ADCInit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获取ADC值 */</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">GetAdcVal</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (!adc_flag_get(ADC0, ADC_FLAG_EOC));</span><br><span class="line">    <span class="keyword">return</span> adc_regular_data_read(ADC0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ADC测试函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">VresTest</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> AdcVal = GetAdcVal();</span><br><span class="line">    <span class="type">float</span> Voltage = (<span class="type">float</span>)AdcVal / <span class="number">4095</span> * <span class="number">3.3f</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;AdcVal = %d, Voltage = %.1f V.\n&quot;</span>, AdcVal, Voltage);</span><br><span class="line">    DelayNms(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-调试与问题解决"><a href="#2-调试与问题解决" class="headerlink" title="2.调试与问题解决"></a><strong>2.调试与问题解决</strong></h4><p>在编写和调试代码过程中，可能会遇到以下问题：</p>
<ol>
<li><p><strong>程序复位后只打印一次数据：</strong></p>
<ul>
<li>可能是因为没有正确调用回调函数或中断处理。</li>
<li>检查<code>system.c</code>中的定时器中断处理，确保回调函数指针不为空。</li>
</ul>
</li>
<li><p><strong>硬错误（Hard Fault）：</strong></p>
<ul>
<li>发生空指针引用，通常由于回调函数未正确初始化。</li>
<li>解决方法是在调用回调前加入空指针判断，例如：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (callback_ptr != <span class="literal">NULL</span>) </span><br><span class="line">&#123;</span><br><span class="line">    callback_ptr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>转换模式的调整：</strong></p>
<ul>
<li>初始实现为单次转换模式，每次获取ADC值都需要软件触发。</li>
<li>可扩展为连续转换模式，使得只需一次触发即可连续获取ADC值。</li>
</ul>
</li>
</ol>
<h4 id="3-实验与测试"><a href="#3-实验与测试" class="headerlink" title="3.实验与测试"></a><strong>3.实验与测试</strong></h4><p>​    将代码下载到开发板后，复位设备并观察串口打印的数据。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190037805.png" alt="QQ20241201-173721"></p>
<p>​    通过调节可调电阻的位置，可以看到ADC值和对应的电压值在0到3.3V之间变化。</p>
<h2 id="3-多通道采集"><a href="#3-多通道采集" class="headerlink" title="3.多通道采集"></a>3.多通道采集</h2><p>使用<strong>连续扫描模式</strong>，配合<strong>DMA</strong>（直接存储器访问）实现<strong>多通道的ADC转换</strong>。</p>
<h3 id="1-硬件连接-1"><a href="#1-硬件连接-1" class="headerlink" title="1.硬件连接"></a><strong>1.硬件连接</strong></h3><p>原理框图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190038454.png" alt="QQ20241201-174601"></p>
<blockquote>
<p><strong>转换通道选择：</strong></p>
<ul>
<li><p><strong>可调电阻</strong></p>
<ul>
<li>对应GPIO口：PC2</li>
<li>ADC通道编号：12</li>
</ul>
</li>
<li><p><strong>热敏电阻</strong></p>
<ul>
<li>对应GPIO口：PC3</li>
<li>ADC通道编号：13</li>
</ul>
</li>
</ul>
<p><strong>电源与电压范围：</strong></p>
<ul>
<li>供电电压：3.3V</li>
<li>电压范围：0V 到 3.3V</li>
</ul>
<p><strong>限流电阻说明：</strong></p>
<p>限流电阻不会用于分压。当将GPIO口配置为模拟输入模式时，GPIO口呈现高阻态，因此限流电阻不会分压。</p>
</blockquote>
<h3 id="2-代码实现-3"><a href="#2-代码实现-3" class="headerlink" title="2.代码实现"></a><strong>2.代码实现</strong></h3><h4 id="1-ADC-初始化配置-1"><a href="#1-ADC-初始化配置-1" class="headerlink" title="1.ADC 初始化配置"></a><strong>1.ADC 初始化配置</strong></h4><blockquote>
<p>与单次转换模式相比，连续扫描模式需要进行以下配置：</p>
<ol>
<li><p><strong>使能连续模式和扫描模式：</strong></p>
<ul>
<li>设置ADC为连续转换模式。</li>
<li>启用扫描模式，以支持多通道转换。</li>
</ul>
</li>
<li><p><strong>使能ADC的DMA功能：</strong></p>
<ul>
<li>通过DMA将转换结果自动搬移到内存数组中，减少CPU负担。</li>
</ul>
</li>
<li><p><strong>配置转换通道：</strong></p>
<ul>
<li>设置转换通道数量为2，分别为通道12和通道13。</li>
<li>配置每个通道在转换序列中的位置。</li>
</ul>
</li>
</ol>
</blockquote>
<h4 id="2-DMA-初始化配置"><a href="#2-DMA-初始化配置" class="headerlink" title="2.DMA 初始化配置"></a><strong>2.DMA 初始化配置</strong></h4><blockquote>
<p>DMA的初始化配置与之前讲解的串口配合DMA的方法基本相同，主要步骤如下：</p>
<ol>
<li><p><strong>使能DMA时钟并复位DMA通道：</strong></p>
<ul>
<li>使能对应DMA控制器的时钟。</li>
<li>复位DMA通道以确保配置的正确性。</li>
</ul>
</li>
<li><p><strong>配置DMA传输参数：</strong></p>
<ul>
<li><strong>传输方向：</strong> 外设到内存。</li>
<li><strong>源地址：</strong> ADC的数据寄存器地址。</li>
<li><strong>目的地址：</strong> 存放ADC转换结果的数组。</li>
<li><strong>数据传输位宽：</strong> 16位（由于ADC使用12位分辨率）。</li>
<li><strong>传输次数：</strong> 2次（对应两个通道）。</li>
<li><strong>循环模式：</strong> 使能循环模式，实现数据的循环搬移。</li>
</ul>
</li>
<li><p><strong>使能DMA通道：</strong></p>
<ul>
<li>启动DMA通道，使其开始工作。</li>
</ul>
</li>
</ol>
</blockquote>
<p>ADC多通道配合DMA转换配置框图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190037859.png" alt="image-20241201174501329"></p>
<p>以下是参考代码，用于初始化GPIO、ADC和DMA，并实现获取多通道ADC值及测试函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f30x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* GPIO初始化 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">GPIOInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    rcu_periph_clock_enable(RCU_GPIOC);</span><br><span class="line">    gpio_init(GPIOC, GPIO_MODE_AIN, GPIO_OSPEED_10MHZ, GPIO_PIN_2);</span><br><span class="line">    gpio_init(GPIOC, GPIO_MODE_AIN, GPIO_OSPEED_10MHZ, GPIO_PIN_3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ADC初始化 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ADCInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 使能ADC时钟 */</span></span><br><span class="line">    rcu_periph_clock_enable(RCU_ADC0);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置ADC时钟分频系数为6分频（120MHz / 6 = 20MHz） */</span></span><br><span class="line">    rcu_adc_clock_config(RCU_CKADC_CKAPB2_DIV6);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置ADC为独立模式 */</span></span><br><span class="line">    adc_mode_config(ADC_MODE_FREE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置ADC为连续转换模式 */</span></span><br><span class="line">    adc_special_function_config(ADC0, ADC_CONTINUOUS_MODE, ENABLE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置扫描模式 */</span></span><br><span class="line">    adc_special_function_config(ADC0, ADC_SCAN_MODE, ENABLE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置数据对齐为右对齐 */</span></span><br><span class="line">    adc_data_alignment_config(ADC0, ADC_DATAALIGN_RIGHT);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置转换通道个数为2 */</span></span><br><span class="line">    adc_channel_length_config(ADC0, ADC_REGULAR_CHANNEL, <span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置转换通道12，放在序列寄存器的第0序列，采样时间239.5个周期 */</span></span><br><span class="line">    adc_regular_channel_config(ADC0, <span class="number">0</span>, ADC_CHANNEL_12, ADC_SAMPLETIME_239POINT5);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置转换通道13，放在序列寄存器的第1序列，采样时间239.5个周期 */</span></span><br><span class="line">    adc_regular_channel_config(ADC0, <span class="number">1</span>, ADC_CHANNEL_13, ADC_SAMPLETIME_239POINT5);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 选择软件触发作为外部触发源 */</span></span><br><span class="line">    adc_external_trigger_source_config(ADC0, ADC_REGULAR_CHANNEL, ADC0_1_2_EXTTRIG_REGULAR_NONE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 使能外部触发 */</span></span><br><span class="line">    adc_external_trigger_config(ADC0, ADC_REGULAR_CHANNEL, ENABLE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 使能ADC的DMA功能 */</span></span><br><span class="line">    adc_dma_mode_enable(ADC0);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 使能ADC */</span></span><br><span class="line">    adc_enable(ADC0);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 内部校准 */</span></span><br><span class="line">    DelayNus(<span class="number">50</span>);</span><br><span class="line">    adc_calibration_enable(ADC0);</span><br><span class="line">    adc_software_trigger_enable(ADC0, ADC_REGULAR_CHANNEL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADC0_RDATA_ADDR    (ADC0 + 0x4C)</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint16_t</span> g_adcVal[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* DMA初始化 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">DMAInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 使能DMA时钟 */</span></span><br><span class="line">    rcu_periph_clock_enable(RCU_DMA0);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 复位DMA通道 */</span></span><br><span class="line">    dma_deinit(DMA0, DMA_CH0);</span><br><span class="line">    </span><br><span class="line">    dma_parameter_struct dmaStruct;</span><br><span class="line">    dma_struct_para_init(&amp;dmaStruct);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置传输方向：外设到内存 */</span></span><br><span class="line">    dmaStruct.direction = DMA_PERIPHERAL_TO_MEMORY;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置数据源地址 */</span></span><br><span class="line">    dmaStruct.periph_addr = ADC0_RDATA_ADDR;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置源地址不递增 */</span></span><br><span class="line">    dmaStruct.periph_inc = DMA_PERIPH_INCREASE_DISABLE;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置源数据传输位宽为16位 */</span></span><br><span class="line">    dmaStruct.periph_width = DMA_PERIPHERAL_WIDTH_16BIT;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置数据目的地址 */</span></span><br><span class="line">    dmaStruct.memory_addr = (<span class="type">uint32_t</span>)g_adcVal;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置目的地址递增 */</span></span><br><span class="line">    dmaStruct.memory_inc = DMA_MEMORY_INCREASE_ENABLE;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置目的数据传输位宽为16位 */</span></span><br><span class="line">    dmaStruct.memory_width = DMA_MEMORY_WIDTH_16BIT;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置数据传输最大次数为2 */</span></span><br><span class="line">    dmaStruct.number = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置DMA通道优先级为高 */</span></span><br><span class="line">    dmaStruct.priority = DMA_PRIORITY_HIGH;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 初始化DMA通道 */</span></span><br><span class="line">    dma_init(DMA0, DMA_CH0, &amp;dmaStruct);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 使能DMA循环模式搬移数据 */</span></span><br><span class="line">    dma_circulation_enable(DMA0, DMA_CH0);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 使能DMA通道 */</span></span><br><span class="line">    dma_channel_enable(DMA0, DMA_CH0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief ADC硬件初始化</span></span><br><span class="line"><span class="comment">* @param</span></span><br><span class="line"><span class="comment">* @return </span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">VresInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIOInit();</span><br><span class="line">    ADCInit();</span><br><span class="line">    DMAInit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ADC测试函数 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">VresTest</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;CH12 AdcVal = %d.\n&quot;</span>, g_adcVal[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;CH13 AdcVal = %d.\n&quot;</span>, g_adcVal[<span class="number">1</span>]);</span><br><span class="line">    DelayNms(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-调试与问题解决"><a href="#3-调试与问题解决" class="headerlink" title="3.调试与问题解决"></a><strong>3.调试与问题解决</strong></h4><blockquote>
<p>在编写和调试代码过程中，可能会遇到以下问题：</p>
<ol>
<li><p><strong>数据未正确搬移到内存数组：</strong></p>
<ul>
<li><strong>原因：</strong> DMA配置不正确或DMA未使能。</li>
<li><strong>解决方法：</strong> 检查DMA初始化配置，确保DMA通道已使能并配置为循环模式。</li>
</ul>
</li>
<li><p><strong>硬错误（Hard Fault）：</strong></p>
<ul>
<li><strong>原因：</strong> DMA传输地址配置错误，导致访问非法内存。</li>
<li><strong>解决方法：</strong> 确认DMA源地址和目的地址配置正确，确保目的数组已正确声明并分配足够内存。</li>
</ul>
</li>
<li><p><strong>ADC数据不更新或保持不变：</strong></p>
<ul>
<li><strong>原因：</strong> ADC未正确启动或DMA未正确配置。</li>
<li><strong>解决方法：</strong> 确认ADC已使能并开始转换，检查DMA是否正常工作。</li>
</ul>
</li>
<li><p><strong>CPU负担过重或系统响应缓慢：</strong></p>
<ul>
<li><strong>原因：</strong> 未使用DMA，手动读取ADC数据导致CPU负担增加。</li>
<li><strong>解决方法：</strong>使用DMA搬移数据，减少CPU的中断处理次数。</li>
</ul>
</li>
</ol>
</blockquote>
<h2 id="4-滤波处理"><a href="#4-滤波处理" class="headerlink" title="4.滤波处理"></a>4.滤波处理</h2><h3 id="1-硬件滤波"><a href="#1-硬件滤波" class="headerlink" title="1.硬件滤波"></a><strong>1.硬件滤波</strong></h3><blockquote>
<p><strong>过采样滤波原理：</strong></p>
<ul>
<li><strong>过采样单元</strong>通过多次采样并求和，随后进行右移操作，实现数据的平均滤波。</li>
<li><strong>配置参数：</strong><ul>
<li><strong>n</strong>：代表将多少次的结果求和。</li>
<li><strong>m</strong>：对应的是除法系数，即右移的次数。右移一次相当于除以二，右移两次相当于除以四，依此类推。</li>
</ul>
</li>
</ul>
<p><strong>实例配置：</strong></p>
<ul>
<li>配置为取16次的结果求和（n = 16）。</li>
<li>进行右移4次（m = 4），相当于除以16。</li>
</ul>
<p><strong>硬件滤波的优势：</strong></p>
<ul>
<li>减少CPU的负担，提升系统效率。</li>
<li>实现快速的硬件滤波，提升数据处理速度。</li>
</ul>
<p><strong>ADC 硬件滤波初始化配置：</strong></p>
<p>与之前的连续扫描模式和DMA配置相比，硬件滤波模式需要进行以下额外配置：</p>
<ol>
<li><p><strong>配置ADC为连续模式：</strong></p>
<ul>
<li>设置ADC为连续转换模式，只需一次触发即可连续进行转换。</li>
</ul>
</li>
<li><p><strong>配置硬件滤波参数：</strong></p>
<ul>
<li>设置过采样次数（n）和右移次数（m）。</li>
<li>例如，配置为16次求和，右移4次。</li>
</ul>
</li>
<li><p><strong>使能ADC的过采样模式：</strong></p>
<ul>
<li>启用ADC的过采样功能，以实现硬件滤波。</li>
</ul>
</li>
</ol>
</blockquote>
<h3 id="2-软件滤波"><a href="#2-软件滤波" class="headerlink" title="2.软件滤波"></a><strong>2.软件滤波</strong></h3><blockquote>
<p>在项目开发中，软件滤波算法常用于处理ADC采集的数据。以下介绍几种常用的软件滤波算法：</p>
<ol>
<li><p><strong>算术平均滤波法（Arithmetic Average Filter）：</strong></p>
<ul>
<li>取n个采样值进行算术平均运算。</li>
<li>简单易实现，但对极端值敏感。</li>
</ul>
</li>
<li><p><strong>中位值滤波法（Median Filter）：</strong></p>
<ul>
<li>连续采样n次，将n次采样值按大小排序，取中间值作为有效值。</li>
<li>对极端值有较好的抑制效果，适用于去除脉冲干扰。</li>
</ul>
</li>
<li><p><strong>中位值平均滤波法（Median Average Filter）：</strong></p>
<ul>
<li>连续采样n个数据，去掉一个最大值和一个最小值，然后计算剩余n-2个数据的算术平均值。</li>
<li>兼具算术平均和中位值滤波的优点，既能去除极端值，又能平滑数据。</li>
</ul>
</li>
</ol>
</blockquote>
<h3 id="3-代码实现-2"><a href="#3-代码实现-2" class="headerlink" title="3.代码实现"></a><strong>3.代码实现</strong></h3><p>以下是参考代码，用于初始化GPIO和ADC，并实现ADC硬件滤波功能及测试函数：</p>
<h4 id="1-硬件滤波代码"><a href="#1-硬件滤波代码" class="headerlink" title="1.硬件滤波代码"></a><strong>1.硬件滤波代码</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f30x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* GPIO初始化 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">GPIOInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    rcu_periph_clock_enable(RCU_GPIOC);</span><br><span class="line">    gpio_init(GPIOC, GPIO_MODE_AIN, GPIO_OSPEED_10MHZ, GPIO_PIN_2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ADC初始化 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ADCInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 使能ADC时钟 */</span></span><br><span class="line">    rcu_periph_clock_enable(RCU_ADC0);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置ADC时钟分频系数为6分频（120MHz / 6 = 20MHz） */</span></span><br><span class="line">    rcu_adc_clock_config(RCU_CKADC_CKAPB2_DIV6);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置ADC为独立模式 */</span></span><br><span class="line">    adc_mode_config(ADC_MODE_FREE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置连续转换模式 */</span></span><br><span class="line">    adc_special_function_config(ADC0, ADC_CONTINUOUS_MODE, ENABLE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置数据对齐为右对齐 */</span></span><br><span class="line">    adc_data_alignment_config(ADC0, ADC_DATAALIGN_RIGHT);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置转换通道个数为1 */</span></span><br><span class="line">    adc_channel_length_config(ADC0, ADC_REGULAR_CHANNEL, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置转换通道12，放在序列寄存器的第0序列，采样时间239.5个周期 */</span></span><br><span class="line">    adc_regular_channel_config(ADC0, <span class="number">0</span>, ADC_CHANNEL_12, ADC_SAMPLETIME_239POINT5);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 选择软件触发作为外部触发源 */</span></span><br><span class="line">    adc_external_trigger_source_config(ADC0, ADC_REGULAR_CHANNEL, ADC0_1_2_EXTTRIG_REGULAR_NONE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 使能外部触发 */</span></span><br><span class="line">    adc_external_trigger_config(ADC0, ADC_REGULAR_CHANNEL, ENABLE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置硬件滤波 */</span></span><br><span class="line">    adc_oversample_mode_config(ADC0, ADC_OVERSAMPLING_ALL_CONVERT, ADC_OVERSAMPLING_SHIFT_4B, ADC_OVERSAMPLING_RATIO_MUL16);</span><br><span class="line">    adc_oversample_mode_enable(ADC0);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 使能ADC */</span></span><br><span class="line">    adc_enable(ADC0);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 内部校准 */</span></span><br><span class="line">    DelayNus(<span class="number">50</span>);</span><br><span class="line">    adc_calibration_enable(ADC0);</span><br><span class="line">    adc_software_trigger_enable(ADC0, ADC_REGULAR_CHANNEL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief ADC硬件初始化</span></span><br><span class="line"><span class="comment">* @param</span></span><br><span class="line"><span class="comment">* @return </span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">VresInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIOInit();</span><br><span class="line">    ADCInit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">GetAdcVal</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (!adc_flag_get(ADC0, ADC_FLAG_EOC));</span><br><span class="line">    <span class="keyword">return</span> adc_regular_data_read(ADC0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">VresTest</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> AdcVal = GetAdcVal();</span><br><span class="line">    <span class="type">float</span> Voltage = (<span class="type">float</span>)AdcVal / <span class="number">4095</span> * <span class="number">3.3f</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;AdcVal = %d, Voltage = %.1f V.\n&quot;</span>, AdcVal, Voltage);</span><br><span class="line">    DelayNms(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-软件滤波代码："><a href="#2-软件滤波代码：" class="headerlink" title="2.软件滤波代码："></a><strong>2.软件滤波代码：</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f30x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ADC0_RDATA_ADDR    (ADC0 + 0x4C)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BUF_SIZE        10</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint16_t</span> g_adcVal[MAX_BUF_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* GPIO初始化 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">GPIOInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    rcu_periph_clock_enable(RCU_GPIOC);</span><br><span class="line">    gpio_init(GPIOC, GPIO_MODE_AIN, GPIO_OSPEED_10MHZ, GPIO_PIN_2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ADC初始化 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ADCInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 使能ADC时钟 */</span></span><br><span class="line">    rcu_periph_clock_enable(RCU_ADC0);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置ADC时钟分频系数为6分频（120MHz / 6 = 20MHz） */</span></span><br><span class="line">    rcu_adc_clock_config(RCU_CKADC_CKAPB2_DIV6);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置ADC为独立模式 */</span></span><br><span class="line">    adc_mode_config(ADC_MODE_FREE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置连续转换模式 */</span></span><br><span class="line">    adc_special_function_config(ADC0, ADC_CONTINUOUS_MODE, ENABLE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置扫描模式 */</span></span><br><span class="line">    adc_special_function_config(ADC0, ADC_SCAN_MODE, ENABLE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置数据对齐为右对齐 */</span></span><br><span class="line">    adc_data_alignment_config(ADC0, ADC_DATAALIGN_RIGHT);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 设置转换通道个数为1 */</span></span><br><span class="line">    adc_channel_length_config(ADC0, ADC_REGULAR_CHANNEL, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置转换通道12，放在序列寄存器的第0序列，采样时间239.5个周期 */</span></span><br><span class="line">    adc_regular_channel_config(ADC0, <span class="number">0</span>, ADC_CHANNEL_12, ADC_SAMPLETIME_239POINT5);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 选择软件触发作为外部触发源 */</span></span><br><span class="line">    adc_external_trigger_source_config(ADC0, ADC_REGULAR_CHANNEL, ADC0_1_2_EXTTRIG_REGULAR_NONE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 使能外部触发 */</span></span><br><span class="line">    adc_external_trigger_config(ADC0, ADC_REGULAR_CHANNEL, ENABLE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 使能ADC的DMA功能 */</span></span><br><span class="line">    adc_dma_mode_enable(ADC0);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 使能ADC */</span></span><br><span class="line">    adc_enable(ADC0);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 内部校准 */</span></span><br><span class="line">    DelayNus(<span class="number">50</span>);</span><br><span class="line">    adc_calibration_enable(ADC0);</span><br><span class="line">    adc_software_trigger_enable(ADC0, ADC_REGULAR_CHANNEL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* DMA初始化 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">DMAInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 使能DMA时钟 */</span></span><br><span class="line">    rcu_periph_clock_enable(RCU_DMA0);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 复位DMA通道 */</span></span><br><span class="line">    dma_deinit(DMA0, DMA_CH0);</span><br><span class="line">    </span><br><span class="line">    dma_parameter_struct dmaStruct;</span><br><span class="line">    dma_struct_para_init(&amp;dmaStruct);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置传输方向：外设到内存 */</span></span><br><span class="line">    dmaStruct.direction = DMA_PERIPHERAL_TO_MEMORY;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置数据源地址 */</span></span><br><span class="line">    dmaStruct.periph_addr = ADC0_RDATA_ADDR;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置源地址不递增 */</span></span><br><span class="line">    dmaStruct.periph_inc = DMA_PERIPH_INCREASE_DISABLE;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置源数据传输位宽为16位 */</span></span><br><span class="line">    dmaStruct.periph_width = DMA_PERIPHERAL_WIDTH_16BIT;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置数据目的地址 */</span></span><br><span class="line">    dmaStruct.memory_addr = (<span class="type">uint32_t</span>)g_adcVal;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置目的地址递增 */</span></span><br><span class="line">    dmaStruct.memory_inc = DMA_MEMORY_INCREASE_ENABLE;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置目的数据传输位宽为16位 */</span></span><br><span class="line">    dmaStruct.memory_width = DMA_MEMORY_WIDTH_16BIT;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置数据传输最大次数为MAX_BUF_SIZE */</span></span><br><span class="line">    dmaStruct.number = MAX_BUF_SIZE;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 配置DMA通道优先级为高 */</span></span><br><span class="line">    dmaStruct.priority = DMA_PRIORITY_HIGH;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 初始化DMA通道 */</span></span><br><span class="line">    dma_init(DMA0, DMA_CH0, &amp;dmaStruct);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 使能DMA循环模式搬移数据 */</span></span><br><span class="line">    dma_circulation_enable(DMA0, DMA_CH0);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 使能DMA通道 */</span></span><br><span class="line">    dma_channel_enable(DMA0, DMA_CH0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief ADC硬件初始化</span></span><br><span class="line"><span class="comment">* @param</span></span><br><span class="line"><span class="comment">* @return </span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">VresInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPIOInit();</span><br><span class="line">    ADCInit();</span><br><span class="line">    DMAInit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 算术平均滤波函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint16_t</span> <span class="title function_">ArithAvgFltr</span><span class="params">(<span class="type">uint16_t</span> *arr, <span class="type">uint32_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">uint16_t</span>)(sum / len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">VresTest</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> buf[MAX_BUF_SIZE];</span><br><span class="line">    <span class="built_in">memcpy</span>(buf, g_adcVal, <span class="keyword">sizeof</span>(<span class="type">uint16_t</span>) * MAX_BUF_SIZE);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint8_t</span> i = <span class="number">0</span>; i &lt; MAX_BUF_SIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;AdcVal[%d] = %d.\n&quot;</span>, i, buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> res = ArithAvgFltr(buf, MAX_BUF_SIZE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;res = %d.\n&quot;</span>, res);</span><br><span class="line">    DelayNms(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-调试与问题解决-1"><a href="#3-调试与问题解决-1" class="headerlink" title="3.调试与问题解决"></a><strong>3.调试与问题解决</strong></h4><blockquote>
<p>在实现和调试ADC滤波功能时，可能会遇到以下问题：</p>
<ol>
<li><p><strong>ADC数据不更新或保持不变：</strong></p>
<ul>
<li><strong>原因：</strong> ADC未正确启动或DMA未正确配置。</li>
<li><strong>解决方法：</strong> 确认ADC已使能并开始转换，检查DMA配置是否正确，确保DMA通道已使能。</li>
</ul>
</li>
<li><p><strong>硬错误（Hard Fault）：</strong></p>
<ul>
<li><strong>原因：</strong> DMA传输地址配置错误，导致访问非法内存。</li>
<li><strong>解决方法：</strong> 确认DMA源地址和目的地址配置正确，确保目的数组已正确声明并分配足够内存。</li>
</ul>
</li>
<li><p><strong>滤波结果不准确：</strong></p>
<ul>
<li><strong>原因：</strong> 过采样参数配置不当，或滤波算法实现有误。</li>
<li><strong>解决方法：</strong> 检查过采样次数和右移次数的配置，确保滤波算法逻辑正确。</li>
</ul>
</li>
<li><p><strong>CPU负担过重或系统响应缓慢：</strong></p>
<ul>
<li><strong>原因：</strong> 未使用DMA，手动读取ADC数据导致CPU负担增加。</li>
<li><strong>解决方法：</strong> 使用DMA搬移数据，减少CPU的中断处理次数。</li>
</ul>
</li>
</ol>
</blockquote>
<h2 id="5-快速排序"><a href="#5-快速排序" class="headerlink" title="5.快速排序"></a>5.快速排序</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a><strong>1.概述</strong></h3><blockquote>
<p><strong>快速排序（Quick Sort）</strong>是一种高效的排序算法，采用分治策略，通过一个基准元素将数组分成两部分，递归地排序这两部分。相比<strong>冒泡排序法</strong>，快速排序具有以下优势：</p>
<ul>
<li><strong>更高的性能</strong>：平均时间复杂度为O(n log n)，而冒泡排序为O(n²)。</li>
<li><strong>更灵活</strong>：C标准库提供了快速排序的接口函数<code>qsort</code>，简化了排序过程。</li>
</ul>
<p><strong>快速排序优点</strong></p>
<ul>
<li><strong>灵活性</strong>：<code>qsort</code>函数允许用户自定义排序规则，通过函数指针实现升序或降序排序。</li>
<li><strong>性能优越</strong>：快速排序在大多数情况下比冒泡排序更快，适用于需要高效排序的应用场景。</li>
</ul>
</blockquote>
<h3 id="2-qsort函数"><a href="#2-qsort函数" class="headerlink" title="2.qsort函数"></a><strong>2.<code>qsort</code>函数</strong></h3><blockquote>
<p>在C标准库中，<code>qsort</code>函数用于对数组进行排序。其函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">qsort</span><span class="params">(<span class="type">void</span> *base, <span class="type">size_t</span> nmemb, <span class="type">size_t</span> size, <span class="type">int</span> (*compar)(<span class="type">const</span> <span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *))</span>;</span><br></pre></td></tr></table></figure>
<p><strong>参数说明：</strong></p>
<ol>
<li><strong><code>base</code></strong>：指向要排序的数组的首地址。</li>
<li><strong><code>nmemb</code></strong>：数组中元素的个数。</li>
<li><strong><code>size</code></strong>：数组中每个元素所占用的内存空间大小（通常使用<code>sizeof</code>运算符计算）。</li>
<li><strong><code>compar</code></strong>：指向比较函数的指针，用于定义排序规则（升序或降序）。</li>
</ol>
<p><strong>比较函数的定义：</strong></p>
<p>比较函数必须符合以下签名：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">compar</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span>;</span><br></pre></td></tr></table></figure>
<p><strong>返回值：</strong></p>
<ul>
<li><strong>负值</strong>：如果<code>*a</code>小于<code>*b</code>。</li>
<li><strong>零</strong>：如果<code>*a</code>等于<code>*b</code>。</li>
<li><strong>正值</strong>：如果<code>*a</code>大于<code>*b</code>（升序）。</li>
</ul>
<p>通过调整比较函数的返回值，可以实现升序或降序排序。</p>
</blockquote>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h3><p>以下是一个使用<code>qsort</code>对<code>uint16_t</code>类型数组和结构体数组进行排序的示例代码。</p>
<h4 id="1-排序整数数组"><a href="#1-排序整数数组" class="headerlink" title="1. 排序整数数组"></a><strong>1. 排序整数数组</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led_drv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;key_drv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;systick.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usb2com_drv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rtc_drv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vres_drv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usb2com_app.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hmi_app.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">DrvInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    DelayInit();</span><br><span class="line">    LedInit();</span><br><span class="line">    KeyInit();</span><br><span class="line">    Usb2ComInit();</span><br><span class="line">    RtcInit();</span><br><span class="line">    VresInit();</span><br><span class="line">    SystickInit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> id;</span><br><span class="line">    <span class="type">uint8_t</span> score;</span><br><span class="line">&#125; StuInfo_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 整数数组比较函数（降序） */</span></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">CmpCb</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *_a, <span class="type">const</span> <span class="type">void</span> *_b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> *a = (<span class="type">uint16_t</span> *)_a;</span><br><span class="line">    <span class="type">uint16_t</span> *b = (<span class="type">uint16_t</span> *)_b;</span><br><span class="line">    <span class="keyword">if</span> (*a &gt; *b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*a &lt; *b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 结构体数组比较函数（降序） */</span></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">StuCmpCb</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *_a, <span class="type">const</span> <span class="type">void</span> *_b)</span></span><br><span class="line">&#123;</span><br><span class="line">    StuInfo_t *a = (StuInfo_t *)_a;</span><br><span class="line">    StuInfo_t *b = (StuInfo_t *)_b;</span><br><span class="line">    <span class="keyword">if</span> (a-&gt;score &gt; b-&gt;score)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a-&gt;score &lt; b-&gt;score)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;	</span><br><span class="line">    DrvInit();</span><br><span class="line">    <span class="type">uint16_t</span> num[<span class="number">10</span>] = &#123;<span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">26</span>, <span class="number">52</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">14</span>, <span class="number">56</span>&#125;;</span><br><span class="line">    <span class="type">uint16_t</span> sz = <span class="keyword">sizeof</span>(num) / <span class="keyword">sizeof</span>(num[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 使用qsort对整数数组进行降序排序 */</span></span><br><span class="line">    qsort(num, sz, <span class="keyword">sizeof</span>(num[<span class="number">0</span>]), CmpCb);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint8_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;num[%d] = %d.\n&quot;</span>, i, num[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 定义并初始化结构体数组 */</span></span><br><span class="line">    StuInfo_t stuInfo[<span class="number">5</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">90</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="number">65</span>&#125;,</span><br><span class="line">        &#123;<span class="number">3</span>, <span class="number">80</span>&#125;,</span><br><span class="line">        &#123;<span class="number">4</span>, <span class="number">75</span>&#125;,</span><br><span class="line">        &#123;<span class="number">5</span>, <span class="number">70</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 使用qsort对结构体数组进行降序排序 */</span></span><br><span class="line">    qsort(stuInfo, <span class="number">5</span>, <span class="keyword">sizeof</span>(stuInfo[<span class="number">0</span>]), StuCmpCb);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint8_t</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;student id = %d, score = %d.\n&quot;</span>, stuInfo[i].id, stuInfo[i].score);</span><br><span class="line">    &#125;	</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-排序结构体数组"><a href="#2-排序结构体数组" class="headerlink" title="2. 排序结构体数组"></a><strong>2. 排序结构体数组</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;systick.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usb2com_drv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;rtc_drv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vres_drv.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;usb2com_app.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">DrvInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    DelayInit();</span><br><span class="line">    LedInit();</span><br><span class="line">    KeyInit();</span><br><span class="line">    Usb2ComInit();</span><br><span class="line">    RtcInit();</span><br><span class="line">    VresInit();</span><br><span class="line">    SystickInit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> id;</span><br><span class="line">    <span class="type">uint8_t</span> score;</span><br><span class="line">&#125; StuInfo_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 结构体数组比较函数（降序） */</span></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">StuCmpCb</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *_a, <span class="type">const</span> <span class="type">void</span> *_b)</span></span><br><span class="line">&#123;</span><br><span class="line">    StuInfo_t *a = (StuInfo_t *)_a;</span><br><span class="line">    StuInfo_t *b = (StuInfo_t *)_b;</span><br><span class="line">    <span class="keyword">if</span> (a-&gt;score &gt; b-&gt;score)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a-&gt;score &lt; b-&gt;score)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;	</span><br><span class="line">    DrvInit();</span><br><span class="line">    <span class="type">uint16_t</span> num[<span class="number">10</span>] = &#123;<span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">26</span>, <span class="number">52</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">14</span>, <span class="number">56</span>&#125;;</span><br><span class="line">    <span class="type">uint16_t</span> sz = <span class="keyword">sizeof</span>(num) / <span class="keyword">sizeof</span>(num[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 使用qsort对整数数组进行降序排序 */</span></span><br><span class="line">    qsort(num, sz, <span class="keyword">sizeof</span>(num[<span class="number">0</span>]), CmpCb);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint8_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;num[%d] = %d.\n&quot;</span>, i, num[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 定义并初始化结构体数组 */</span></span><br><span class="line">    StuInfo_t stuInfo[<span class="number">5</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">90</span>&#125;,</span><br><span class="line">        &#123;<span class="number">2</span>, <span class="number">65</span>&#125;,</span><br><span class="line">        &#123;<span class="number">3</span>, <span class="number">80</span>&#125;,</span><br><span class="line">        &#123;<span class="number">4</span>, <span class="number">75</span>&#125;,</span><br><span class="line">        &#123;<span class="number">5</span>, <span class="number">70</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 使用qsort对结构体数组进行降序排序 */</span></span><br><span class="line">    qsort(stuInfo, <span class="number">5</span>, <span class="keyword">sizeof</span>(stuInfo[<span class="number">0</span>]), StuCmpCb);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint8_t</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;student id = %d, score = %d.\n&quot;</span>, stuInfo[i].id, stuInfo[i].score);</span><br><span class="line">    &#125;	</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码讲解"><a href="#代码讲解" class="headerlink" title="代码讲解"></a><strong>代码讲解</strong></h3><h4 id="1-排序整数数组-1"><a href="#1-排序整数数组-1" class="headerlink" title="1. 排序整数数组"></a><strong>1. 排序整数数组</strong></h4><blockquote>
<p>在本例中，我们定义了一个<code>uint16_t</code>类型的数组<code>num</code>，包含10个元素。通过调用<code>qsort</code>函数，对该数组进行降序排序。</p>
<p><strong>关键步骤：</strong></p>
<ol>
<li><p><strong>定义比较函数<code>CmpCb</code></strong>：</p>
<ul>
<li>接受两个<code>const void *</code>类型的指针，分别指向数组中的两个元素。</li>
<li>将其转换为<code>uint16_t *</code>类型。</li>
<li>比较两个数的大小，返回<code>-1</code>（如果第一个数大于第二个数）、<code>1</code>（如果第一个数小于第二个数）或<code>0</code>（相等）。</li>
<li>该实现实现了<strong>降序排序</strong>。</li>
</ul>
</li>
<li><p><strong>调用<code>qsort</code>函数</strong>：</p>
<ul>
<li><strong>第一个参数</strong>：数组<code>num</code>的首地址。</li>
<li><strong>第二个参数</strong>：数组元素的个数（10）。</li>
<li><strong>第三个参数</strong>：数组元素所占用的内存空间大小（<code>sizeof(num[0])</code>）。</li>
<li><strong>第四个参数</strong>：比较函数的指针（<code>CmpCb</code>）。</li>
</ul>
</li>
<li><p><strong>打印排序后的数组</strong>：</p>
<ul>
<li>使用<code>for</code>循环遍历数组，并通过<code>printf</code>函数打印每个元素的值。</li>
</ul>
</li>
</ol>
<p><strong>输出结果示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">num[<span class="number">0</span>] = <span class="number">56.</span></span><br><span class="line">num[<span class="number">1</span>] = <span class="number">52.</span></span><br><span class="line">num[<span class="number">2</span>] = <span class="number">26.</span></span><br><span class="line">num[<span class="number">3</span>] = <span class="number">14.</span></span><br><span class="line">num[<span class="number">4</span>] = <span class="number">9.</span></span><br><span class="line">num[<span class="number">5</span>] = <span class="number">8.</span></span><br><span class="line">num[<span class="number">6</span>] = <span class="number">7.</span></span><br><span class="line">num[<span class="number">7</span>] = <span class="number">5.</span></span><br><span class="line">num[<span class="number">8</span>] = <span class="number">3.</span></span><br><span class="line">num[<span class="number">9</span>] = <span class="number">1.</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="2-排序结构体数组-1"><a href="#2-排序结构体数组-1" class="headerlink" title="2. 排序结构体数组"></a><strong>2. 排序结构体数组</strong></h4><blockquote>
<p>我们定义了一个结构体<code>StuInfo_t</code>，包含<code>id</code>和<code>score</code>两个成员，用于表示学生的相关信息。通过<code>qsort</code>函数，对结构体数组<code>stuInfo</code>进行降序排序，基于学生的分数。</p>
<p><strong>关键步骤：</strong></p>
<ol>
<li><p><strong>定义比较函数<code>StuCmpCb</code></strong>：</p>
<ul>
<li>接受两个<code>const void *</code>类型的指针，分别指向结构体数组中的两个元素。</li>
<li>将其转换为<code>StuInfo_t *</code>类型。</li>
<li>比较两个学生的分数，返回<code>-1</code>（如果第一个学生的分数高于第二个学生）、<code>1</code>（如果第一个学生的分数低于第二个学生）或<code>0</code>（相等）。</li>
<li>该实现实现了<strong>基于分数的降序排序</strong>。</li>
</ul>
</li>
<li><p><strong>调用<code>qsort</code>函数</strong>：</p>
<ul>
<li><strong>第一个参数</strong>：结构体数组<code>stuInfo</code>的首地址。</li>
<li><strong>第二个参数</strong>：结构体数组元素的个数（5）。</li>
<li><strong>第三个参数</strong>：结构体数组元素所占用的内存空间大小（<code>sizeof(stuInfo[0])</code>）。</li>
<li><strong>第四个参数</strong>：比较函数的指针（<code>StuCmpCb</code>）。</li>
</ul>
</li>
<li><p><strong>打印排序后的结构体数组</strong>：</p>
<ul>
<li>使用<code>for</code>循环遍历结构体数组，并通过<code>printf</code>函数打印每个学生的<code>id</code>和<code>score</code>。</li>
</ul>
</li>
</ol>
<p><strong>输出结果示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">student id = <span class="number">1</span>, score = <span class="number">90.</span></span><br><span class="line">student id = <span class="number">3</span>, score = <span class="number">80.</span></span><br><span class="line">student id = <span class="number">4</span>, score = <span class="number">75.</span></span><br><span class="line">student id = <span class="number">5</span>, score = <span class="number">70.</span></span><br><span class="line">student id = <span class="number">2</span>, score = <span class="number">65.</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="6-二分查找"><a href="#6-二分查找" class="headerlink" title="6.二分查找"></a>6.二分查找</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1.概述"></a><strong>1.概述</strong></h3><p><strong>二分查找法</strong>，也称为<strong>折半查找法</strong>，是一种在有序数组中查找某个目标值是否存在的算法。其主要优势在于相较于<strong>顺序查找</strong>（线性查找），二分查找法能够显著降低查找的时间复杂度。</p>
<p><strong>时间复杂度:</strong></p>
<ul>
<li><strong>顺序查找</strong>的时间复杂度为O(n)，其中n是数组的元素个数。</li>
<li><strong>二分查找法</strong>的时间复杂度为O(log₂n)，大大提高了查找效率。</li>
</ul>
<p><strong>示例</strong>：</p>
<p>假设数组中有8个元素：</p>
<ul>
<li>顺序查找最多需要8次比较。</li>
<li>二分查找只需要3次比较（因为2³ = 8）。</li>
</ul>
<h4 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2. 应用场景"></a><strong>2. 应用场景</strong></h4><ul>
<li>适用于<strong>有序数组</strong>。</li>
<li>需要快速查找元素的场景，如查找温度传感器的校准值、配置表等。</li>
</ul>
<h3 id="2-基本原理"><a href="#2-基本原理" class="headerlink" title="2.基本原理"></a><strong>2.基本原理</strong></h3><p>二分查找法通过不断将查找范围分成两半，逐步缩小查找区间，直至找到目标值或确定目标值不存在。</p>
<p><strong>步骤</strong>：</p>
<ol>
<li><strong>初始化</strong>：<ul>
<li><strong>左下标（left）</strong>：指向数组的起始位置，通常为0。</li>
<li><strong>右下标（right）</strong>：指向数组的末尾位置，通常为数组长度减1。</li>
</ul>
</li>
<li><strong>循环查找</strong>：<ul>
<li><strong>计算中间下标（middle）</strong></li>
<li><strong>比较目标值与中间元素</strong></li>
</ul>
</li>
<li><strong>终止条件</strong>：<ul>
<li>当左下标超过右下标时，查找结束，目标值不存在于数组中。</li>
</ul>
</li>
</ol>
<h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a><strong>实现细节</strong></h3><blockquote>
<p>在实现二分查找法时，需要注意以下几个关键点：</p>
<ol>
<li><p><strong>防止溢出</strong>：</p>
<ul>
<li>在计算中间下标时，使用 <code>mid = left + (right - left) / 2</code> 而不是 <code>mid = left + right  / 2</code>，以避免当 <code>left</code>和 <code>right</code> 都很大时发生整型溢出。</li>
</ul>
</li>
<li><p><strong>变量类型</strong>：</p>
<ul>
<li><code>left</code>、<code>right</code> 和 <code>middle</code> 应定义为<strong>有符号整型</strong>，如 <code>int</code> 或 <code>int32_t</code>，以处理可能出现的负值。</li>
</ul>
</li>
<li><p><strong>升序与降序</strong>：</p>
<ul>
<li>根据数组的排序顺序（升序或降序），调整比较逻辑以确保正确缩小查找范围。</li>
</ul>
</li>
<li><p><strong>查找接近目标值的元素</strong>：</p>
<ul>
<li>除了查找目标值是否存在，二分查找法还可用于查找最接近目标值的元素下标。</li>
</ul>
</li>
</ol>
</blockquote>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h3><p>以下是二分查找法在C语言中的实现，包括<strong>升序查找</strong>和<strong>降序查找</strong>，以及查找最接近目标值的函数。</p>
<h4 id="1-升序二分查找"><a href="#1-升序二分查找" class="headerlink" title="1. 升序二分查找"></a><strong>1. 升序二分查找</strong></h4><p><strong>函数说明</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 升序数组的二分查找函数</span></span><br><span class="line"><span class="comment"> * @param arr 有序数组的首地址</span></span><br><span class="line"><span class="comment"> * @param size 数组的大小</span></span><br><span class="line"><span class="comment"> * @param key 目标值</span></span><br><span class="line"><span class="comment"> * @return 目标值的下标，若未找到返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">AscBinarySearch</span><span class="params">(<span class="type">int32_t</span> *arr, <span class="type">int32_t</span> size, <span class="type">int32_t</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int32_t</span> left = <span class="number">0</span>;               <span class="comment">// 左下标</span></span><br><span class="line">    <span class="type">int32_t</span> right = size - <span class="number">1</span>;       <span class="comment">// 右下标</span></span><br><span class="line">    <span class="type">int32_t</span> mid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;         <span class="comment">// 循环条件</span></span><br><span class="line">        mid = left + (right - left) / <span class="number">2</span>;   <span class="comment">// 计算中间下标</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (key &lt; arr[mid]) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;        <span class="comment">// 目标值在左半部分</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; arr[mid]) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;         <span class="comment">// 目标值在右半部分</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;             <span class="comment">// 找到目标值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;                        <span class="comment">// 未找到目标值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-降序二分查找"><a href="#2-降序二分查找" class="headerlink" title="2. 降序二分查找"></a><strong>2. 降序二分查找</strong></h4><p><strong>函数说明</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 降序数组的二分查找函数</span></span><br><span class="line"><span class="comment"> * @param arr 有序数组的首地址</span></span><br><span class="line"><span class="comment"> * @param size 数组的大小</span></span><br><span class="line"><span class="comment"> * @param key 目标值</span></span><br><span class="line"><span class="comment"> * @return 目标值的下标，若未找到返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">DescBinarySearch</span><span class="params">(<span class="type">int32_t</span> *arr, <span class="type">int32_t</span> size, <span class="type">int32_t</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int32_t</span> left = <span class="number">0</span>;               <span class="comment">// 左下标</span></span><br><span class="line">    <span class="type">int32_t</span> right = size - <span class="number">1</span>;       <span class="comment">// 右下标</span></span><br><span class="line">    <span class="type">int32_t</span> mid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;         <span class="comment">// 循环条件</span></span><br><span class="line">        mid = left + (right - left) / <span class="number">2</span>;   <span class="comment">// 计算中间下标</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (key &gt; arr[mid]) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;        <span class="comment">// 目标值在左半部分</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; arr[mid]) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;         <span class="comment">// 目标值在右半部分</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;             <span class="comment">// 找到目标值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;                        <span class="comment">// 未找到目标值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-升序查找最接近目标值的元素下标"><a href="#3-升序查找最接近目标值的元素下标" class="headerlink" title="3. 升序查找最接近目标值的元素下标"></a><strong>3. 升序查找最接近目标值的元素下标</strong></h4><p><strong>函数说明</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 升序数组中查找最接近目标值的元素下标</span></span><br><span class="line"><span class="comment"> * @param arr 有序数组的首地址</span></span><br><span class="line"><span class="comment"> * @param size 数组的大小</span></span><br><span class="line"><span class="comment"> * @param key 目标值</span></span><br><span class="line"><span class="comment"> * @return 最接近目标值的元素下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">AscNear</span><span class="params">(<span class="type">int32_t</span> *arr, <span class="type">int32_t</span> size, <span class="type">int32_t</span> key)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int32_t</span> left = <span class="number">0</span>;               <span class="comment">// 左下标</span></span><br><span class="line">    <span class="type">int32_t</span> right = size - <span class="number">1</span>;       <span class="comment">// 右下标</span></span><br><span class="line">    <span class="type">int32_t</span> mid;</span><br><span class="line">    <span class="type">int32_t</span> index = size - <span class="number">1</span>;       <span class="comment">// 初始假设为最后一个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;          <span class="comment">// 循环条件</span></span><br><span class="line">        mid = left + (right - left) / <span class="number">2</span>;   <span class="comment">// 计算中间下标</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (key &lt;= arr[mid]) &#123;</span><br><span class="line">            index = mid;             <span class="comment">// 记录当前中间下标</span></span><br><span class="line">            right = mid - <span class="number">1</span>;         <span class="comment">// 目标值在左半部分</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;          <span class="comment">// 目标值在右半部分</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;                     <span class="comment">// 返回最接近目标值的元素下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-降序查找最接近目标值的元素下标"><a href="#4-降序查找最接近目标值的元素下标" class="headerlink" title="4. 降序查找最接近目标值的元素下标"></a><strong>4. 降序查找最接近目标值的元素下标</strong></h4><p><strong>函数说明</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 降序数组中查找最接近目标值的元素下标</span></span><br><span class="line"><span class="comment"> * @param arr 有序数组的首地址</span></span><br><span class="line"><span class="comment"> * @param size 数组的大小</span></span><br><span class="line"><span class="comment"> * @param key 目标值</span></span><br><span class="line"><span class="comment"> * @return 最接近目标值的元素下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int32_t</span> <span class="title function_">DescNear</span><span class="params">(<span class="type">int32_t</span> *arr, <span class="type">int32_t</span> size, <span class="type">int32_t</span> key)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int32_t</span> left = <span class="number">0</span>;               <span class="comment">// 左下标</span></span><br><span class="line">    <span class="type">int32_t</span> right = size - <span class="number">1</span>;       <span class="comment">// 右下标</span></span><br><span class="line">    <span class="type">int32_t</span> mid;</span><br><span class="line">    <span class="type">int32_t</span> index = size - <span class="number">1</span>;       <span class="comment">// 初始假设为最后一个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;          <span class="comment">// 循环条件</span></span><br><span class="line">        mid = left + (right - left) / <span class="number">2</span>;   <span class="comment">// 计算中间下标</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (key &gt;= arr[mid]) &#123;</span><br><span class="line">            index = mid;             <span class="comment">// 记录当前中间下标</span></span><br><span class="line">            right = mid - <span class="number">1</span>;         <span class="comment">// 目标值在左半部分</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;          <span class="comment">// 目标值在右半部分</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;                     <span class="comment">// 返回最接近目标值的元素下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-传感器框架"><a href="#7-传感器框架" class="headerlink" title="7.传感器框架"></a>7.传感器框架</h2><h3 id="1-分层架构概述"><a href="#1-分层架构概述" class="headerlink" title="1. 分层架构概述"></a><strong>1. 分层架构概述</strong></h3><p>在本节课中，我们将实现一个<strong>两层分层的应用层和驱动层</strong>的软件架构。这种架构的主要优势在于：</p>
<ul>
<li><strong>代码可复用</strong>：不同传感器的驱动可以在不修改应用层代码的情况下进行替换。</li>
<li><strong>代码可移植</strong>：通过统一的接口设计，软件架构可以适应不同的硬件平台。</li>
</ul>
<h3 id="2-驱动层的设计"><a href="#2-驱动层的设计" class="headerlink" title="2. 驱动层的设计"></a><strong>2. 驱动层的设计</strong></h3><p>在驱动层，我们实现一个<strong>统一的传感器框架</strong>。具体步骤如下：</p>
<ul>
<li><strong>驱动文件</strong>：创建一个驱动文件<code>driver.c</code>，由驱动层对外提供接口，供应用层调用。</li>
<li><strong>暴露函数</strong>：驱动层暴露获取传感器数据的函数，供外部应用层使用。</li>
</ul>
<h3 id="3-数据结构设计"><a href="#3-数据结构设计" class="headerlink" title="3. 数据结构设计"></a><strong>3. 数据结构设计</strong></h3><p>我们设计一个结构体来存储传感器的数据，结构体成员包括各类传感器的数据，如湿度、温度等。为了未来的扩展，还可以添加PM2.5、甲醛等传感器的数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _SENSOR_DRV_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _SENSOR_DRV_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">float</span> temp;   <span class="comment">// 温度，单位：摄氏度</span></span><br><span class="line">    <span class="type">uint8_t</span> humi; <span class="comment">// 湿度，单位：%</span></span><br><span class="line">&#125; SensorData_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief 传感器驱动初始化</span></span><br><span class="line"><span class="comment">* @param</span></span><br><span class="line"><span class="comment">* @return </span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SensorDrvInit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief 获取传感器数据</span></span><br><span class="line"><span class="comment">* @param sensorData, 输出，传感器数据回写地址</span></span><br><span class="line"><span class="comment">* @return </span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GetSensorData</span><span class="params">(SensorData_t *sensorData)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief 触发驱动转换传感器数据</span></span><br><span class="line"><span class="comment">* @param</span></span><br><span class="line"><span class="comment">* @return </span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SensorDrvProc</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="4-驱动层实现"><a href="#4-驱动层实现" class="headerlink" title="4. 驱动层实现"></a><strong>4. 驱动层实现</strong></h3><p>在驱动层的源文件<code>sensor_drv.c</code>中，实现传感器驱动的初始化、数据转换和数据获取功能。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f30x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sensor_drv.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief 传感器驱动初始化</span></span><br><span class="line"><span class="comment">* @param</span></span><br><span class="line"><span class="comment">* @return </span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SensorDrvInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化相关硬件，如GPIO、ADC等</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief 触发驱动转换传感器数据</span></span><br><span class="line"><span class="comment">* @param</span></span><br><span class="line"><span class="comment">* @return </span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SensorDrvProc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 触发ADC转换，读取传感器数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief 获取传感器数据</span></span><br><span class="line"><span class="comment">* @param sensorData, 输出，传感器数据回写地址</span></span><br><span class="line"><span class="comment">* @return </span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GetSensorData</span><span class="params">(SensorData_t *sensorData)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从ADC读取数据并转换为温度和湿度</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief 传感器任务处理函数</span></span><br><span class="line"><span class="comment">* @param </span></span><br><span class="line"><span class="comment">* @return </span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SensorTask</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    SensorDrvProc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-应用层的设计与实现"><a href="#5-应用层的设计与实现" class="headerlink" title="5. 应用层的设计与实现"></a><strong>5. 应用层的设计与实现</strong></h3><p>在应用层，我们实现一个<code>app.c</code>文件，负责任务调度和传感器数据的获取与处理。</p>
<h4 id="5-1-任务调度结构体"><a href="#5-1-任务调度结构体" class="headerlink" title="5.1 任务调度结构体"></a><strong>5.1 任务调度结构体</strong></h4><p>首先，定义一个任务调度结构体，用于管理任务的执行状态和时间片。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 任务调度结构体 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> run;                <span class="comment">// 调度标志，1：调度，0：挂起</span></span><br><span class="line">    <span class="type">uint16_t</span> timCount;          <span class="comment">// 时间片计数值</span></span><br><span class="line">    <span class="type">uint16_t</span> timRload;          <span class="comment">// 时间片重载值</span></span><br><span class="line">    <span class="type">void</span> (*pTaskFuncCb)(<span class="type">void</span>);  <span class="comment">// 函数指针变量，用来保存业务功能模块函数地址</span></span><br><span class="line">&#125; TaskComps_t;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> TaskComps_t g_taskComps[] = </span><br><span class="line">&#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1000</span>, <span class="number">1000</span>,  HmiTask&#125;,</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1000</span>, <span class="number">1000</span>,  SensorTask&#125;</span><br><span class="line">    <span class="comment">/* 添加业务功能模块 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_NUM_MAX   (sizeof(g_taskComps) / sizeof(g_taskComps[0]))</span></span><br></pre></td></tr></table></figure>
<h4 id="5-2-任务处理与调度函数"><a href="#5-2-任务处理与调度函数" class="headerlink" title="5.2 任务处理与调度函数"></a><strong>5.2 任务处理与调度函数</strong></h4><p>实现任务处理函数<code>TaskHandler</code>和任务调度回调函数<code>TaskScheduleCb</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 任务处理函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">TaskHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint8_t</span> i = <span class="number">0</span>; i &lt; TASK_NUM_MAX; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (g_taskComps[i].run)                  <span class="comment">// 判断时间片标志</span></span><br><span class="line">        &#123;</span><br><span class="line">            g_taskComps[i].run = <span class="number">0</span>;              <span class="comment">// 标志清零</span></span><br><span class="line">            g_taskComps[i].pTaskFuncCb();        <span class="comment">// 执行调度业务功能模块</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief 在定时器中断服务函数中被间接调用，设置时间片标记，</span></span><br><span class="line"><span class="comment">         需要定时器1ms产生1次中断</span></span><br><span class="line"><span class="comment">* @param</span></span><br><span class="line"><span class="comment">* @return </span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">TaskScheduleCb</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint8_t</span> i = <span class="number">0</span>; i &lt; TASK_NUM_MAX; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (g_taskComps[i].timCount)</span><br><span class="line">        &#123;</span><br><span class="line">            g_taskComps[i].timCount--;</span><br><span class="line">            <span class="keyword">if</span> (g_taskComps[i].timCount == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                g_taskComps[i].run = <span class="number">1</span>;</span><br><span class="line">                g_taskComps[i].timCount = g_taskComps[i].timRload;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-热敏电阻"><a href="#8-热敏电阻" class="headerlink" title="8.热敏电阻"></a><strong>8.热敏电阻</strong></h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a><strong>1. 简介</strong></h3><blockquote>
<p><strong>热敏电阻（Thermistor）</strong>是一种电阻值随温度变化而显著变化的电阻器件，主要分为：</p>
<ul>
<li><strong>负温度系数（NTC）</strong>：温度升高，阻值减小。</li>
<li><strong>正温度系数（PTC）</strong>：温度升高，阻值增大。</li>
</ul>
<p>我们使用的是<strong>负温度系数（NTC）</strong>热敏电阻，其阻值随温度升高而减小，反之亦然。</p>
</blockquote>
<h4 id="1-工作原理-2"><a href="#1-工作原理-2" class="headerlink" title="1. 工作原理"></a><strong>1. 工作原理</strong></h4><blockquote>
<h4 id="2-1-电路设计"><a href="#2-1-电路设计" class="headerlink" title="2.1 电路设计"></a><strong>2.1 电路设计</strong></h4><ul>
<li><strong>分压电路</strong>：热敏电阻与一个限流电阻（通常为1kΩ）串联，形成分压电路。</li>
<li><strong>ADC采集</strong>：通过ADC采集热敏电阻两端的电压值，转换为数字信号。</li>
</ul>
<h4 id="2-2-温度与阻值关系"><a href="#2-2-温度与阻值关系" class="headerlink" title="2.2 温度与阻值关系"></a><strong>2.2 温度与阻值关系</strong></h4><ul>
<li><strong>25摄氏度时</strong>：NTC热敏电阻的阻值为10kΩ。</li>
<li><strong>阻值变化</strong>：温度升高，阻值下降；温度降低，阻值上升。</li>
<li><strong>测量范围</strong>：-55°C到100°C，分辨率为1°C，精度为±1%。</li>
</ul>
</blockquote>
<h4 id="2-电压转换"><a href="#2-电压转换" class="headerlink" title="2. 电压转换"></a><strong>2. 电压转换</strong></h4><blockquote>
<h4 id="3-1-分压公式"><a href="#3-1-分压公式" class="headerlink" title="3.1 分压公式"></a><strong>3.1 分压公式</strong></h4><script type="math/tex; mode=display">
V_{\text{adc}} = V_{\text{cc}} \times \frac{R_{\text{therm}}}{R_{\text{fixed}} + R_{\text{therm}}}</script><p>其中：</p>
<ul>
<li><code>R_therm</code>是热敏电阻的阻值。</li>
<li><code>R_fixed</code>是固定限流电阻。</li>
</ul>
<h4 id="3-2-示例计算"><a href="#3-2-示例计算" class="headerlink" title="3.2 示例计算"></a><strong>3.2 示例计算</strong></h4><ul>
<li><p><strong>25°C时</strong>：</p>
<script type="math/tex; mode=display">
R_{\text{therm}} = 10kΩ</script><script type="math/tex; mode=display">
V_{\text{adc}} = 3.3V \times \frac{10k}{10k + 10k} = 1.65V</script></li>
</ul>
<ul>
<li><p><strong>温度升高至较高温度（例如5kΩ）</strong>：</p>
<script type="math/tex; mode=display">
R_{\text{therm}} = 5kΩ</script><script type="math/tex; mode=display">
V_{\text{adc}} = 3.3V \times \frac{5k}{10k + 5k} = 1.1V</script></li>
</ul>
</blockquote>
<h4 id="3-温度计算"><a href="#3-温度计算" class="headerlink" title="3. 温度计算"></a><strong>3. 温度计算</strong></h4><blockquote>
<h4 id="4-1-直接映射"><a href="#4-1-直接映射" class="headerlink" title="4.1 直接映射"></a><strong>4.1 直接映射</strong></h4><ul>
<li><strong>阻值与温度表</strong>：通过预先测量不同温度下的阻值，建立阻值与温度的对应关系表。</li>
<li><strong>代码实现</strong>：在代码中直接将ADC读取的数值映射到相应的温度值，避免实时计算，节省CPU资源。</li>
</ul>
<h4 id="4-2-精度提升"><a href="#4-2-精度提升" class="headerlink" title="4.2 精度提升"></a><strong>4.2 精度提升</strong></h4><ul>
<li><p><strong>线性插值</strong>：为了实现更高的温度精度（如0.1°C），在相邻温度区间内进行线性插值计算。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190041723.png" alt="image-20241201203039214"></p>
<p>已知：</p>
<ul>
<li>28°C 对应 ADC 值 1913</li>
<li>29°C 对应 ADC 值 1869</li>
</ul>
<p>目标 ADC 值为 1889（写代码会用到此公式）：</p>
<script type="math/tex; mode=display">
\text{温度} = 28 + \frac{(1889 - 1869)}{(1913 - 1869)} \times 1 \approx 28.45°C</script></li>
</ul>
</blockquote>
<h3 id="2-代码实现-4"><a href="#2-代码实现-4" class="headerlink" title="2. 代码实现"></a>2. 代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f30x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NTC 热敏电阻 ADC 值查找表</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint16_t</span> g_ntcAdcTable[] = </span><br><span class="line">&#123;</span><br><span class="line">	<span class="number">3123</span>, <span class="number">3089</span>, <span class="number">3051</span>, <span class="number">3013</span>, <span class="number">2973</span>, <span class="number">2933</span>, <span class="number">2893</span>, <span class="number">2852</span>, <span class="number">2810</span>, <span class="number">2767</span>,     <span class="comment">//0   ~   9℃</span></span><br><span class="line">	<span class="number">2720</span>, <span class="number">2681</span>, <span class="number">2637</span>, <span class="number">2593</span>, <span class="number">2548</span>, <span class="number">2503</span>, <span class="number">2458</span>, <span class="number">2412</span>, <span class="number">2367</span>, <span class="number">2321</span>,     <span class="comment">//10  ~  19℃</span></span><br><span class="line">	<span class="number">2275</span>, <span class="number">2230</span>, <span class="number">2184</span>, <span class="number">2138</span>, <span class="number">2093</span>, <span class="number">2048</span>, <span class="number">2002</span>, <span class="number">1958</span>, <span class="number">1913</span>, <span class="number">1869</span>,     <span class="comment">//20  ~  29℃</span></span><br><span class="line">	<span class="number">1825</span>, <span class="number">1782</span>, <span class="number">1739</span>, <span class="number">1697</span>, <span class="number">1655</span>, <span class="number">1614</span>, <span class="number">1573</span>, <span class="number">1533</span>, <span class="number">1494</span>, <span class="number">1455</span>,     <span class="comment">//30  ~  39℃</span></span><br><span class="line">	<span class="number">1417</span>, <span class="number">1380</span>, <span class="number">1343</span>, <span class="number">1307</span>, <span class="number">1272</span>, <span class="number">1237</span>, <span class="number">1203</span>, <span class="number">1170</span>, <span class="number">1138</span>, <span class="number">1106</span>,     <span class="comment">//40  ~  49℃</span></span><br><span class="line">	<span class="number">1081</span>, <span class="number">1045</span>, <span class="number">1016</span>, <span class="number">987</span>,  <span class="number">959</span>,  <span class="number">932</span>,  <span class="number">905</span>,  <span class="number">879</span>,  <span class="number">854</span>,  <span class="number">829</span>,      <span class="comment">//50  ~  59℃</span></span><br><span class="line">	<span class="number">806</span>,  <span class="number">782</span>,  <span class="number">760</span>,  <span class="number">738</span>,  <span class="number">716</span>,  <span class="number">696</span>,  <span class="number">675</span>,  <span class="number">656</span>,  <span class="number">637</span>,  <span class="number">618</span>,      <span class="comment">//60  ~  69℃</span></span><br><span class="line">	<span class="number">600</span>,  <span class="number">583</span>,  <span class="number">566</span>,  <span class="number">550</span>,  <span class="number">534</span>,  <span class="number">518</span>,  <span class="number">503</span>,  <span class="number">489</span>,  <span class="number">475</span>,  <span class="number">461</span>,      <span class="comment">//70  ~  79℃</span></span><br><span class="line">	<span class="number">448</span>,  <span class="number">435</span>,  <span class="number">422</span>,  <span class="number">410</span>,  <span class="number">398</span>,  <span class="number">387</span>,  <span class="number">376</span>,  <span class="number">365</span>,  <span class="number">355</span>,  <span class="number">345</span>,      <span class="comment">//80  ~  89℃</span></span><br><span class="line">	<span class="number">335</span>,  <span class="number">326</span>,  <span class="number">316</span>,  <span class="number">308</span>,  <span class="number">299</span>,  <span class="number">290</span>,  <span class="number">283</span>,  <span class="number">274</span>,  <span class="number">267</span>,  <span class="number">259</span>,      <span class="comment">//90  ~  99℃</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NTC_TABLE_SIZE         (sizeof(g_ntcAdcTable) / sizeof(g_ntcAdcTable[0]))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INDEX_TO_TEMP(index)   ((int32_t)index)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFF_NUM_SIZE 11</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint16_t</span> g_temp10MplBuf[BUFF_NUM_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">float</span> g_tempData;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">GPIOInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	rcu_periph_clock_enable(RCU_GPIOC);</span><br><span class="line">	gpio_init(GPIOC, GPIO_MODE_AIN, GPIO_OSPEED_10MHZ, GPIO_PIN_3);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ADCInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 使能时钟；*/</span></span><br><span class="line">	rcu_periph_clock_enable(RCU_ADC0);</span><br><span class="line">	<span class="comment">/* 设置分频系数；*/</span></span><br><span class="line">	rcu_adc_clock_config(RCU_CKADC_CKAPB2_DIV6);  <span class="comment">// 6分频，120MHz / 6 = 20MHz</span></span><br><span class="line">	<span class="comment">/* 设置独立模式；*/</span></span><br><span class="line">	adc_mode_config(ADC_MODE_FREE);</span><br><span class="line">	<span class="comment">/* 设置连续模式；*/</span> </span><br><span class="line">	adc_special_function_config(ADC0, ADC_CONTINUOUS_MODE, ENABLE);</span><br><span class="line">	<span class="comment">/* 设置数据对齐；*/</span></span><br><span class="line">	adc_data_alignment_config(ADC0, ADC_DATAALIGN_RIGHT);</span><br><span class="line">	<span class="comment">/* 设置转换通道个数；*/</span> </span><br><span class="line">	adc_channel_length_config(ADC0, ADC_REGULAR_CHANNEL, <span class="number">1</span>);</span><br><span class="line">	<span class="comment">/* 设置转换哪一个通道以及所处序列位置；*/</span> </span><br><span class="line">	adc_regular_channel_config(ADC0, <span class="number">0</span>, ADC_CHANNEL_13, ADC_SAMPLETIME_239POINT5);  <span class="comment">// PC3对应通道13，放在序列寄存器的0序列中，239.5个周期</span></span><br><span class="line">	<span class="comment">/* 设置选择哪一个外部触发源；*/</span> </span><br><span class="line">	adc_external_trigger_source_config(ADC0, ADC_REGULAR_CHANNEL, ADC0_1_2_EXTTRIG_REGULAR_NONE);</span><br><span class="line">	<span class="comment">/* 使能外部触发；*/</span> </span><br><span class="line">	adc_external_trigger_config(ADC0, ADC_REGULAR_CHANNEL, ENABLE);</span><br><span class="line">	<span class="comment">/* 使能硬件滤波；*/</span> </span><br><span class="line">	adc_oversample_mode_config(ADC0, ADC_OVERSAMPLING_ALL_CONVERT, ADC_OVERSAMPLING_SHIFT_4B, ADC_OVERSAMPLING_RATIO_MUL16);</span><br><span class="line">	adc_oversample_mode_enable(ADC0);</span><br><span class="line">	<span class="comment">/* 使能ADC；*/</span> </span><br><span class="line">	adc_enable(ADC0);</span><br><span class="line">	<span class="comment">/* 内部校准；*/</span> </span><br><span class="line">	DelayNus(<span class="number">50</span>);</span><br><span class="line">	adc_calibration_enable(ADC0);</span><br><span class="line">	adc_software_trigger_enable(ADC0, ADC_REGULAR_CHANNEL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief 算术平均滤波</span></span><br><span class="line"><span class="comment">* @param arr，数组首地址</span></span><br><span class="line"><span class="comment">* @param len，元素个数</span></span><br><span class="line"><span class="comment">* @return 平均运算结果</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint16_t</span> <span class="title function_">ArithAvgFltr</span><span class="params">(<span class="type">uint16_t</span> *arr, <span class="type">uint32_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint32_t</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sum += arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">uint16_t</span>)(sum / len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">DescBinarySearch</span><span class="params">(<span class="type">const</span> <span class="type">uint16_t</span> *arr, <span class="type">int32_t</span> size, <span class="type">uint16_t</span> key)</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int32_t</span> left = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int32_t</span> right = size - <span class="number">1</span>;</span><br><span class="line">	<span class="type">int32_t</span> mid = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int32_t</span> index = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">	&#123;</span><br><span class="line">		mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(key &gt;= arr[mid])</span><br><span class="line">		&#123;</span><br><span class="line">			right = mid - <span class="number">1</span>;</span><br><span class="line">			index = mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			left = mid + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief qsort函数调用的回调函数，比较规则，降序排列</span></span><br><span class="line"><span class="comment">* @param *_a，对应数组元素</span></span><br><span class="line"><span class="comment">* @param *_b，对应数组元素</span></span><br><span class="line"><span class="comment">* @return 比较结果</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">CmpCb</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *_a, <span class="type">const</span> <span class="type">void</span> *_b)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint16_t</span>* a = (<span class="type">uint16_t</span>*)_a;</span><br><span class="line">	<span class="type">uint16_t</span>* b = (<span class="type">uint16_t</span>*)_b;</span><br><span class="line">	<span class="type">int8_t</span> val = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(*a &lt; *b)</span><br><span class="line">	&#123;</span><br><span class="line">		val = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(*a &gt; *b)</span><br><span class="line">	&#123;</span><br><span class="line">		val = <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		val = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief 中位值平均滤波</span></span><br><span class="line"><span class="comment">* @param arr，数组首地址</span></span><br><span class="line"><span class="comment">* @param len，元素个数，需要大于等于3个</span></span><br><span class="line"><span class="comment">* @return 平均运算结果</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint16_t</span> <span class="title function_">MedianAvgFltr</span><span class="params">(<span class="type">uint16_t</span> *arr, <span class="type">uint32_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">	qsort(arr, len, <span class="keyword">sizeof</span>(<span class="type">uint16_t</span>), CmpCb);</span><br><span class="line">	<span class="keyword">return</span> ArithAvgFltr(&amp;arr[<span class="number">1</span>], len - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">Get_ADCVal</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (!adc_flag_get(ADC0, ADC_FLAG_EOC));</span><br><span class="line">	<span class="keyword">return</span> adc_regular_data_read(ADC0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint16_t</span> <span class="title function_">ADCtoTemp10Mpl</span><span class="params">(<span class="type">uint16_t</span> ADCVal)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 二分查找 找温度（下标）</span></span><br><span class="line">	<span class="type">int32_t</span> index = DescBinarySearch(g_ntcAdcTable, NTC_TABLE_SIZE, ADCVal);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(index == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 表示温度为0</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 计算 </span></span><br><span class="line">	<span class="type">uint16_t</span> Temp10Mpl = INDEX_TO_TEMP(index - <span class="number">1</span>) * <span class="number">10</span> + (g_ntcAdcTable[index - <span class="number">1</span>] - ADCVal) / (g_ntcAdcTable[index - <span class="number">1</span>] - g_ntcAdcTable[index]);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> Temp10Mpl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PushDataToBuf</span><span class="params">(<span class="type">uint16_t</span> temp10Mpl)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">uint16_t</span> s_index = <span class="number">0</span>;</span><br><span class="line">	g_temp10MplBuf[s_index++] = temp10Mpl; </span><br><span class="line">	s_index %= BUFF_NUM_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief NTC驱动初始化</span></span><br><span class="line"><span class="comment">* @param</span></span><br><span class="line"><span class="comment">* @return </span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Temp_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIOInit();</span><br><span class="line">	ADCInit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief 触发驱动转换温度传感器数据</span></span><br><span class="line"><span class="comment">* @param</span></span><br><span class="line"><span class="comment">* @return </span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Temp_SensorProc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">uint16_t</span> s_convertNum = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 获得ADC采集数据	</span></span><br><span class="line">	<span class="type">uint16_t</span> ADCVal = Get_ADCVal();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 将ADC采集数据转换为十倍温度值</span></span><br><span class="line">	<span class="type">uint16_t</span> temp10Mpl = ADCtoTemp10Mpl(ADCVal);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 将十倍温度值放入Buffer中</span></span><br><span class="line">	PushDataToBuf(temp10Mpl);</span><br><span class="line">	</span><br><span class="line">	s_convertNum++;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 采集小于3次直接用第一次采集数据代替</span></span><br><span class="line">	<span class="keyword">if</span>(s_convertNum &lt; <span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		g_tempData = g_temp10MplBuf[<span class="number">0</span>] / <span class="number">10.0f</span>;</span><br><span class="line">		<span class="comment">//return ;// 少加return 直接触发</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(s_convertNum &gt; BUFF_NUM_SIZE)</span><br><span class="line">	&#123;</span><br><span class="line">		s_convertNum = BUFF_NUM_SIZE;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 快速排序 + 中值滤波 </span></span><br><span class="line">	g_tempData = MedianAvgFltr(g_temp10MplBuf, s_convertNum) / <span class="number">10.0f</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief 获取温度传感器数据</span></span><br><span class="line"><span class="comment">* @param</span></span><br><span class="line"><span class="comment">* @return 温度数据，小数</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">Get_TempData</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> g_tempData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-湿敏电阻"><a href="#9-湿敏电阻" class="headerlink" title="9.湿敏电阻"></a>9.湿敏电阻</h2><h3 id="1-简介-1"><a href="#1-简介-1" class="headerlink" title="1. 简介"></a><strong>1. 简介</strong></h3><p><strong>湿敏电阻（Humidity Sensitive Resistor）</strong>是一种对湿度变化敏感的电阻器件。由于材料特性的原因，为了防止极化和电解作用，湿敏电阻需要<strong>交流电源驱动</strong>。相比于热敏电阻，湿敏电阻的驱动电路更为复杂。</p>
<h4 id="1-相对湿度与绝对湿度"><a href="#1-相对湿度与绝对湿度" class="headerlink" title="1. 相对湿度与绝对湿度"></a><strong>1. 相对湿度与绝对湿度</strong></h4><p>在日常生活中，当我们说“湿度是50”，其实指的是<strong>相对湿度</strong>。相对湿度是指在某一特定温度下，空气中实际含有的水蒸气密度与该温度下水蒸气的饱和密度之比，通常以百分比表示。因此，“50”代表<strong>50%</strong>。</p>
<p>相对湿度与绝对湿度的区别如下：</p>
<ul>
<li><strong>相对湿度</strong>：空气中水蒸气的实际密度与饱和密度之比，表示为百分比。</li>
<li><strong>绝对湿度</strong>：在一定温度和压力条件下，空气中水蒸气的最大容量，通常以克每立方米（g/m³）表示。</li>
</ul>
<h4 id="2-驱动电路设计"><a href="#2-驱动电路设计" class="headerlink" title="2. 驱动电路设计"></a><strong>2. 驱动电路设计</strong></h4><p>驱动电路简易框图如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202501190042276.png" alt="image-20241201210622103"></p>
<p>以下是湿敏电阻的驱动电路设计要点：</p>
<ul>
<li><strong>驱动引脚</strong>：使用三个引脚，其中<code>PB0</code>和<code>PB1</code>用于交流电源驱动。具体配置如下：<ul>
<li>当<code>PB0</code>为高电平时，<code>PB1</code>为低电平。</li>
<li>当<code>PB0</code>为低电平时，<code>PB1</code>为高电平。</li>
</ul>
</li>
<li><strong>ADC采集端口</strong>：<code>PC4</code>为ADC采集端口，用于读取湿敏电阻上的电压值。</li>
<li><strong>电阻配置</strong>：<ul>
<li>湿敏电阻串联一个470Ω的电阻。</li>
<li>并联一个1MΩ的电阻。</li>
<li>使用39kΩ的分压电阻。</li>
</ul>
</li>
<li><strong>驱动频率</strong>：<strong><code>厂商建议使用1kHz的交流驱动频率</code></strong>，即每个周期1毫秒，高电平500微秒，低电平500微秒。但在实际项目中，为了降低频率需求，我们选择<strong>250Hz</strong>，即每个周期4毫秒，高电平2毫秒，低电平2毫秒。这一频率足以满足数据采集需求，同时减少定时器中断的负担。</li>
</ul>
<h4 id="3-驱动电路工作原理"><a href="#3-驱动电路工作原理" class="headerlink" title="3. 驱动电路工作原理"></a><strong>3. 驱动电路工作原理</strong></h4><p>在驱动电路中，通过<code>PB0</code>和<code>PB1</code>的高低电平交替，产生交流信号驱动湿敏电阻。<code>PC4</code>端口通过ADC采集湿敏电阻两端的电压值，并将其转换为数字信号用于后续处理。</p>
<p>湿度数据的计算</p>
<blockquote>
<h4 id="1：根据温度获取对应湿度的ADC数值"><a href="#1：根据温度获取对应湿度的ADC数值" class="headerlink" title="1：根据温度获取对应湿度的ADC数值"></a><strong>1：根据温度获取对应湿度的ADC数值</strong></h4><p>假设我们获得的温度数据是18摄氏度，正好位于15°C和20°C之间。湿度的间隔为5%，同样，温度的间隔也是5°C。</p>
<p><strong>计算过程</strong>：</p>
<ol>
<li><p>确定温度行：</p>
<ul>
<li><p>温度数据18°C位于15°C和20°C之间。</p>
</li>
<li><p>温度行索引计算：</p>
<script type="math/tex; mode=display">
text{temp\_row} = \frac{18}{5} = 3.6 \approx 3</script><p>（向下取整，索引从0开始，表示15°C对应第3行）</p>
</li>
</ul>
</li>
<li><p>获取15°C和20°C下特定湿度的ADC数值：</p>
<ul>
<li>例如，20%湿度在15°C下对应的ADC数值为154，在20°C下为168。</li>
</ul>
</li>
<li><p><strong>线性插值计算18°C下20%湿度的ADC数值</strong>：</p>
<script type="math/tex; mode=display">
\text{ADC}_{18} = \text{ADC}_{15} + \left( \frac{18 - 15}{20 - 15} \right) \times (\text{ADC}_{20} - \text{ADC}_{15}) = 154 + \left( \frac{3}{5} \right) \times (168 - 154) = 154 + 10.8 = 164.8 \approx 165</script><p>这样，我们得到18°C下20%湿度对应的ADC数值约为165。</p>
</li>
</ol>
<h4 id="2：根据ADC数值计算湿度"><a href="#2：根据ADC数值计算湿度" class="headerlink" title="2：根据ADC数值计算湿度"></a><strong>2：根据ADC数值计算湿度</strong></h4><ol>
<li><p>二分查找法定位ADC数值：</p>
<ul>
<li>使用二分查找法在对应温度行的ADC数值数组中查找目标ADC值。</li>
<li>假设目标ADC值为170，位于15°C下20%湿度（ADC=154）和20°C下20%湿度（ADC=168）之间。</li>
</ul>
</li>
<li><p>线性插值计算湿度：</p>
<script type="math/tex; mode=display">
\text{湿度} = \text{湿度}_{\text{low}} + \left( \frac{\text{ADC}_{\text{low}} - \text{ADC}_{\text{current}}}{\text{ADC}_{\text{low}} - \text{ADC}_{\text{high}}} \right) \times (\text{湿度}_{\text{high}} - \text{湿度}_{\text{low}})</script></li>
</ol>
<p>   示例：</p>
<script type="math/tex; mode=display">
\text{ADC}_{\text{low}} = 168</script><p>   20°C下20%湿度</p>
<script type="math/tex; mode=display">
   \text{ADC}_{\text{high}} = 154</script><p>   15°C下20%湿度</p>
<script type="math/tex; mode=display">
   \text{ADC}_{\text{current}} = 170</script><script type="math/tex; mode=display">
   \text{湿度} = 20\% + \left( \frac{168 - 170}{168 - 154} \right) \times (25\% - 20\%) = 20\% + \left( \frac{-2}{14} \right) \times 5\% \approx 20\% - 0.714\% \approx 19.3\%</script></blockquote>
<h3 id="2-代码实现-5"><a href="#2-代码实现-5" class="headerlink" title="2.代码实现"></a>2.代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;gd32f30x.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;delay.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;led_drv.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint16_t</span> g_adcVal;	<span class="comment">// 全局变量，用于存储ADC转换的数值</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> g_humiData;	<span class="comment">// 全局变量，用于存储湿度值</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HUMI_LEVEL_NUM 18	<span class="comment">// 湿度等级数量</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不同温度下的湿度对应ADC值表</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">uint16_t</span> g_rhADCVal[][HUMI_LEVEL_NUM] = &#123;</span><br><span class="line"><span class="comment">//         10%RH  15%RH  20%RH  25%RH  30%RH  35%RH  40%RH  45%RH  50%RH  55%RH  60%RH  65%RH  70%RH  75%RH  80%RH  85%RH  90%RH  95%RH               </span></span><br><span class="line"><span class="comment">/* 0℃*/</span>  &#123;<span class="number">154</span>,   <span class="number">155</span>,   <span class="number">160</span>,   <span class="number">165</span>,   <span class="number">177</span>,   <span class="number">204</span>,   <span class="number">257</span>,   <span class="number">354</span>,   <span class="number">516</span>,   <span class="number">803</span>,   <span class="number">1189</span>,  <span class="number">1633</span>,  <span class="number">2101</span>,  <span class="number">2579</span>,  <span class="number">2919</span>,  <span class="number">3204</span>,  <span class="number">3434</span>,  <span class="number">3595</span>,&#125;,</span><br><span class="line"><span class="comment">/* 5℃*/</span>  &#123;<span class="number">154</span>,   <span class="number">155</span>,   <span class="number">161</span>,   <span class="number">168</span>,   <span class="number">186</span>,   <span class="number">223</span>,   <span class="number">296</span>,   <span class="number">429</span>,   <span class="number">650</span>,   <span class="number">985</span>,   <span class="number">1408</span>,  <span class="number">1874</span>,  <span class="number">2330</span>,  <span class="number">2796</span>,  <span class="number">3113</span>,  <span class="number">3356</span>,  <span class="number">3571</span>,  <span class="number">3702</span>,&#125;,</span><br><span class="line"><span class="comment">/*10℃*/</span>  &#123;<span class="number">154</span>,   <span class="number">156</span>,   <span class="number">164</span>,   <span class="number">175</span>,   <span class="number">199</span>,   <span class="number">250</span>,   <span class="number">342</span>,   <span class="number">508</span>,   <span class="number">775</span>,   <span class="number">1154</span>,  <span class="number">1633</span>,  <span class="number">2127</span>,  <span class="number">2540</span>,  <span class="number">2945</span>,  <span class="number">3236</span>,  <span class="number">3456</span>,  <span class="number">3619</span>,  <span class="number">3736</span>,&#125;,</span><br><span class="line"><span class="comment">/*15℃*/</span>  &#123;<span class="number">154</span>,   <span class="number">157</span>,   <span class="number">168</span>,   <span class="number">183</span>,   <span class="number">217</span>,   <span class="number">284</span>,   <span class="number">410</span>,   <span class="number">619</span>,   <span class="number">941</span>,   <span class="number">1367</span>,  <span class="number">1835</span>,  <span class="number">2330</span>,  <span class="number">2750</span>,  <span class="number">3113</span>,  <span class="number">3370</span>,  <span class="number">3555</span>,  <span class="number">3676</span>,  <span class="number">3780</span>,&#125;,</span><br><span class="line"><span class="comment">/*20℃*/</span>  &#123;<span class="number">155</span>,   <span class="number">158</span>,   <span class="number">176</span>,   <span class="number">197</span>,   <span class="number">237</span>,   <span class="number">320</span>,   <span class="number">477</span>,   <span class="number">750</span>,   <span class="number">1121</span>,  <span class="number">1604</span>,  <span class="number">2075</span>,  <span class="number">2540</span>,  <span class="number">2919</span>,  <span class="number">3236</span>,  <span class="number">3442</span>,  <span class="number">3611</span>,  <span class="number">3736</span>,  <span class="number">3825</span>,&#125;,</span><br><span class="line"><span class="comment">/*25℃*/</span>  &#123;<span class="number">155</span>,   <span class="number">160</span>,   <span class="number">183</span>,   <span class="number">210</span>,   <span class="number">264</span>,   <span class="number">375</span>,   <span class="number">579</span>,   <span class="number">901</span>,   <span class="number">1338</span>,  <span class="number">1855</span>,  <span class="number">2298</span>,  <span class="number">2727</span>,  <span class="number">3055</span>,  <span class="number">3342</span>,  <span class="number">3539</span>,  <span class="number">3676</span>,  <span class="number">3780</span>,  <span class="number">3853</span>,&#125;,</span><br><span class="line"><span class="comment">/*30℃*/</span>  &#123;<span class="number">155</span>,   <span class="number">161</span>,   <span class="number">191</span>,   <span class="number">230</span>,   <span class="number">301</span>,   <span class="number">451</span>,   <span class="number">696</span>,   <span class="number">1062</span>,  <span class="number">1537</span>,  <span class="number">2075</span>,  <span class="number">2502</span>,  <span class="number">2894</span>,  <span class="number">3204</span>,  <span class="number">3427</span>,  <span class="number">3595</span>,  <span class="number">3719</span>,  <span class="number">3807</span>,  <span class="number">3871</span>,&#125;,</span><br><span class="line"><span class="comment">/*35℃*/</span>  &#123;<span class="number">156</span>,   <span class="number">164</span>,   <span class="number">202</span>,   <span class="number">250</span>,   <span class="number">344</span>,   <span class="number">508</span>,   <span class="number">803</span>,   <span class="number">1226</span>,  <span class="number">1728</span>,  <span class="number">2238</span>,  <span class="number">2705</span>,  <span class="number">3055</span>,  <span class="number">3302</span>,  <span class="number">3501</span>,  <span class="number">3652</span>,  <span class="number">3754</span>,  <span class="number">3834</span>,  <span class="number">3899</span>,&#125;,</span><br><span class="line"><span class="comment">/*40℃*/</span>  &#123;<span class="number">156</span>,   <span class="number">166</span>,   <span class="number">214</span>,   <span class="number">284</span>,   <span class="number">397</span>,   <span class="number">619</span>,   <span class="number">985</span>,   <span class="number">1429</span>,  <span class="number">1936</span>,  <span class="number">2430</span>,  <span class="number">2820</span>,  <span class="number">3143</span>,  <span class="number">3370</span>,  <span class="number">3547</span>,  <span class="number">3685</span>,  <span class="number">3780</span>,  <span class="number">3853</span>,  <span class="number">3909</span>,&#125;,</span><br><span class="line"><span class="comment">/*45℃*/</span>  &#123;<span class="number">157</span>,   <span class="number">171</span>,   <span class="number">237</span>,   <span class="number">315</span>,   <span class="number">477</span>,   <span class="number">750</span>,   <span class="number">1154</span>,  <span class="number">1604</span>,  <span class="number">2101</span>,  <span class="number">2540</span>,  <span class="number">2945</span>,  <span class="number">3236</span>,  <span class="number">3442</span>,  <span class="number">3603</span>,  <span class="number">3728</span>,  <span class="number">3816</span>,  <span class="number">3871</span>,  <span class="number">3918</span>,&#125;,</span><br><span class="line"><span class="comment">/*50℃*/</span>  &#123;<span class="number">158</span>,   <span class="number">174</span>,   <span class="number">253</span>,   <span class="number">354</span>,   <span class="number">545</span>,   <span class="number">865</span>,   <span class="number">1328</span>,  <span class="number">1835</span>,  <span class="number">2298</span>,  <span class="number">2727</span>,  <span class="number">3055</span>,  <span class="number">3329</span>,  <span class="number">3516</span>,  <span class="number">3660</span>,  <span class="number">3762</span>,  <span class="number">3843</span>,  <span class="number">3895</span>,  <span class="number">3938</span>,&#125;,</span><br><span class="line"><span class="comment">/*55℃*/</span>  &#123;<span class="number">159</span>,   <span class="number">179</span>,   <span class="number">278</span>,   <span class="number">401</span>,   <span class="number">634</span>,   <span class="number">941</span>,   <span class="number">1524</span>,  <span class="number">2027</span>,  <span class="number">2502</span>,  <span class="number">2844</span>,  <span class="number">3173</span>,  <span class="number">3398</span>,  <span class="number">3563</span>,  <span class="number">3693</span>,  <span class="number">3789</span>,  <span class="number">3862</span>,  <span class="number">3909</span>,  <span class="number">3947</span>,&#125;,</span><br><span class="line"><span class="comment">/*60℃*/</span>  &#123;<span class="number">160</span>,   <span class="number">184</span>,   <span class="number">301</span>,   <span class="number">457</span>,   <span class="number">739</span>,   <span class="number">1035</span>,  <span class="number">1711</span>,  <span class="number">2209</span>,  <span class="number">2662</span>,  <span class="number">2999</span>,  <span class="number">3275</span>,  <span class="number">3456</span>,  <span class="number">3611</span>,  <span class="number">3728</span>,  <span class="number">3807</span>,  <span class="number">3871</span>,  <span class="number">3918</span>,  <span class="number">3957</span>,&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEMP_INTERVAL_VAL   5   <span class="comment">// 温度间隔值 (°C)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HUMI_INTERVAL_VAL   5   <span class="comment">// 湿度间隔值 (%RH)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HUMI_MAX_VAL        95  <span class="comment">// 最大湿度值 (%RH)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HUMI_MIN_VAL        10  <span class="comment">// 最小湿度值 (%RH)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEMP_MAX_VAL        60  <span class="comment">// 最大温度值 (°C)</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">GPIOInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	rcu_periph_clock_enable(RCU_GPIOC);</span><br><span class="line">	gpio_init(GPIOC, GPIO_MODE_AIN, GPIO_OSPEED_MAX, GPIO_PIN_4);    <span class="comment">// ADC通道14</span></span><br><span class="line">	</span><br><span class="line">	rcu_periph_clock_enable(RCU_GPIOB);</span><br><span class="line">	gpio_init(GPIOB, GPIO_MODE_OUT_PP, GPIO_OSPEED_50MHZ, GPIO_PIN_0 | GPIO_PIN_1);  <span class="comment">// 交流电源激励</span></span><br><span class="line">	gpio_bit_write(GPIOB, GPIO_PIN_0, (bit_status)<span class="number">1</span>);</span><br><span class="line">	gpio_bit_write(GPIOB, GPIO_PIN_1, (bit_status)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ADCInit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 使能时钟；*/</span></span><br><span class="line">	rcu_periph_clock_enable(RCU_ADC1);</span><br><span class="line">	<span class="comment">/* 设置分频系数；*/</span></span><br><span class="line">	rcu_adc_clock_config(RCU_CKADC_CKAPB2_DIV6);  <span class="comment">// 6分频，120MHz / 6 = 20MHz</span></span><br><span class="line">	<span class="comment">/* 设置独立模式；*/</span></span><br><span class="line">	adc_mode_config(ADC_MODE_FREE);</span><br><span class="line">	<span class="comment">/* 设置单次模式；*/</span> </span><br><span class="line">	adc_special_function_config(ADC1, ADC_CONTINUOUS_MODE, DISABLE);</span><br><span class="line">	<span class="comment">/* 设置数据对齐；*/</span></span><br><span class="line">	adc_data_alignment_config(ADC1, ADC_DATAALIGN_RIGHT);</span><br><span class="line">	<span class="comment">/* 设置转换通道个数；*/</span> </span><br><span class="line">	adc_channel_length_config(ADC1, ADC_REGULAR_CHANNEL, <span class="number">1</span>);</span><br><span class="line">	<span class="comment">/* 设置转换哪一个通道以及所处序列位置；*/</span> </span><br><span class="line">	adc_regular_channel_config(ADC1, <span class="number">0</span>, ADC_CHANNEL_14, ADC_SAMPLETIME_71POINT5);  <span class="comment">// PC4对应通道14，放在序列寄存器的0序列中，71.5个周期</span></span><br><span class="line">	<span class="comment">/* 设置选择哪一个外部触发源；*/</span> </span><br><span class="line">	adc_external_trigger_source_config(ADC1, ADC_REGULAR_CHANNEL, ADC0_1_2_EXTTRIG_REGULAR_NONE);</span><br><span class="line">	<span class="comment">/* 使能外部触发；*/</span> </span><br><span class="line">	adc_external_trigger_config(ADC1, ADC_REGULAR_CHANNEL, ENABLE);</span><br><span class="line">	<span class="comment">/* 使能硬件滤波；*/</span> </span><br><span class="line">	adc_oversample_mode_config(ADC1, ADC_OVERSAMPLING_ALL_CONVERT, ADC_OVERSAMPLING_SHIFT_4B, ADC_OVERSAMPLING_RATIO_MUL16);</span><br><span class="line">	adc_oversample_mode_enable(ADC1);</span><br><span class="line">	<span class="comment">/* 使能ADC；*/</span> </span><br><span class="line">	adc_enable(ADC1);</span><br><span class="line">	<span class="comment">/* 内部校准；*/</span> </span><br><span class="line">	DelayNus(<span class="number">50</span>);</span><br><span class="line">	adc_calibration_enable(ADC1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">TimerInit</span><span class="params">(<span class="type">uint32_t</span> periodUs)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 使能定时器时钟；*/</span></span><br><span class="line">	rcu_periph_clock_enable(RCU_TIMER4);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 复位定时器；*/</span></span><br><span class="line">	timer_deinit(TIMER4);</span><br><span class="line">	</span><br><span class="line">	timer_parameter_struct timerInitPara;</span><br><span class="line">	timer_struct_para_init(&amp;timerInitPara);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 设置预分频器值；*/</span></span><br><span class="line">	timerInitPara.prescaler = <span class="number">120</span> - <span class="number">1</span>;     <span class="comment">// 输入给计数器的时钟频率为1Mhz，周期1us</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 设置自动重装载值；*/</span> </span><br><span class="line">	timerInitPara.period = periodUs - <span class="number">1</span>;</span><br><span class="line">	timer_init(TIMER4, &amp;timerInitPara);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 使能定时器的计数更新中断；*/</span></span><br><span class="line">	timer_interrupt_enable(TIMER4, TIMER_INT_UP);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 使能定时器中断和优先级；*/</span></span><br><span class="line">	nvic_irq_enable(TIMER4_IRQn, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 使能定时器；*/</span> </span><br><span class="line">	timer_enable(TIMER4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief 湿度传感器驱动初始化</span></span><br><span class="line"><span class="comment">* @param</span></span><br><span class="line"><span class="comment">* @return </span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Humi_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIOInit();</span><br><span class="line">	ADCInit();</span><br><span class="line">	Timer_Init(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief 获取数据寄存器中的 ADC 值</span></span><br><span class="line"><span class="comment">* @param</span></span><br><span class="line"><span class="comment">* @return ADC值</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint16_t</span> <span class="title function_">GetAdcVal</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 中断服务函数中每调用一次，使能ADC转换 */</span></span><br><span class="line">	adc_software_trigger_enable(ADC1, ADC_REGULAR_CHANNEL);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* 等待转换完成标志 */</span></span><br><span class="line">    <span class="keyword">while</span>(!adc_flag_get(ADC1, ADC_FLAG_EOC));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 读取数据寄存器 */</span></span><br><span class="line">    <span class="keyword">return</span> (adc_regular_data_read(ADC1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief 翻转 IO 状态</span></span><br><span class="line"><span class="comment">* @param 无</span></span><br><span class="line"><span class="comment">* @return 无</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">AcPowerProc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	gpio_bit_write(GPIOB, GPIO_PIN_0, (FlagStatus)((FlagStatus)<span class="number">1</span> - gpio_output_bit_get(GPIOB, GPIO_PIN_0)));</span><br><span class="line">	gpio_bit_write(GPIOB, GPIO_PIN_1, (FlagStatus)((FlagStatus)<span class="number">1</span> - gpio_output_bit_get(GPIOB, GPIO_PIN_1)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TIMER4_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">uint16_t</span> timerCount = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (timer_interrupt_flag_get(TIMER4, TIMER_INT_FLAG_UP) != RESET)</span><br><span class="line">	&#123;</span><br><span class="line">		timer_interrupt_flag_clear(TIMER4, TIMER_INT_FLAG_UP);</span><br><span class="line">		timerCount++;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (timerCount % <span class="number">2</span> == <span class="number">0</span>)     <span class="comment">// 每2ms反转IO口</span></span><br><span class="line">		&#123;</span><br><span class="line">			AcPowerProc();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (timerCount % <span class="number">400</span> == <span class="number">1</span>)  <span class="comment">// 每隔400ms，在高电平中间位置获取一次ADC的数据</span></span><br><span class="line">		&#123;</span><br><span class="line">			g_adcVal = GetAdcVal();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief 根据温度计算湿度对应的 ADC 值表</span></span><br><span class="line"><span class="comment">* @param arr 存储计算结果的数组</span></span><br><span class="line"><span class="comment">* @param temp 当前温度</span></span><br><span class="line"><span class="comment">* @return 无</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">CalcHumiAdcByTemp</span><span class="params">(<span class="type">uint16_t</span> *arr, <span class="type">uint8_t</span> temp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> tempRow = temp / TEMP_INTERVAL_VAL;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 边界值温度直接返回其ADC值即可 */</span></span><br><span class="line">	<span class="keyword">if</span> (temp % TEMP_INTERVAL_VAL == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memcpy</span>(arr, &amp;g_rhADCVal[tempRow][<span class="number">0</span>], HUMI_LEVEL_NUM * <span class="keyword">sizeof</span>(<span class="type">uint16_t</span>));</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">uint8_t</span> i = <span class="number">0</span>; i &lt; HUMI_LEVEL_NUM; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		arr[i] = g_rhADCVal[tempRow][i] + (g_rhADCVal[tempRow + <span class="number">1</span>][i] - g_rhADCVal[tempRow][i]) * (tempRow) / TEMP_INTERVAL_VAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief 使用二分法在升序数组中查找元素位置</span></span><br><span class="line"><span class="comment">* @param arr 升序数组</span></span><br><span class="line"><span class="comment">* @param size 数组大小</span></span><br><span class="line"><span class="comment">* @param key 查找的键值</span></span><br><span class="line"><span class="comment">* @return 找到的位置索引</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int32_t</span> <span class="title function_">AsceBinarySearch</span><span class="params">(<span class="type">const</span> <span class="type">uint16_t</span> *arr, <span class="type">int32_t</span> size, <span class="type">uint16_t</span> key)</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int32_t</span> left = <span class="number">0</span>;              			</span><br><span class="line">	<span class="type">int32_t</span> right = size - <span class="number">1</span>;       		</span><br><span class="line">	<span class="type">int32_t</span> mid;</span><br><span class="line">	<span class="type">int32_t</span> index = size - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (left &lt;= right)             		</span><br><span class="line">	&#123;</span><br><span class="line">		mid = left + (right - left) / <span class="number">2</span>; </span><br><span class="line">		<span class="keyword">if</span> (key &lt;= arr[mid])</span><br><span class="line">		&#123;</span><br><span class="line">			right = mid - <span class="number">1</span>;</span><br><span class="line">			index = mid;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			left = mid + <span class="number">1</span>;  		</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    	<span class="keyword">return</span> index;               				</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> <span class="title function_">ADCToHumi</span><span class="params">(<span class="type">uint16_t</span> *arr, <span class="type">uint16_t</span> adcVal)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int32_t</span> index = AsceBinarySearch(arr, HUMI_LEVEL_NUM, adcVal);</span><br><span class="line">	<span class="keyword">if</span> (index == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> HUMI_MIN_VAL;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">uint8_t</span> humi = HUMI_MIN_VAL + (index - <span class="number">1</span>) * HUMI_INTERVAL_VAL +  HUMI_INTERVAL_VAL * (adcVal - arr[index - <span class="number">1</span>]) / (arr[index] - arr[index - <span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">return</span> humi;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief 触发驱动转换湿度传感器数据</span></span><br><span class="line"><span class="comment">* @param</span></span><br><span class="line"><span class="comment">* @return </span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Humi_SensorProc</span><span class="params">(<span class="type">uint8_t</span> temp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (temp &gt; TEMP_MAX_VAL)</span><br><span class="line">	&#123;</span><br><span class="line">		temp = TEMP_MAX_VAL;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">uint16_t</span> humiADCBuf[HUMI_LEVEL_NUM];</span><br><span class="line">	CalcHumiAdcByTemp(humiADCBuf, temp);</span><br><span class="line">	g_humiData = ADCToHumi(humiADCBuf, g_adcVal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">* @brief 获取湿度传感器数据</span></span><br><span class="line"><span class="comment">* @param</span></span><br><span class="line"><span class="comment">* @return 湿度数据，整数</span></span><br><span class="line"><span class="comment">***********************************************************</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">Get_HumiData</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> g_humiData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="RS485"><a href="#RS485" class="headerlink" title="RS485"></a>RS485</h1><h2 id="1-协议介绍"><a href="#1-协议介绍" class="headerlink" title="1.协议介绍"></a><strong>1.协议介绍</strong></h2><blockquote>
<h6 id="协议框图："><a href="#协议框图：" class="headerlink" title="协议框图："></a>协议框图：</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412021947729.png" alt="image-20241202194707662" style="zoom: 150%;"></p>
<p>​    RS485采用的是双线传输，包含A信号线和B信号线。与RS232最本质的区别在于，RS485采用了差分模式。即在同一时刻，RS485    总线要么在发送数据，要么在接收数据，因此是半双工的。</p>
<p>​    RS232是全双工的，使用两个信号线，一个用于发送数据，另一个用于接收数据。这是它们两个的主要区别。</p>
<p>​    由于采用差分模式，当A-B的电压差值大于0.2伏时，RS485总线传输逻辑电平1；当A-B小于-0.2伏时，传输逻辑电平0。如果A-B    的电压差在-0.2伏到0.2伏之间，则无法识别逻辑电平。</p>
<p>​    这种差分模式可以提高抗干扰能力。例如，遇到脉冲干扰时，干扰会叠加在A和B信号线上，但由于差分模式，A-B的差值会抵消    这些脉冲干扰。因此，RS485能够实现更远的通信距离，理论上可达1200米，远超RS232，广泛应用于工业现场。</p>
<p>​    RS485支持一主多从的通信方式，即一个主机可以连接多个从机。这种能力取决于芯片的转换能力和软件协议。</p>
</blockquote>
<h2 id="2-硬件电路方案"><a href="#2-硬件电路方案" class="headerlink" title="2.硬件电路方案"></a><strong>2.硬件电路方案</strong></h2><blockquote>
<h6 id="常规方案"><a href="#常规方案" class="headerlink" title="常规方案:"></a>常规方案:</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412021957614.png" alt="image-20241202195740526"></p>
<p>​    使用常见的转换芯片，如SSP485。左侧部分连接到MCU单片机，涉及三个IO口，分别对应串口的RX、TX以及一个普通的IO口。    在开发板上使用的是PC5口，用于切换RS485芯片的工作模式（发送或接收）。通过一个切换开关控制，并配有三个100欧姆的限    流电阻起到缓冲作用。</p>
<p>​    右侧是RS485相关的电路部分，包括防护电路。主要有两个自恢复保险丝，起到过流保护，防止电流过大烧毁器件；三个TVS二极    管，用于防止浪涌干扰。这些都是典型的防护电路，可以参考芯片的规格书（datasheet）获取这些电路信息，实际产品中也大量    使用，放在自己的项目中没有问题。</p>
<p>​    左侧有两个上拉和下拉电阻。A信号线接一个上拉电阻到3.3伏，B信号线接一个下拉电阻到GND。这两个上下拉电阻是必须要加</p>
<p>​    的，以保证RS485总线在空闲状态下A和B信号线呈现逻辑电平1，即电压差大于0.2伏。这样在空闲状态下，A和B信号线通过上下    拉电阻分别为3.3伏和0伏，确保RS485总线电平为1。</p>
<p>​    另外，RS485有时需要在A和B信号线之间加上120欧姆的终端电阻，具体是否需要根据实际部署环境决定。如果系统中有多个节点    且总线距离较长，可以在主机侧和最后一个从机侧各加一个120欧姆的终端电阻，以起到阻抗匹配、防止信号反射的作用。</p>
<h6 id="自收发电路"><a href="#自收发电路" class="headerlink" title="自收发电路:"></a>自收发电路:</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412021957032.png" alt="image-20241202195733946"></p>
<p>​    较于第一种方案，它节省了一个IO口，仅使用串口的RX和TX。</p>
<h6 id="具体实现方式如下："><a href="#具体实现方式如下：" class="headerlink" title="具体实现方式如下："></a>具体实现方式如下：</h6><p>​    串口的RX接到RO管脚，DI管脚接地。单片机的TX通过一个三极管连接到RE和DE管脚。这种设计虽然节省了IO口，但不太规范，    实际应用中不推荐使用。之前使用这种电路时，遇到了RS485通信异常的问题，发现电阻损坏（虽然表面未烧毁，但电阻变为无    穷大），原因可能与现场环境如雷击或强干扰有关。因此，建议采用第一种常规方案。</p>
<h6 id="自收发电路的工作原理："><a href="#自收发电路的工作原理：" class="headerlink" title="自收发电路的工作原理："></a>自收发电路的工作原理：</h6><p>​    自收发电路中，当工作在接收模式时，单片机的TX默认是高电平，三极管导通，使RE被使能，RS485芯片进入接收模式，可以接    收外部数据。当需要发送数据时，通过三极管切换至发送模式，发送对应的逻辑电平。由于使用了三极管的开关特性，频率特性    与串口的波特率相关，适用于较低的波特率（如9600），高波特率下可能不稳定。</p>
<p>​    这种电路的优点是节省IO口，适用于IO资源有限的项目。但由于稳定性和可靠性问题，实际应用中建议优先选择常规方案。</p>
</blockquote>
<h1 id="MODBUS"><a href="#MODBUS" class="headerlink" title="MODBUS"></a>MODBUS</h1><h2 id="1-协议介绍-1"><a href="#1-协议介绍-1" class="headerlink" title="1.协议介绍"></a><strong>1.协议介绍</strong></h2><h3 id="1-RS485-amp-MODBUS"><a href="#1-RS485-amp-MODBUS" class="headerlink" title="1. RS485 &amp; MODBUS"></a>1. RS485 &amp; MODBUS</h3><blockquote>
<h6 id="关系框图："><a href="#关系框图：" class="headerlink" title="关系框图："></a>关系框图：</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412022050180.png" alt="image-20241202205031112"></p>
<p>​    RS485 是一种电气协议，属于硬件级别的协议。而 MODBUS 是一种软件协议，这种软件协议既可以运行在 RS485 这种电气接口</p>
<p>​    上，也可以运行在 RS232 或者以太网电气接口上。</p>
<p>​    <strong>RS485相当于公路，MODBUS相当于交通规则，传输的数据就是汽车。</strong></p>
</blockquote>
<h3 id="2-特点"><a href="#2-特点" class="headerlink" title="2.特点"></a>2.特点</h3><blockquote>
<h6 id="标准开放性："><a href="#标准开放性：" class="headerlink" title="标准开放性："></a>标准开放性：</h6><p>MODBUS 协议是标准开放的，公开发表的，没有版权要求。</p>
<h6 id="协议格式与兼容性："><a href="#协议格式与兼容性：" class="headerlink" title="协议格式与兼容性："></a>协议格式与兼容性：</h6><p>MODBUS 协议的消息帧格式非常简单，便于厂商开发和集成。在做产品时，尽量少使用私有协议（即自己定义的协议），因为这样无法与其他厂商的产品对接，尤其是在复杂庞大的系统中，可能有许多不同厂家的设备，系统将无法正常运行。因此，在使用通信协议时，一定要选择标准开放的协议。</p>
<h6 id="传输介质与报文类型："><a href="#传输介质与报文类型：" class="headerlink" title="传输介质与报文类型："></a>传输介质与报文类型：</h6><p>MODBUS 协议可以在 RS485 、RS232 和以太网上传输，支持三种报文类型，包括 ASCII、RTU（Remote Terminal Unit）和 TCP。对于 ASCII 和 RTU ，通常运行在 RS485 和 RS232 电气接口上；而 TCP 则用于以太网接口。</p>
<p>在 ASCII 和 RTU 中，RTU 模式最为常用。RTU 使用二进制（或 16 进制）数据传输，而 ASCII 模式使用字符数据传输。</p>
</blockquote>
<h2 id="2-报文格式"><a href="#2-报文格式" class="headerlink" title="2.报文格式"></a>2.报文格式</h2><blockquote>
<h6 id="报文介绍："><a href="#报文介绍：" class="headerlink" title="报文介绍："></a>报文介绍：</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412022054120.png" alt="image-20241202205421028"></p>
<ul>
<li>绿色的线表示以太网，传输协议报文类型为TCP。</li>
<li>蓝色的线表示RS485电气接口。主机通过RS485连接多个从机，大家都使用一套MODBUS RTU协议进行集成。</li>
</ul>
<h6 id="MODBUS-RTU-报文格式："><a href="#MODBUS-RTU-报文格式：" class="headerlink" title="MODBUS-RTU 报文格式："></a>MODBUS-RTU 报文格式：</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412022057133.png" alt="image-20241202205755053"></p>
<p>​    在传输数据时，一包数据通常包含多个字节，我们可以称之为一帧数据。其格式如下：</p>
<ul>
<li><strong>从机地址（ 1 字节）</strong>：每个从机都有唯一的地址（ID），相当于门牌号，主机通过地址找到对应的从机。</li>
<li><strong>功能码（ 1 字节）</strong>：指示这一帧数据的用途，例如查询数据、读取数据、修改数据或写入数据。</li>
<li><strong>数据部分（ 0 - 252 字节）</strong>：根据功能码的不同，内容也不同。</li>
<li><strong>CRC校验码（ 2 字节）</strong>：包括低字节和高字节，用于检测接收数据的正确性。</li>
</ul>
<h6 id="功能码："><a href="#功能码：" class="headerlink" title="功能码："></a>功能码：</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412022059166.png" alt="image-20241202205953093"></p>
<p>​    MODBUS协议中有多个功能码，其中最常用的功能码：</p>
<ul>
<li>03：读多个寄存器</li>
<li>06：写单个寄存器</li>
<li>16：写多个寄存器</li>
</ul>
</blockquote>
<h2 id="3-数据格式"><a href="#3-数据格式" class="headerlink" title="3.数据格式"></a>3.<strong>数据格式</strong></h2><blockquote>
<p>​    <strong>这里的寄存器不是指单片机中的物理寄存器，而是软件中的控制项。</strong>例如，控制传感器、继电器、开关等。这些寄存器在软件设</p>
<p>​    计时需要分配唯一的地址，类似于 PLC 系统中的控制项。</p>
<p>​    以某个产品为例，支持 RS485 MODBUS 功能。软件设计时，需要为每个传感器（如 PM2.5、温度、湿度、二氧化碳、TVOC、</p>
<p>​    PM10）分配唯一的寄存器地址，并定义其数据格式（通常为两个字节）。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412022107725.png" alt="image-20241202210742650" style="zoom:;"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412022102725.png" alt="image-20241202210254655"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412022106828.png" alt="image-20241202210609762"></p>
<p>​    <strong>空闲间隔时间（3.5T）</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412031549792.png" alt="image-20241203154937731"></p>
<p>​    为了方便软件解析数据，MODBUS RTU 协议规定两帧数据之间必须有 3.5 个字符时间的空闲间隔，称为 3.5T 。这有助于判断一帧</p>
<p>​    数据是否接收完毕。具体时间计算如下：</p>
<ul>
<li><p>假设波特率为9600，字符时间为10位（1起始位 + 8数据位 + 1停止位）。</p>
</li>
<li><p>一个字符传输时间 = 10位 / 9600波特率 ≈ 1.04毫秒</p>
</li>
<li><p>3.5T ≈ 3.5 × 1.04 ≈ 3.64毫秒</p>
<p><strong>通常设计时，使用定时器来实现3.5T的检测。</strong></p>
</li>
</ul>
<h6 id="异常处理："><a href="#异常处理：" class="headerlink" title="异常处理："></a>异常处理：</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412022125615.png" alt="image-20241202212532544"></p>
<p>​    实际应用中，可能会接收到错误的数据，此时需要进行异常处理。MODBUS 定义了几种异常码，例如：</p>
<ul>
<li>01：非法功能码（从机不支持该功能码）</li>
<li>02：非法地址（地址超出范围）</li>
<li>03：非法数据值（数据值不在允许范围）</li>
<li>04：从机故障（解析数据时出错）</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412022126452.png" alt="image-20241202212635382"></p>
<p>​    主机发送了一个非法地址，或者数据值不合法，从机会返回对应的异常码通知主机。</p>
</blockquote>
<h2 id="4-软件架构"><a href="#4-软件架构" class="headerlink" title="4.软件架构"></a><strong>4.软件架构</strong></h2><blockquote>
<h6 id="采用分层架构，代码清晰："><a href="#采用分层架构，代码清晰：" class="headerlink" title="采用分层架构，代码清晰："></a>采用分层架构，代码清晰：</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412022119111.png" alt></p>
<ul>
<li><strong>应用层</strong>：实现具体的业务逻辑，如数据处理和控制。</li>
<li><strong>中间件层</strong>：使用 FreeMODBUS 库，实现协议相关功能。</li>
<li><strong>驱动层</strong>：实现定时器和串口的初始化及中断功能。</li>
</ul>
<p>​    MODBUS 协议本身格式简单，但在代码实现时涉及数据解析、异常处理和 3.5T 的检测，可能显得复杂。因此，建议使用开源的</p>
<p>​    MODBUS 库，如 FreeMODBUS ，来简化开发。FreeMODBUS 已经实现了<strong>从机功能、异常处理和数据解析</strong>等，开发者只需实现驱</p>
<p>​    动层接口，如定时器和串口中断，并编写业务逻辑代码。</p>
</blockquote>
<h1 id="IIC"><a href="#IIC" class="headerlink" title="IIC"></a>IIC</h1><h2 id="1-协议解读"><a href="#1-协议解读" class="headerlink" title="1.协议解读"></a>1.协议解读</h2><h3 id="1-串并行通信"><a href="#1-串并行通信" class="headerlink" title="1.串并行通信"></a>1.串并行通信</h3><blockquote>
<h6 id="串行通信与并行通信简易框图："><a href="#串行通信与并行通信简易框图：" class="headerlink" title="串行通信与并行通信简易框图："></a>串行通信与并行通信简易框图：</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412131829756.png" alt="image-20241213182936683"></p>
<p>​     <strong>UART 、I²C、SPI、CAN、USB </strong>都是串行通信。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412131855012.png" alt="image-20241213185508950"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412131830718.png" alt="image-20241213183034659"></p>
<p>​    I²C 总线一共两个信号线，一个是时钟信号线（ SCL ），一个是数据线（ SDA ）。而异步通信，比如 UART（串口），没有时钟信    号线。</p>
<p>​    同步通信：由于有时钟信号，接收端根据<strong>时钟信号的脉冲</strong>来检测和解析数据线上的数据是<code>0</code>还是<code>1</code>。因此，对于同步通信来</p>
<p>​    说，对持续时间的要求没有那么严格，可以稍快或慢。</p>
<p>​    异步通信：数据传输时，<strong>接收端和发送端必须严格按照固定的波特率去发送和解析数据</strong>。例如<code>9600</code>波特</p>
<p>​    率，接收端接收到数据时，会根据波特率对应每一个二进制位的持续时间去解析数据，是二进制的<code>0</code>还是<code>1</code>。因此，时序要求非</p>
<p>​    常严格。</p>
<p>​    <strong>I²C 总线是半双工的，因为只有两个信号线（ SCL 和 SDA ），在同一时刻只能进行发送或接收。</strong></p>
</blockquote>
<h3 id="2-硬件原理"><a href="#2-硬件原理" class="headerlink" title="2.硬件原理"></a>2.硬件原理</h3><blockquote>
<p>​    I²C 总线和 MODBUS 一样，<strong>支持一主多从的通信方式</strong>，即一个主机可以连接多个从机。例如在一个总线上，可以将单片机作为主    机，挂载多个从机（如 EEPROM 、触摸屏芯片、温湿度传感器等）。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412131540868.png" alt="image-20241213154014804"></p>
<p>​    在总线上，有多个节点设备要求这些设备内部需要将<strong>SDA和SCL总线配置成开漏输出模式，而不能设计成推挽输出模式</strong>。</p>
<p>​    设备内部设计成开漏输出模式，还需要在总线上使用两个上拉电阻，每条总线都加一个上拉电阻，阻值一般是3kΩ到10kΩ，典型</p>
<p>​    值是4.7kΩ。</p>
<h6 id="开漏输出和上拉电阻实现限流："><a href="#开漏输出和上拉电阻实现限流：" class="headerlink" title="开漏输出和上拉电阻实现限流："></a>开漏输出和上拉电阻实现限流：</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412131541437.png" alt="image-20241213154145377"></p>
<p>​    假如总线上有两个设备：</p>
<ul>
<li><p>第一个设备要输出高电平1，上拉电阻将总线拉高，开漏输出管不导通，总线保持高电平。</p>
</li>
<li><p>另一个设备要输出低电平0，它的开漏输出管导通，将总线拉低。</p>
</li>
</ul>
<p>​    <strong>由于开漏输出模式，多个设备可以安全地连接在同一总线上，而不会像推挽输出模式那样导致短路和损坏器件。</strong></p>
</blockquote>
<h2 id="2-数据格式"><a href="#2-数据格式" class="headerlink" title="2.数据格式"></a><strong>2.数据格式</strong></h2><blockquote>
<h6 id="数据格式："><a href="#数据格式：" class="headerlink" title="数据格式："></a>数据格式：</h6><ul>
<li><p>主机控制：单片机程序</p>
</li>
<li><p>从机控制：芯片内部</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412131906232.png" alt="image-20241213190652166"></p>
<h6 id="向从机写数据："><a href="#向从机写数据：" class="headerlink" title="向从机写数据："></a>向从机写数据：</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202502151716819.png" alt="图片1"></p>
<p>​    主机发送数据，从机接收数据后发送应答信号。</p>
<h6 id="向从机读数据："><a href="#向从机读数据：" class="headerlink" title="向从机读数据："></a>向从机读数据：</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202502151717896.png" alt="图片2"></p>
<p>​    主机发送从机地址 + 读控制位后，从机发送数据，主机接收数据后发送应答信号，主机接收完数据后发送非应答信号。</p>
</blockquote>
<h2 id="3-时钟频率与数据传输"><a href="#3-时钟频率与数据传输" class="headerlink" title="3.时钟频率与数据传输"></a><strong>3.时钟频率与数据传输</strong></h2><blockquote>
<p>​    I²C总线支持多种时钟频率，如 <strong>100kHz（标准模式）</strong>、400kHz（快速模式）、1MHz（高速模式）。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412131912451.png" alt="image-20241213191225388"></p>
<p>​    主机控制 SCL 时钟信号，SDA 信号线由主机或从机控制。传输数据时，SDA 信号线的数据只能在 SCL 为低电平时变化，在 SCL 为    高电平时保持稳定，供接收方读取。</p>
</blockquote>
<h3 id="1-起始、停止信号"><a href="#1-起始、停止信号" class="headerlink" title="1.起始、停止信号"></a><strong>1.起始、停止信号</strong></h3><blockquote>
<h6 id="空闲状态时，SDA-和-SCL-信号线都保持高电平："><a href="#空闲状态时，SDA-和-SCL-信号线都保持高电平：" class="headerlink" title="空闲状态时，SDA 和 SCL 信号线都保持高电平："></a>空闲状态时，SDA 和 SCL 信号线都保持高电平：</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412131914019.png" alt="image-20241213191453961"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412131916321.png" alt="image-20241213191612262"></p>
<p>​    <strong>当数据传输时，主机发起起始信号，开始数据传输；传输完成后，主机发起停止信号，返回空闲状态</strong>。</p>
</blockquote>
<h3 id="2-发送字节"><a href="#2-发送字节" class="headerlink" title="2.发送字节"></a><strong>2.发送字节</strong></h3><blockquote>
<h6 id="高电平（稳定状态）读取数据，低电平准备数据："><a href="#高电平（稳定状态）读取数据，低电平准备数据：" class="headerlink" title="高电平（稳定状态）读取数据，低电平准备数据："></a>高电平（稳定状态）读取数据，低电平准备数据：</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412131922777.png" alt="image-20241213192215715"></p>
<p>​    <strong>主机使 SCL 高电平时间维持周期的一半值（以上），从机才能检测到 SDA 数据。</strong></p>
</blockquote>
<h3 id="3-读取字节"><a href="#3-读取字节" class="headerlink" title="3.读取字节"></a><strong>3.读取字节</strong></h3><blockquote>
<h6 id="读取数据时，不论主机还是从机，主机必须先释放-SDA-线："><a href="#读取数据时，不论主机还是从机，主机必须先释放-SDA-线：" class="headerlink" title="读取数据时，不论主机还是从机，主机必须先释放 SDA 线："></a>读取数据时，不论主机还是从机，<strong>主机</strong>必须先释放 SDA 线：</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412131928260.png" alt="image-20241213192838194"></p>
<p>​    <strong>在 IIC 协议中，SDA 线是双向的，既可以由主机控制，也可以由从机控制。</strong>主机在读取数据时，必须释放 SDA 线，使得从机能够    写入数据到 SDA 线，主机将数据放到 SDA 线上。如果主机没有释放 SDA 线而仍然保持为低电平，则该时刻，无论从机发送数据</p>
<p>​    的是 0 还是 1 ，最终都会被拉成 0（从机无法操作 SDA 线），因为主机仍然控制着 SDA 线。</p>
</blockquote>
<h3 id="4-发送应答"><a href="#4-发送应答" class="headerlink" title="4.发送应答"></a><strong>4.发送应答</strong></h3><blockquote>
<h6 id="主机和从机都可以发送应答信号（ACK）。低电平应答，高电平（初态）非应答："><a href="#主机和从机都可以发送应答信号（ACK）。低电平应答，高电平（初态）非应答：" class="headerlink" title="主机和从机都可以发送应答信号（ACK）。低电平应答，高电平（初态）非应答："></a>主机和从机都可以发送应答信号（ACK）。低电平应答，高电平（初态）非应答：</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412131944748.png" alt="image-20241213194439683"></p>
<p>​    <strong>主机</strong>：<strong>主机</strong>接收到从机发送的数据（<strong>读操作</strong>），会<strong>向从机发送</strong>一个 ACK 信号，表示数据已经接收，可以继续接收更多数据，此时    从机接收应答（<strong>主机软件手动控制，从机硬件检测</strong>）。</p>
<p>​    <strong>从机</strong>：<strong>从机</strong>接收到主机发送的数据（<strong>写操作</strong>），会<strong>向主机发送</strong>一个 ACK 信号，表示数据已经接收，可以继续接收更多数据，此时    主机接收应答（<strong>从机硬件自动发送，主机软件检测</strong>）。</p>
</blockquote>
<h3 id="5-接收应答"><a href="#5-接收应答" class="headerlink" title="5.接收应答"></a><strong>5.接收应答</strong></h3><blockquote>
<h6 id="主机和从机都接收应答信号（ACK）："><a href="#主机和从机都接收应答信号（ACK）：" class="headerlink" title="主机和从机都接收应答信号（ACK）："></a>主机和从机都接收应答信号（ACK）：</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412131938993.png" alt="image-20241213193803925"></p>
<p>​    <strong>主机</strong>：从机发送一个 ACK 信号（<strong>从机硬件自动发送</strong>），主机接收该应答信号（<strong>主机软件检测</strong>）表示已成功接收数据并准备好接收    下一个字节。</p>
<p>​    <strong>从机</strong>：主机发送一个 ACK 信号（<strong>主机软件手动控制</strong>），从机接收该应答信号（<strong>从机硬件检测</strong>）表示已成功接收数据并准备好接收    下一个字节。</p>
</blockquote>
<h2 id="4-EEPROM"><a href="#4-EEPROM" class="headerlink" title="4. EEPROM"></a>4. EEPROM</h2><blockquote>
<h6 id="存储器分类："><a href="#存储器分类：" class="headerlink" title="存储器分类："></a>存储器分类：</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412132024705.png" alt="image-20241213202400643"></p>
</blockquote>
<h3 id="1-ROM发展历程"><a href="#1-ROM发展历程" class="headerlink" title="1. ROM发展历程"></a>1. ROM发展历程</h3><blockquote>
<h6 id="ROM-介绍："><a href="#ROM-介绍：" class="headerlink" title="ROM 介绍："></a>ROM 介绍：</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412132025153.png" alt="image-20241213202541090"></p>
<ul>
<li><strong>掩膜ROM（Mask ROM）</strong>：出厂时就写入数据，之后不可修改。</li>
<li><strong>PROM</strong>：可编程 ROM ，通过特殊手段可以在出厂后写入一次数据，但只能修改一次。</li>
<li><strong>EPROM</strong>：可擦除可编程 ROM ，采用紫外线擦除并重新写入数据，支持多次擦写。</li>
<li><strong>EEPROM（电可擦除可编程 ROM ）</strong>：与 EPROM 类似，但采用电流擦除，支持多次擦写。</li>
</ul>
</blockquote>
<h3 id="2-EEPROM-与-Flash"><a href="#2-EEPROM-与-Flash" class="headerlink" title="2. EEPROM 与 Flash"></a>2. EEPROM 与 Flash</h3><blockquote>
<h6 id="Flash-与-EEPROM-比较："><a href="#Flash-与-EEPROM-比较：" class="headerlink" title="Flash 与 EEPROM 比较："></a>Flash 与 EEPROM 比较：</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412132025477.png" alt="image-20241213202552418"></p>
<ul>
<li><p><strong>EEPROM</strong>：可以随机访问并修改任何字节，支持数据保存 100 年，擦写次数可达 100 万次。它的成本较高，容量较小，如</p>
<p>​    <strong>AT24C02</strong> 为 256 字节。</p>
</li>
<li><p><strong>Flash</strong>：闪存通常按块擦除，相比 EEPROM ，它可以支持更大的存储容量（如 U 盘使用的 NAND Flash），且具有较低的成本。</p>
<ul>
<li><p><strong>NOR Flash</strong>：数据线和地址线分开，支持随机寻址，适用于代码存储。</p>
</li>
<li><p><strong>NAND Flash</strong>：数据线和地址线复用，不能随机寻址，但擦除和写入速度较快，成本较低，适用于大容量存储（U盘）。</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="3-AT24C02"><a href="#3-AT24C02" class="headerlink" title="3. AT24C02"></a>3. AT24C02</h3><blockquote>
<p>AT24C02 是一个小容量的 EEPROM ，容量为 256 字节（2Kbits），每个字节都有唯一的地址。支持按字节或按页写入，能够在掉电后保存数据。使用 IIC 协议与主机通信，可以通过控制信号进行数据的读写操作。它支持多字节读取和写入，具有较高的可靠性，但容量有限，适用于小容量存储应用。</p>
</blockquote>
<h4 id="1-写数据"><a href="#1-写数据" class="headerlink" title="1.写数据"></a>1.写数据</h4><blockquote>
<h6 id="写入一个字节："><a href="#写入一个字节：" class="headerlink" title="写入一个字节："></a>写入一个字节：</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412151225078.png" alt="image-20241215122519962"></p>
<ul>
<li><strong>起始信号</strong>：主机发送起始信号。</li>
<li><strong>设备地址和写控制位</strong>：主机发送24C02的地址及写控制位。</li>
<li><strong>数据地址</strong>：主机指定要写入数据的地址（0-255）。</li>
<li><strong>数据</strong>：主机发送要写入的数据字节。</li>
<li><strong>应答信号</strong>：24C02返回应答信号（ACK）。</li>
<li><strong>停止信号</strong>：主机发送停止信号。</li>
</ul>
<h6 id="按页写："><a href="#按页写：" class="headerlink" title="按页写："></a>按页写：</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412151226127.png" alt="image-20241215122659056"></p>
<ul>
<li>每个页包含 8 个字节，24C02 总共有 32 页（ 256 字节 ÷ 8 字节 / 页）。</li>
<li>可以选择从任意字节地址开始写入（例如从地址 1 开始），但每页的最大写入字节数为 8 个。如果超过 8 个字节，会跨页，需重新发送写信号。</li>
</ul>
</blockquote>
<h4 id="2-读数据"><a href="#2-读数据" class="headerlink" title="2.读数据"></a>2.读数据</h4><blockquote>
<h6 id="单字节读取："><a href="#单字节读取：" class="headerlink" title="单字节读取："></a>单字节读取：</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412151316197.png" alt="image-20241215131603127"></p>
<ul>
<li>主机发送设备地址和写控制位，指定要读取的起始地址（假写）。</li>
<li>主机发送起始信号后，再次发送设备地址和读控制位，24C02返回指定地址的数据。</li>
<li>主机发送非应答信号，并发送停止信号。</li>
</ul>
<h6 id="多字节读取："><a href="#多字节读取：" class="headerlink" title="多字节读取："></a>多字节读取：</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412151316341.png" alt="image-20241215131617281"></p>
<p>​    主机只需发送起始地址，24C02内部有地址计数器，可以连续返回后续地址数据，直到主机发送非应答信号。</p>
<h6 id="时序延时注意："><a href="#时序延时注意：" class="headerlink" title="时序延时注意："></a>时序延时注意：</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412151324403.png" alt="image-20241215132401331"></p>
</blockquote>
<h3 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4.代码实现"></a>4.代码实现</h3><h4 id="1-软件IIC"><a href="#1-软件IIC" class="headerlink" title="1.软件IIC"></a>1.软件IIC</h4><h5 id="1-软件模拟IIC"><a href="#1-软件模拟IIC" class="headerlink" title="1.软件模拟IIC"></a>1.软件模拟IIC</h5><blockquote>
<h6 id="延时时间："><a href="#延时时间：" class="headerlink" title="延时时间："></a>延时时间：</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202502161324651.png" alt="微信截图_20250216131831"></p>
</blockquote>
<h6 id="1-起始信号"><a href="#1-起始信号" class="headerlink" title="1.起始信号"></a>1.起始信号</h6><blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412151324633.png" alt="image-20241215132434566"></p>
</blockquote>
<h6 id="2-停止信号"><a href="#2-停止信号" class="headerlink" title="2.停止信号"></a>2.停止信号</h6><blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412151325702.png" alt="image-20241215132539631"></p>
</blockquote>
<h6 id="3-发送字节"><a href="#3-发送字节" class="headerlink" title="3.发送字节"></a>3.发送字节</h6><blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412151326402.png" alt="image-20241215132622333"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412151326453.png" alt="image-20241215132635387"></p>
<p>​    <strong>发送数据时</strong>，主机通过 SDA 线传输8位数据。每位数据的传输时，SDA线由主机控制，<strong>并且在每一位的数据传输后，</strong>SDA 线需要</p>
<p>​    为下一位传输准备好。<strong>当所有数据位（8位）完成后，SDA线会被设置为“高电平”</strong>，这是由上拉电阻来保证的，表示总线已经空</p>
<p>​    闲，可以开始新的数据传输。</p>
</blockquote>
<h6 id="4-读取字节"><a href="#4-读取字节" class="headerlink" title="4.读取字节"></a>4.读取字节</h6><blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412151327329.png" alt="image-20241215132703258"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412151327848.png" alt="image-20241215132722771"></p>
</blockquote>
<h6 id="5-发送应答"><a href="#5-发送应答" class="headerlink" title="5.发送应答"></a>5.发送应答</h6><blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412151328592.png" alt="image-20241215132804524"></p>
<p>​    <strong>发送应答 ACK 后，主机必须手动释放SDA线，不然从机没办法发送数据。</strong></p>
</blockquote>
<h6 id="6-接收应答"><a href="#6-接收应答" class="headerlink" title="6.接收应答"></a>6.接收应答</h6><blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202412151328049.png" alt="image-20241215132809986"></p>
</blockquote>
<h5 id="2-读写实现"><a href="#2-读写实现" class="headerlink" title="2.读写实现"></a>2.读写实现</h5><h6 id="1-EEPROM读"><a href="#1-EEPROM读" class="headerlink" title="1. EEPROM读"></a>1. EEPROM读</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EEPROM_DRV_ADDR			  0xA0		<span class="comment">// 24xx02的设备地址 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EEPROM_PAGE_SIZE		  8			<span class="comment">// 24xx02的页面大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EEPROM_SIZE				  256	    <span class="comment">// 24xx02总容量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EEPROM_I2C_WR			  0		    <span class="comment">// 写控制bit</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EEPROM_I2C_RD	          1		    <span class="comment">// 读控制bit</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">Read_EEPROM_Data</span><span class="params">(<span class="type">uint8_t</span> readAddr, <span class="type">uint8_t</span> *pBuffer, <span class="type">uint16_t</span> numToRead)</span></span><br><span class="line">&#123;	</span><br><span class="line">	<span class="comment">/* 起始位置和读取数据量超过 PPEROM 最大读取地址 或 此时 pBuffer地址并没有数据 */</span></span><br><span class="line">	<span class="keyword">if</span>(readAddr + numToRead &gt; EEPROM_SIZE | pBuffer == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 无法正确操作EEPROM 返回错误 */</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	I2CStart();                       				   <span class="comment">// 发送起始信号</span></span><br><span class="line">	I2CSendByte(EEPROM_DRV_ADDR | EEPROM_I2C_WR);	   <span class="comment">// 发送器件地址和读写模式，1 0 1 0 x x x  R/~W  0xA0</span></span><br><span class="line">	<span class="keyword">if</span>(!I2CWaitAck())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">goto</span> iic_err;</span><br><span class="line">	&#125;</span><br><span class="line">	I2CSendByte(readAddr);</span><br><span class="line">	<span class="keyword">if</span>(!I2CWaitAck())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">goto</span> iic_err;</span><br><span class="line">	&#125;</span><br><span class="line">	I2CStart();                       				   <span class="comment">// 发送起始信号</span></span><br><span class="line">	I2CSendByte(EEPROM_DRV_ADDR | EEPROM_I2C_RD);	   <span class="comment">// 发送器件地址和读写模式，1 0 1 0 x x x  R/~W  0xA0</span></span><br><span class="line">	<span class="keyword">if</span>(!I2CWaitAck())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">goto</span> iic_err;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(numToRead--)</span><br><span class="line">	&#123;</span><br><span class="line">		*pBuffer++ = I2CReadByte();</span><br><span class="line">		<span class="keyword">if</span>(numToRead)</span><br><span class="line">		&#123;</span><br><span class="line">			I2CSendAck();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			I2CSendNack();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	I2CStop(); </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	</span><br><span class="line">iic_err:</span><br><span class="line">	I2CStop(); </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="2-EEPROM写"><a href="#2-EEPROM写" class="headerlink" title="2. EEPROM写"></a>2. EEPROM写</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">Write_EEPROM_Data</span><span class="params">(<span class="type">uint8_t</span> writeAddr, <span class="type">uint8_t</span> *pBuffer, <span class="type">uint16_t</span> numToWrite)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 起始位置和读取数据量超过 PPEROM 最大读取地址 或 此时 pBuffer地址并没有数据 */</span></span><br><span class="line">	<span class="keyword">if</span>(writeAddr + numToWrite &gt; EEPROM_SIZE | pBuffer == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 无法正确操作EEPROM 返回错误 */</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">	I2CStart();                       				   <span class="comment">// 发送起始信号</span></span><br><span class="line">    </span><br><span class="line">	I2CSendByte(EEPROM_DRV_ADDR | EEPROM_I2C_WR);	   <span class="comment">// 发送器件地址和读写模式，1 0 1 0 x x x  R/~W  0xA0</span></span><br><span class="line">	<span class="keyword">if</span>(!I2CWaitAck())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">goto</span> iic_err;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	I2CSendByte(writeAddr);</span><br><span class="line">	<span class="keyword">if</span>(!I2CWaitAck())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">goto</span> iic_err;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 发送数据 */</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">uint8_t</span> i = <span class="number">0</span>; i &lt; numToWrite; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		I2CSendByte(pBuffer[i]);</span><br><span class="line">		<span class="keyword">if</span>(!I2CWaitAck())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">goto</span> iic_err;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	I2CStop(); </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;	</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">iic_err:</span><br><span class="line">	I2CStop(); </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="3-EEPROM-收发数据"><a href="#3-EEPROM-收发数据" class="headerlink" title="3. EEPROM 收发数据"></a>3. EEPROM 收发数据</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE              17</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">EEPROM_Test</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> bufferWrite[BUFFER_SIZE];</span><br><span class="line">    <span class="type">uint8_t</span> bufferRead[BUFFER_SIZE];</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;AT24C02 writing data：\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">uint16_t</span> i = <span class="number">0</span>; i &lt; BUFFER_SIZE; i++)</span><br><span class="line">	&#123; </span><br><span class="line">		bufferWrite[i]= i + <span class="number">1</span>;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;0x%02X &quot;</span>, bufferWrite[i]);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n开始写入\n&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (!Write_EEPROM_Data(<span class="number">0</span>, bufferWrite, BUFFER_SIZE))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;AT24C02写数据故障，请排查！\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	DelayNms(<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;AT24C02 reading...\n&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (!Read_EEPROM_Data(<span class="number">0</span>, bufferRead, BUFFER_SIZE))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;AT24C02读数据故障，请排查！\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">uint16_t</span> i = <span class="number">0</span>; i &lt; BUFFER_SIZE; i++)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">if</span> (bufferRead[i] != bufferWrite[i])&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0x%02X &quot;</span>, bufferRead[i]);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;AT24C02测试故障，请排查！\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0x%02X &quot;</span>, bufferRead[i]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n24C02测试通过！\n&quot;</span>);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="1-3-问题"><a href="#1-3-问题" class="headerlink" title="1.3.问题"></a>1.3.问题</h5><h6 id="1-页写入限制"><a href="#1-页写入限制" class="headerlink" title="1.页写入限制"></a>1.页写入限制</h6><blockquote>
<h6 id="BUFFER-SIZE-越大时，会出现“AT24C02测试故障，请排查”的报错："><a href="#BUFFER-SIZE-越大时，会出现“AT24C02测试故障，请排查”的报错：" class="headerlink" title="BUFFER_SIZE 越大时，会出现“AT24C02测试故障，请排查”的报错："></a><strong>BUFFER_SIZE</strong> 越大时，会出现“AT24C02测试故障，请排查”的报错：</h6><ul>
<li>第一次有可能不是从 EEPROM <strong>每一页的首地址</strong>开始写数据。</li>
<li>尝试写入超过页大小的数据（如 17 字节），导致<strong>数据截断</strong>或<strong>覆盖</strong>，写入失败。需要重新发起。</li>
</ul>
<h6 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h6><p>写入数据前，先判断写入EEPROM的地址是否为页首地址：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">Write_EEPROM_Data</span><span class="params">(<span class="type">uint8_t</span> writeAddr, <span class="type">uint8_t</span> *pBuffer, <span class="type">uint16_t</span> numToWrite)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 起始位置和读取数据量超过 PPEROM 最大读取地址 或 此时 pBuffer地址并没有数据 */</span></span><br><span class="line">	<span class="keyword">if</span>(writeAddr + numToWrite &gt; EEPROM_SIZE | pBuffer == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 无法正确操作EEPROM 返回错误 */</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 发送数据 */</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">uint8_t</span> i = <span class="number">0</span>; i &lt; numToWrite; i++)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">		<span class="comment">/* 判断要写入的页地址是否为页首地址 */</span></span><br><span class="line">		<span class="keyword">if</span>(i == <span class="number">0</span> || (writeAddr &amp; (EEPROM_PAGE_SIZE - <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/* 停止上一次的主从交互，使总线变为高电平状态 */</span></span><br><span class="line">			I2CStop();</span><br><span class="line">			I2CStart();                       				   <span class="comment">// 发送起始信号</span></span><br><span class="line">			I2CSendByte(EEPROM_DRV_ADDR | EEPROM_I2C_WR);	   <span class="comment">// 发送器件地址和读写模式，1 0 1 0 x x x  R/~W  0xA0</span></span><br><span class="line">			<span class="keyword">if</span>(!I2CWaitAck())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">goto</span> iic_err;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			I2CSendByte(writeAddr);</span><br><span class="line">			<span class="keyword">if</span>(!I2CWaitAck())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">goto</span> iic_err;</span><br><span class="line">			&#125;			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">        </span><br><span class="line">		I2CSendByte(pBuffer[i]);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(!I2CWaitAck())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">goto</span> iic_err;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 2</span></span><br><span class="line">		<span class="comment">/* 每成功写入数据，就更新其页地址 */</span></span><br><span class="line">		writeAddr++;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	I2CStop(); </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">iic_err:</span><br><span class="line">	I2CStop(); </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="2-页间隔限制"><a href="#2-页间隔限制" class="headerlink" title="2.页间隔限制"></a>2.页间隔限制</h6><blockquote>
<h6 id="写入数据故障："><a href="#写入数据故障：" class="headerlink" title="写入数据故障："></a>写入数据故障：</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202502172000817.png" alt="微信截图_20250217195839"></p>
<p> ​    原因：写入超过一页时，页与页之间要有间隔。常规延时也可以解决！</p>
<h6 id="解决方法：-1"><a href="#解决方法：-1" class="headerlink" title="解决方法："></a>解决方法：</h6><p>​    单片机向 EEPROM 发送寻址的命令，检测 EEPROM 是否发来应答信号：    </p>
<p>​    返回 ACK ：说明本次页写入完成。可以进行下一次页写入！！</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/QChilli/Picture/202502172018372.png" alt="微信截图_20250217201748"></p>
<p>​    <strong>页间隔使 j 循环 7 次！</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">Write_EEPROM_Data</span><span class="params">(<span class="type">uint8_t</span> writeAddr, <span class="type">uint8_t</span> *pBuffer, <span class="type">uint16_t</span> numToWrite)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/* 起始位置和读取数据量超过 PPEROM 最大读取地址 或 此时 pBuffer地址并没有数据 */</span></span><br><span class="line">	<span class="keyword">if</span>(writeAddr + numToWrite &gt; EEPROM_SIZE | pBuffer == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 无法正确操作EEPROM 返回错误 */</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 3 尽量不改变传入的形参</span></span><br><span class="line">	<span class="type">uint16_t</span> i, j;</span><br><span class="line">	<span class="type">uint8_t</span> dataAddr = writeAddr;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* 发送数据 */</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; numToWrite; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/* 判断要写入的页地址是否为页首地址  第 1 次 || 第 N 次 */</span></span><br><span class="line">		<span class="keyword">if</span>(i == <span class="number">0</span> || (dataAddr &amp; (EEPROM_PAGE_SIZE - <span class="number">1</span>)) == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">/* 使总线变为高电平状态 */</span></span><br><span class="line">			I2CStop();</span><br><span class="line">            <span class="comment">// 3</span></span><br><span class="line">			<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				I2CStart();                       				   <span class="comment">// 发送起始信号</span></span><br><span class="line">				I2CSendByte(EEPROM_DRV_ADDR | EEPROM_I2C_WR);	   <span class="comment">// 发送器件地址和读写模式，1 0 1 0 x x x  R/~W  0xA0					// 如果应答，说明可以进行下一页写入 第一次写入直接应答，之后要消耗一定时间</span></span><br><span class="line">				<span class="keyword">if</span>(I2CWaitAck())								   </span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">// 3</span></span><br><span class="line">			<span class="comment">/* EEPROM不处于空闲状态 */</span></span><br><span class="line">			<span class="keyword">if</span>(j == <span class="number">100</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">goto</span> iic_err;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 3</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;dataAddr = %d, j = %d\n&quot;</span>, dataAddr, j);</span><br><span class="line">			</span><br><span class="line">			I2CSendByte(dataAddr);</span><br><span class="line">			<span class="keyword">if</span>(!I2CWaitAck())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">goto</span> iic_err;</span><br><span class="line">			&#125;			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		I2CSendByte(pBuffer[i]);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span>(!I2CWaitAck())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">goto</span> iic_err;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 3</span></span><br><span class="line">		<span class="comment">/* 每成功写入数据，就判断其 */</span></span><br><span class="line">		dataAddr++;</span><br><span class="line">	&#125;</span><br><span class="line">	I2CStop(); </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">iic_err:</span><br><span class="line">	I2CStop(); </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-硬件IIC"><a href="#2-硬件IIC" class="headerlink" title="2.硬件IIC"></a>2.硬件IIC</h4></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://qchilli.github.io">Chilli</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://qchilli.github.io/2024/11/29/%E5%B5%8C%E5%85%A5%E5%BC%8F/GD32/">https://qchilli.github.io/2024/11/29/%E5%B5%8C%E5%85%A5%E5%BC%8F/GD32/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://qchilli.github.io" target="_blank">Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://source.fomal.cc/img/default_cover_47.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/10/27/RTT/RTT%E9%97%AE%E9%A2%98%E5%90%88%E9%9B%86/" title=""><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_50.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info"></div></div></a></div><div class="next-post pull-right"><a href="/2024/12/01/%E7%9F%A5%E8%AF%86%E7%82%B9/%E7%9F%A5%E8%AF%86%E7%82%B9/" title=""><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_32.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info"></div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Chilli</div><div class="author-info__description">成长</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" href="https://qchilli.github.io/"><i class="fab fa-github"></i><span>🛴前往小家...</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xxxxx" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#GPIO"><span class="toc-text">GPIO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-text">1.硬件结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">1.工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3"><span class="toc-text">2.概念理解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%BE%93%E5%87%BA%E6%A8%A1%E5%BC%8F"><span class="toc-text">2.输出模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%84"><span class="toc-text">1.输出结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%8E%A8%E6%8C%BD%E8%BE%93%E5%87%BA"><span class="toc-text">1.推挽输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%BC%80%E6%BC%8F%E8%BE%93%E5%87%BA"><span class="toc-text">2.开漏输出</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%BC%80%E6%BC%8F%E8%BE%93%E5%87%BA%E4%BC%98%E7%82%B9"><span class="toc-text">1.开漏输出优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E7%BA%BF%E4%B8%8E%E5%8A%9F%E8%83%BD"><span class="toc-text">2.线与功能</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D"><span class="toc-text">3.地址分配</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%BE%93%E5%85%A5%E6%A8%A1%E5%BC%8F"><span class="toc-text">3.输入模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%A1%AC%E4%BB%B6%E6%A1%86%E6%9E%B6"><span class="toc-text">1.硬件框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%BE%93%E5%85%A5%E7%BB%93%E6%9E%84"><span class="toc-text">2.输入结构</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E-ARM-Cortex-M3-%E5%8D%95%E7%89%87%E6%9C%BA%EF%BC%8C%E5%9C%A8%E8%BD%AC%E6%8D%A2%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%9C%89%E4%BB%A5%E4%B8%8B%E7%89%B9%E6%80%A7%EF%BC%9A"><span class="toc-text">对于 ARM Cortex-M3 单片机，在转换过程中有以下特性：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%B5%AE%E7%A9%BA%E8%BE%93%E5%85%A5"><span class="toc-text">1.浮空输入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%8A%E6%8B%89%E8%BE%93%E5%85%A5"><span class="toc-text">2.上拉输入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%B8%8B%E6%8B%89%E8%BE%93%E5%85%A5"><span class="toc-text">3.下拉输入</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%BE%93%E5%87%BA%E9%80%9F%E5%BA%A6"><span class="toc-text">4.输出速度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%BE%93%E5%87%BA%E9%80%9F%E5%BA%A6%E5%AE%9A%E4%B9%89"><span class="toc-text">1.输出速度定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%BE%93%E5%87%BA%E9%80%9F%E5%BA%A6%E5%BD%B1%E5%93%8D"><span class="toc-text">2.输出速度影响</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CLOCKTREE"><span class="toc-text">CLOCKTREE</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%8D%95%E7%89%87%E6%9C%BA%E6%9E%B6%E6%9E%84"><span class="toc-text">1.单片机架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-51-%E5%8D%95%E7%89%87%E6%9C%BA"><span class="toc-text">1. 51 单片机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-32-%E5%8D%95%E7%89%87%E6%9C%BA"><span class="toc-text">2. 32 单片机</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-text">1.架构设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A4%96%E8%AE%BE%E5%88%86%E5%B8%83"><span class="toc-text">2.外设分布</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%97%B6%E9%92%9F%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84"><span class="toc-text">2.时钟系统架构</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%97%B6%E9%92%9F%E6%A0%91%E7%AE%80%E6%98%93%E6%A1%86%E5%9B%BE%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-text">时钟树简易框图如下：</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%97%B6%E9%92%9F%E7%B3%BB%E7%BB%9F%E5%88%86%E5%B8%83"><span class="toc-text">3.时钟系统分布</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%86%85%E6%A0%B8-DWT-%E5%BB%B6%E6%97%B6"><span class="toc-text">4.内核 DWT 延时</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BB%B6%E6%97%B6%E5%8E%9F%E7%90%86"><span class="toc-text">1.延时原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#NVIC"><span class="toc-text">NVIC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F"><span class="toc-text">1.中断系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3"><span class="toc-text">1.概念理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8D%95%E7%89%87%E6%9C%BA%E4%B8%AD%E6%96%AD%E6%A6%82%E5%BF%B5"><span class="toc-text">2.单片机中断概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%BC%82%E5%B8%B8%E8%A7%A6%E5%8F%91%E6%BA%90"><span class="toc-text">1.异常触发源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%BC%82%E5%B8%B8%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D"><span class="toc-text">2.异常空间分配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%B8%AD%E6%96%AD%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">3.中断执行流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-EXTI-%E4%B8%AD%E6%96%AD"><span class="toc-text">2. EXTI 中断</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%A1%AC%E4%BB%B6%E8%BF%9E%E6%8E%A5%E7%BB%93%E6%9E%84"><span class="toc-text">1.硬件连接结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%AD%E6%96%AD%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">2.中断优先级</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BC%98%E5%85%88%E7%BA%A7%E5%88%86%E7%BB%84"><span class="toc-text">1.优先级分组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-text">2.执行顺序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">3.代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%97%AE%E9%A2%98%E4%B8%80%EF%BC%9A%E6%B2%A1%E6%9C%89%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E5%87%BD%E6%95%B0"><span class="toc-text">1.问题一：没有中断服务函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%97%AE%E9%A2%98%E4%B8%80%EF%BC%9A%E6%9C%89%E4%B8%BB%E5%BE%AA%E7%8E%AF"><span class="toc-text">1.问题一：有主循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%97%AE%E9%A2%98%E4%BA%8C%EF%BC%9A%E6%B2%A1%E6%9C%89%E4%B8%BB%E5%87%BD%E6%95%B0%E5%BE%AA%E7%8E%AF"><span class="toc-text">2.问题二：没有主函数循环</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%97%AE%E9%A2%98%E4%BA%8C%EF%BC%9A%E6%9C%AA%E6%B8%85%E9%99%A4%E6%A0%87%E5%BF%97%E4%BD%8D"><span class="toc-text">2.问题二：未清除标志位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%97%AE%E9%A2%98%E4%B8%89%EF%BC%9A%E4%B8%AD%E6%96%AD%E6%8A%A2%E5%8D%A0%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">3.问题三：中断抢占优先级</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%AA%8C%E8%AF%81%E6%8A%A2%E5%8D%A0%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">1.验证抢占优先级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%AA%8C%E8%AF%81%E5%AD%90%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">2.验证子优先级</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#USART"><span class="toc-text">USART</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">1.基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-text">1.通信方式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E9%80%9A%E4%BF%A1%EF%BC%9A"><span class="toc-text">并行通信：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%B2%E8%A1%8C%E9%80%9A%E4%BF%A1%EF%BC%9A"><span class="toc-text">串行通信：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B8%B8%E8%A7%81%E6%A0%87%E5%87%86"><span class="toc-text">2.常见标准</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E6%8E%A5%E5%8F%A3%EF%BC%9A"><span class="toc-text">通信接口：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6"><span class="toc-text">3.通信机制</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1%EF%BC%9A"><span class="toc-text">同步通信：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1%EF%BC%9A"><span class="toc-text">异步通信：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%8C%E5%B7%A5%E6%A8%A1%E5%BC%8F"><span class="toc-text">双工模式:</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#TTL%EF%BC%9A"><span class="toc-text">TTL：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#RS-232%EF%BC%9A"><span class="toc-text">RS-232：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#RS-485"><span class="toc-text">RS-485:</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%BB%93%E6%9E%84"><span class="toc-text">2.结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84-1"><span class="toc-text">1.硬件结构</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E6%A1%86%E5%9B%BE%EF%BC%9A"><span class="toc-text">结构框图：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%B6%E4%B8%AD%EF%BC%9A"><span class="toc-text">其中：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E5%B8%A7%E7%BB%93%E6%9E%84"><span class="toc-text">2.数据帧结构</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E6%A1%86%E5%9B%BE%EF%BC%9A-1"><span class="toc-text">结构框图：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C%EF%BC%9A"><span class="toc-text">奇偶校验：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BC%82%E6%88%96%E6%A0%A1%E9%AA%8C%EF%BC%9A"><span class="toc-text">异或校验：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%86%97%E4%BD%99%E6%A0%A1%E9%AA%8C%EF%BC%9A"><span class="toc-text">冗余校验：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%9D%BF%E8%BD%BD%E8%AE%BE%E5%A4%87"><span class="toc-text">3.板载设备</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="toc-text">3.代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%B2%E5%8F%A3%E6%99%AE%E9%80%9A%E8%BE%93%E5%87%BA"><span class="toc-text">1.串口普通输出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">1.初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%B8%B2%E5%8F%A3%E8%BD%AF%E4%BB%B6%E4%BF%A1%E6%81%AF%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%9A"><span class="toc-text">1.串口软件信息结构体：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%B8%B2%E5%8F%A3-GPIO-%E9%85%8D%E7%BD%AE%EF%BC%9A"><span class="toc-text">2.串口 GPIO 配置：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%B8%B2%E5%8F%A3%E5%A4%96%E8%AE%BE%E9%85%8D%E7%BD%AE%EF%BC%9A"><span class="toc-text">3.串口外设配置：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%80%BB%E8%BE%91%E7%BC%96%E5%86%99"><span class="toc-text">2.逻辑编写</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%BE%93%E5%87%BA%E6%95%B0%E6%8D%AE%EF%BC%9A"><span class="toc-text">1.输出数据：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-Printf-%E5%8F%91%E9%80%81%EF%BC%9A"><span class="toc-text">2. Printf 发送：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%B2%E5%8F%A3%E4%B8%AD%E6%96%AD%E6%8E%A5%E6%94%B6"><span class="toc-text">2.串口中断接收</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E4%BA%A4%E4%BA%92%E6%95%B0%E6%8D%AE%EF%BC%9A"><span class="toc-text">串口交互数据：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%A4%8D%E6%9D%82%EF%BC%9A"><span class="toc-text">串口接收数据处理复杂：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%9D%E5%A7%8B%E5%8C%96-1"><span class="toc-text">1.初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%B8%B2%E5%8F%A3%E8%BD%AF%E4%BB%B6%E4%BF%A1%E6%81%AF%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%9A-1"><span class="toc-text">1.串口软件信息结构体：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%B8%B2%E5%8F%A3-GPIO-%E9%85%8D%E7%BD%AE%EF%BC%9A-1"><span class="toc-text">2.串口 GPIO 配置：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%B8%B2%E5%8F%A3%E5%A4%96%E8%AE%BE%E9%85%8D%E7%BD%AE%EF%BC%9A-1"><span class="toc-text">3.串口外设配置：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%80%BB%E8%BE%91%E7%BC%96%E5%86%99-1"><span class="toc-text">2.逻辑编写</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E5%87%BD%E6%95%B0"><span class="toc-text">1.中断服务函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90"><span class="toc-text">2.数据解析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%A0%A1%E9%AA%8C%E6%95%B0%E6%8D%AE"><span class="toc-text">3.校验数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E6%8E%A7%E5%88%B6%E9%80%BB%E8%BE%91"><span class="toc-text">4.控制逻辑</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%80%BB%E8%BE%91%E4%BC%98%E5%8C%96"><span class="toc-text">3.逻辑优化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-usb2com-drv-c"><span class="toc-text">1.usb2com_drv.c</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-usb2com-app-c"><span class="toc-text">2.usb2com_app.c</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-main-c"><span class="toc-text">3.main.c</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%8E%AF%E5%BD%A2%E9%98%9F%E5%88%97%E6%94%B6%E5%8F%91"><span class="toc-text">3.环形队列收发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-IDLE-DMA"><span class="toc-text">4. IDLE + DMA</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BA%A7%E7%94%9F%E7%A9%BA%E9%97%B2%E4%B8%AD%E6%96%AD%EF%BC%9A"><span class="toc-text">产生空闲中断：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#DMA-%E8%83%BD%E4%B8%80%E6%AC%A1%E6%80%A7%E5%B0%86%E4%B8%80%E5%8C%85%E6%95%B0%E6%8D%AE%E6%94%BE%E5%85%A5%E5%86%85%E5%AD%98%E4%B8%AD%EF%BC%9A"><span class="toc-text">DMA 能一次性将一包数据放入内存中：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%9D%E5%A7%8B%E5%8C%96-2"><span class="toc-text">1.初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%B8%B2%E5%8F%A3%E8%BD%AF%E4%BB%B6%E4%BF%A1%E6%81%AF%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%9A-2"><span class="toc-text">1.串口软件信息结构体：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%B8%B2%E5%8F%A3%E5%A4%96%E8%AE%BE%E9%85%8D%E7%BD%AE%EF%BC%9A"><span class="toc-text">2.串口外设配置：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%B8%B2%E5%8F%A3-DMA-%E9%85%8D%E7%BD%AE%EF%BC%9A"><span class="toc-text">3.串口 DMA 配置：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%80%BB%E8%BE%91%E7%BC%96%E5%86%99-2"><span class="toc-text">2.逻辑编写</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E5%87%BD%E6%95%B0-1"><span class="toc-text">1.中断服务函数</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%B8%85%E9%99%A4%E7%A9%BA%E9%97%B2%E4%B8%AD%E6%96%AD%E6%A0%87%E5%BF%97%E4%BD%8D%EF%BC%9A"><span class="toc-text">清除空闲中断标志位：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97-DMA-%E6%90%AC%E8%BF%90%E6%95%B0%E6%8D%AE%E9%87%8F%EF%BC%88dma-transfer-number-get%EF%BC%89%EF%BC%9A"><span class="toc-text">计算 DMA 搬运数据量（dma_transfer_number_get）：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%80%9A%E9%81%93-x-%E8%AE%A1%E6%95%B0%E5%AF%84%E5%AD%98%E5%99%A8-DMA-CHxCNT-%EF%BC%9A"><span class="toc-text">通道 x 计数寄存器 (DMA_CHxCNT)：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90-1"><span class="toc-text">2.数据解析</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RTC"><span class="toc-text">RTC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-RTC-amp-BKP"><span class="toc-text">1. RTC &amp; BKP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-RTC"><span class="toc-text">1.RTC</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#RTC-%E7%AE%80%E6%98%93%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84%E6%A1%86%E5%9B%BE%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-text">RTC 简易硬件结构框图如下：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E6%A1%86%E5%9B%BE%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-text">原理框图如下：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E6%A1%86%E5%9B%BE%E5%A6%82%E4%B8%8B%EF%BC%9A-1"><span class="toc-text">原理框图如下：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#RTC%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84%E6%A1%86%E5%9B%BE%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-text">RTC硬件结构框图如下：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-BKP"><span class="toc-text">2.BKP</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#RTC%E7%AE%80%E6%98%93%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84%E6%A1%86%E5%9B%BE%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-text">RTC简易硬件结构框图如下：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BF%A1%E5%8F%B7%E6%A0%A1%E5%87%86"><span class="toc-text">1.信号校准</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E6%A0%A1%E5%87%86%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%9A"><span class="toc-text">信号校准寄存器：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BE%B5%E5%85%A5%E6%A3%80%E6%B5%8B"><span class="toc-text">2.侵入检测</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BE%B5%E5%85%A5%E6%A3%80%E6%B5%8B%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%9A"><span class="toc-text">侵入检测寄存器：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Init-Config"><span class="toc-text">3. Init Config</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="toc-text">2.代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%9D%E5%A7%8B%E5%8C%96-3"><span class="toc-text">1.初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%AE%BE%E7%BD%AE%E6%97%B6%E9%97%B4"><span class="toc-text">2.设置时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%8E%B7%E5%8F%96%E6%97%B6%E9%97%B4"><span class="toc-text">3.获取时间</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ADC"><span class="toc-text">ADC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-1"><span class="toc-text">1.工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%8D%95%E9%80%9A%E9%81%93%E9%87%87%E9%9B%86"><span class="toc-text">2.单通道采集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%A1%AC%E4%BB%B6%E8%BF%9E%E6%8E%A5"><span class="toc-text">1.硬件连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="toc-text">2.代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-ADC-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE"><span class="toc-text">1.ADC 初始化配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%B0%83%E8%AF%95%E4%B8%8E%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3"><span class="toc-text">2.调试与问题解决</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AE%9E%E9%AA%8C%E4%B8%8E%E6%B5%8B%E8%AF%95"><span class="toc-text">3.实验与测试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%A4%9A%E9%80%9A%E9%81%93%E9%87%87%E9%9B%86"><span class="toc-text">3.多通道采集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%A1%AC%E4%BB%B6%E8%BF%9E%E6%8E%A5-1"><span class="toc-text">1.硬件连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-3"><span class="toc-text">2.代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-ADC-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE-1"><span class="toc-text">1.ADC 初始化配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-DMA-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%85%8D%E7%BD%AE"><span class="toc-text">2.DMA 初始化配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%B0%83%E8%AF%95%E4%B8%8E%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3"><span class="toc-text">3.调试与问题解决</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%BB%A4%E6%B3%A2%E5%A4%84%E7%90%86"><span class="toc-text">4.滤波处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%A1%AC%E4%BB%B6%E6%BB%A4%E6%B3%A2"><span class="toc-text">1.硬件滤波</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%BD%AF%E4%BB%B6%E6%BB%A4%E6%B3%A2"><span class="toc-text">2.软件滤波</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="toc-text">3.代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%A1%AC%E4%BB%B6%E6%BB%A4%E6%B3%A2%E4%BB%A3%E7%A0%81"><span class="toc-text">1.硬件滤波代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%BD%AF%E4%BB%B6%E6%BB%A4%E6%B3%A2%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-text">2.软件滤波代码：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%B0%83%E8%AF%95%E4%B8%8E%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3-1"><span class="toc-text">3.调试与问题解决</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-text">5.快速排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="toc-text">1.概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-qsort%E5%87%BD%E6%95%B0"><span class="toc-text">2.qsort函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%8E%92%E5%BA%8F%E6%95%B4%E6%95%B0%E6%95%B0%E7%BB%84"><span class="toc-text">1. 排序整数数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%8E%92%E5%BA%8F%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84"><span class="toc-text">2. 排序结构体数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%AE%B2%E8%A7%A3"><span class="toc-text">代码讲解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%8E%92%E5%BA%8F%E6%95%B4%E6%95%B0%E6%95%B0%E7%BB%84-1"><span class="toc-text">1. 排序整数数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%8E%92%E5%BA%8F%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84-1"><span class="toc-text">2. 排序结构体数组</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-text">6.二分查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0-1"><span class="toc-text">1.概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">2. 应用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-text">2.基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="toc-text">实现细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="toc-text">代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8D%87%E5%BA%8F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-text">1. 升序二分查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%99%8D%E5%BA%8F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-text">2. 降序二分查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8D%87%E5%BA%8F%E6%9F%A5%E6%89%BE%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E5%85%83%E7%B4%A0%E4%B8%8B%E6%A0%87"><span class="toc-text">3. 升序查找最接近目标值的元素下标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%99%8D%E5%BA%8F%E6%9F%A5%E6%89%BE%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E5%85%83%E7%B4%A0%E4%B8%8B%E6%A0%87"><span class="toc-text">4. 降序查找最接近目标值的元素下标</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A1%86%E6%9E%B6"><span class="toc-text">7.传感器框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0"><span class="toc-text">1. 分层架构概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%A9%B1%E5%8A%A8%E5%B1%82%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-text">2. 驱动层的设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-text">3. 数据结构设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%A9%B1%E5%8A%A8%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-text">4. 驱动层实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%BA%94%E7%94%A8%E5%B1%82%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="toc-text">5. 应用层的设计与实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">5.1 任务调度结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6%E5%87%BD%E6%95%B0"><span class="toc-text">5.2 任务处理与调度函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E7%83%AD%E6%95%8F%E7%94%B5%E9%98%BB"><span class="toc-text">8.热敏电阻</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AE%80%E4%BB%8B"><span class="toc-text">1. 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-2"><span class="toc-text">1. 工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1"><span class="toc-text">2.1 电路设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E6%B8%A9%E5%BA%A6%E4%B8%8E%E9%98%BB%E5%80%BC%E5%85%B3%E7%B3%BB"><span class="toc-text">2.2 温度与阻值关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%94%B5%E5%8E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">2. 电压转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E5%88%86%E5%8E%8B%E5%85%AC%E5%BC%8F"><span class="toc-text">3.1 分压公式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E7%A4%BA%E4%BE%8B%E8%AE%A1%E7%AE%97"><span class="toc-text">3.2 示例计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%B8%A9%E5%BA%A6%E8%AE%A1%E7%AE%97"><span class="toc-text">3. 温度计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84"><span class="toc-text">4.1 直接映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E7%B2%BE%E5%BA%A6%E6%8F%90%E5%8D%87"><span class="toc-text">4.2 精度提升</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-4"><span class="toc-text">2. 代码实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E6%B9%BF%E6%95%8F%E7%94%B5%E9%98%BB"><span class="toc-text">9.湿敏电阻</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AE%80%E4%BB%8B-1"><span class="toc-text">1. 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%9B%B8%E5%AF%B9%E6%B9%BF%E5%BA%A6%E4%B8%8E%E7%BB%9D%E5%AF%B9%E6%B9%BF%E5%BA%A6"><span class="toc-text">1. 相对湿度与绝对湿度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%A9%B1%E5%8A%A8%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1"><span class="toc-text">2. 驱动电路设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%A9%B1%E5%8A%A8%E7%94%B5%E8%B7%AF%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">3. 驱动电路工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%9A%E6%A0%B9%E6%8D%AE%E6%B8%A9%E5%BA%A6%E8%8E%B7%E5%8F%96%E5%AF%B9%E5%BA%94%E6%B9%BF%E5%BA%A6%E7%9A%84ADC%E6%95%B0%E5%80%BC"><span class="toc-text">1：根据温度获取对应湿度的ADC数值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%9A%E6%A0%B9%E6%8D%AEADC%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97%E6%B9%BF%E5%BA%A6"><span class="toc-text">2：根据ADC数值计算湿度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-5"><span class="toc-text">2.代码实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RS485"><span class="toc-text">RS485</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D"><span class="toc-text">1.协议介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE%E6%A1%86%E5%9B%BE%EF%BC%9A"><span class="toc-text">协议框图：</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF%E6%96%B9%E6%A1%88"><span class="toc-text">2.硬件电路方案</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%B8%B8%E8%A7%84%E6%96%B9%E6%A1%88"><span class="toc-text">常规方案:</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%87%AA%E6%94%B6%E5%8F%91%E7%94%B5%E8%B7%AF"><span class="toc-text">自收发电路:</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-text">具体实现方式如下：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%87%AA%E6%94%B6%E5%8F%91%E7%94%B5%E8%B7%AF%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-text">自收发电路的工作原理：</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MODBUS"><span class="toc-text">MODBUS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D-1"><span class="toc-text">1.协议介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-RS485-amp-MODBUS"><span class="toc-text">1. RS485 &amp; MODBUS</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E6%A1%86%E5%9B%BE%EF%BC%9A"><span class="toc-text">关系框图：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%89%B9%E7%82%B9"><span class="toc-text">2.特点</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%BC%80%E6%94%BE%E6%80%A7%EF%BC%9A"><span class="toc-text">标准开放性：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE%E6%A0%BC%E5%BC%8F%E4%B8%8E%E5%85%BC%E5%AE%B9%E6%80%A7%EF%BC%9A"><span class="toc-text">协议格式与兼容性：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E4%BB%8B%E8%B4%A8%E4%B8%8E%E6%8A%A5%E6%96%87%E7%B1%BB%E5%9E%8B%EF%BC%9A"><span class="toc-text">传输介质与报文类型：</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F"><span class="toc-text">2.报文格式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8A%A5%E6%96%87%E4%BB%8B%E7%BB%8D%EF%BC%9A"><span class="toc-text">报文介绍：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#MODBUS-RTU-%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F%EF%BC%9A"><span class="toc-text">MODBUS-RTU 报文格式：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E7%A0%81%EF%BC%9A"><span class="toc-text">功能码：</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="toc-text">3.数据格式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%EF%BC%9A"><span class="toc-text">异常处理：</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84"><span class="toc-text">4.软件架构</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%87%87%E7%94%A8%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84%EF%BC%8C%E4%BB%A3%E7%A0%81%E6%B8%85%E6%99%B0%EF%BC%9A"><span class="toc-text">采用分层架构，代码清晰：</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IIC"><span class="toc-text">IIC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%8D%8F%E8%AE%AE%E8%A7%A3%E8%AF%BB"><span class="toc-text">1.协议解读</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%B2%E5%B9%B6%E8%A1%8C%E9%80%9A%E4%BF%A1"><span class="toc-text">1.串并行通信</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%B2%E8%A1%8C%E9%80%9A%E4%BF%A1%E4%B8%8E%E5%B9%B6%E8%A1%8C%E9%80%9A%E4%BF%A1%E7%AE%80%E6%98%93%E6%A1%86%E5%9B%BE%EF%BC%9A"><span class="toc-text">串行通信与并行通信简易框图：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%A1%AC%E4%BB%B6%E5%8E%9F%E7%90%86"><span class="toc-text">2.硬件原理</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BC%80%E6%BC%8F%E8%BE%93%E5%87%BA%E5%92%8C%E4%B8%8A%E6%8B%89%E7%94%B5%E9%98%BB%E5%AE%9E%E7%8E%B0%E9%99%90%E6%B5%81%EF%BC%9A"><span class="toc-text">开漏输出和上拉电阻实现限流：</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="toc-text">2.数据格式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%EF%BC%9A"><span class="toc-text">数据格式：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%90%91%E4%BB%8E%E6%9C%BA%E5%86%99%E6%95%B0%E6%8D%AE%EF%BC%9A"><span class="toc-text">向从机写数据：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%90%91%E4%BB%8E%E6%9C%BA%E8%AF%BB%E6%95%B0%E6%8D%AE%EF%BC%9A"><span class="toc-text">向从机读数据：</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%97%B6%E9%92%9F%E9%A2%91%E7%8E%87%E4%B8%8E%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93"><span class="toc-text">3.时钟频率与数据传输</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%B5%B7%E5%A7%8B%E3%80%81%E5%81%9C%E6%AD%A2%E4%BF%A1%E5%8F%B7"><span class="toc-text">1.起始、停止信号</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E7%8A%B6%E6%80%81%E6%97%B6%EF%BC%8CSDA-%E5%92%8C-SCL-%E4%BF%A1%E5%8F%B7%E7%BA%BF%E9%83%BD%E4%BF%9D%E6%8C%81%E9%AB%98%E7%94%B5%E5%B9%B3%EF%BC%9A"><span class="toc-text">空闲状态时，SDA 和 SCL 信号线都保持高电平：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8F%91%E9%80%81%E5%AD%97%E8%8A%82"><span class="toc-text">2.发送字节</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%AB%98%E7%94%B5%E5%B9%B3%EF%BC%88%E7%A8%B3%E5%AE%9A%E7%8A%B6%E6%80%81%EF%BC%89%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%BD%8E%E7%94%B5%E5%B9%B3%E5%87%86%E5%A4%87%E6%95%B0%E6%8D%AE%EF%BC%9A"><span class="toc-text">高电平（稳定状态）读取数据，低电平准备数据：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%AF%BB%E5%8F%96%E5%AD%97%E8%8A%82"><span class="toc-text">3.读取字节</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E6%97%B6%EF%BC%8C%E4%B8%8D%E8%AE%BA%E4%B8%BB%E6%9C%BA%E8%BF%98%E6%98%AF%E4%BB%8E%E6%9C%BA%EF%BC%8C%E4%B8%BB%E6%9C%BA%E5%BF%85%E9%A1%BB%E5%85%88%E9%87%8A%E6%94%BE-SDA-%E7%BA%BF%EF%BC%9A"><span class="toc-text">读取数据时，不论主机还是从机，主机必须先释放 SDA 线：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%8F%91%E9%80%81%E5%BA%94%E7%AD%94"><span class="toc-text">4.发送应答</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%BB%E6%9C%BA%E5%92%8C%E4%BB%8E%E6%9C%BA%E9%83%BD%E5%8F%AF%E4%BB%A5%E5%8F%91%E9%80%81%E5%BA%94%E7%AD%94%E4%BF%A1%E5%8F%B7%EF%BC%88ACK%EF%BC%89%E3%80%82%E4%BD%8E%E7%94%B5%E5%B9%B3%E5%BA%94%E7%AD%94%EF%BC%8C%E9%AB%98%E7%94%B5%E5%B9%B3%EF%BC%88%E5%88%9D%E6%80%81%EF%BC%89%E9%9D%9E%E5%BA%94%E7%AD%94%EF%BC%9A"><span class="toc-text">主机和从机都可以发送应答信号（ACK）。低电平应答，高电平（初态）非应答：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%8E%A5%E6%94%B6%E5%BA%94%E7%AD%94"><span class="toc-text">5.接收应答</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%BB%E6%9C%BA%E5%92%8C%E4%BB%8E%E6%9C%BA%E9%83%BD%E6%8E%A5%E6%94%B6%E5%BA%94%E7%AD%94%E4%BF%A1%E5%8F%B7%EF%BC%88ACK%EF%BC%89%EF%BC%9A"><span class="toc-text">主机和从机都接收应答信号（ACK）：</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-EEPROM"><span class="toc-text">4. EEPROM</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E5%88%86%E7%B1%BB%EF%BC%9A"><span class="toc-text">存储器分类：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-ROM%E5%8F%91%E5%B1%95%E5%8E%86%E7%A8%8B"><span class="toc-text">1. ROM发展历程</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#ROM-%E4%BB%8B%E7%BB%8D%EF%BC%9A"><span class="toc-text">ROM 介绍：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-EEPROM-%E4%B8%8E-Flash"><span class="toc-text">2. EEPROM 与 Flash</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Flash-%E4%B8%8E-EEPROM-%E6%AF%94%E8%BE%83%EF%BC%9A"><span class="toc-text">Flash 与 EEPROM 比较：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-AT24C02"><span class="toc-text">3. AT24C02</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%86%99%E6%95%B0%E6%8D%AE"><span class="toc-text">1.写数据</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%86%99%E5%85%A5%E4%B8%80%E4%B8%AA%E5%AD%97%E8%8A%82%EF%BC%9A"><span class="toc-text">写入一个字节：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%8C%89%E9%A1%B5%E5%86%99%EF%BC%9A"><span class="toc-text">按页写：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%AF%BB%E6%95%B0%E6%8D%AE"><span class="toc-text">2.读数据</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8D%95%E5%AD%97%E8%8A%82%E8%AF%BB%E5%8F%96%EF%BC%9A"><span class="toc-text">单字节读取：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%A4%9A%E5%AD%97%E8%8A%82%E8%AF%BB%E5%8F%96%EF%BC%9A"><span class="toc-text">多字节读取：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%97%B6%E5%BA%8F%E5%BB%B6%E6%97%B6%E6%B3%A8%E6%84%8F%EF%BC%9A"><span class="toc-text">时序延时注意：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">4.代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%BD%AF%E4%BB%B6IIC"><span class="toc-text">1.软件IIC</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%BD%AF%E4%BB%B6%E6%A8%A1%E6%8B%9FIIC"><span class="toc-text">1.软件模拟IIC</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%BB%B6%E6%97%B6%E6%97%B6%E9%97%B4%EF%BC%9A"><span class="toc-text">延时时间：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E8%B5%B7%E5%A7%8B%E4%BF%A1%E5%8F%B7"><span class="toc-text">1.起始信号</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E5%81%9C%E6%AD%A2%E4%BF%A1%E5%8F%B7"><span class="toc-text">2.停止信号</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-%E5%8F%91%E9%80%81%E5%AD%97%E8%8A%82"><span class="toc-text">3.发送字节</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#4-%E8%AF%BB%E5%8F%96%E5%AD%97%E8%8A%82"><span class="toc-text">4.读取字节</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#5-%E5%8F%91%E9%80%81%E5%BA%94%E7%AD%94"><span class="toc-text">5.发送应答</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#6-%E6%8E%A5%E6%94%B6%E5%BA%94%E7%AD%94"><span class="toc-text">6.接收应答</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E8%AF%BB%E5%86%99%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.读写实现</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-EEPROM%E8%AF%BB"><span class="toc-text">1. EEPROM读</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-EEPROM%E5%86%99"><span class="toc-text">2. EEPROM写</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-EEPROM-%E6%94%B6%E5%8F%91%E6%95%B0%E6%8D%AE"><span class="toc-text">3. EEPROM 收发数据</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-%E9%97%AE%E9%A2%98"><span class="toc-text">1.3.问题</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E9%A1%B5%E5%86%99%E5%85%A5%E9%99%90%E5%88%B6"><span class="toc-text">1.页写入限制</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#BUFFER-SIZE-%E8%B6%8A%E5%A4%A7%E6%97%B6%EF%BC%8C%E4%BC%9A%E5%87%BA%E7%8E%B0%E2%80%9CAT24C02%E6%B5%8B%E8%AF%95%E6%95%85%E9%9A%9C%EF%BC%8C%E8%AF%B7%E6%8E%92%E6%9F%A5%E2%80%9D%E7%9A%84%E6%8A%A5%E9%94%99%EF%BC%9A"><span class="toc-text">BUFFER_SIZE 越大时，会出现“AT24C02测试故障，请排查”的报错：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-text">解决方法：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E9%A1%B5%E9%97%B4%E9%9A%94%E9%99%90%E5%88%B6"><span class="toc-text">2.页间隔限制</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE%E6%95%85%E9%9A%9C%EF%BC%9A"><span class="toc-text">写入数据故障：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%EF%BC%9A-1"><span class="toc-text">解决方法：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%A1%AC%E4%BB%B6IIC"><span class="toc-text">2.硬件IIC</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://source.fomal.cc/img/default_cover_47.webp')"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By Chilli</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.8/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><script defer src="/js/cursor.js"></script><script defer src="/js/light.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://pic2.zhimg.com/v2-1936698c6f78045e44fee6af083d351d_r.jpg);"> <a class="categoryBar-list-link" href="categories/嵌入式/">嵌入式</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://th.bing.com/th/id/R.f49b332d8e2b663bce9268e95cf7c468?rik=lVJPulpH3IA5tg&amp;riu=http%3a%2f%2fs4.51cto.com%2fwyfs02%2fM00%2f95%2fD4%2fwKioL1kaaAOwBXtNAAOHV522bBE251.jpg-wh_651x-s_1292780587.jpg&amp;ehk=O5gqoUnLVq8ZU8dqp6scdnCBf3mnnwrGKcKr7bVgCdU%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0);"> <a class="categoryBar-list-link" href="categories/数据结构/">数据结构</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://th.bing.com/th/id/R.a2086a6f407dec1bef24adc8e2adfda6?rik=1mLlzM9Z5O1XMg&amp;riu=http%3a%2f%2fgz.gec-edu.org%2fPublic%2fcourse_subject%2fimage%2fembedded%2fdouble.jpg&amp;ehk=Kb2bDZdoPWk8QW2fwi1bkfdR1T41KgDBIzhOnWa%2f9XA%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0&amp;sres=1&amp;sresct=1);"> <a class="categoryBar-list-link" href="categories/知识点/">知识点</a><span class="categoryBar-list-count">4</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://ts1.cn.mm.bing.net/th/id/R-C.06ac7d7e5f4f81229e8c7eaf79bd0fef?rik=6dPa67mO8Xo88g&amp;riu=http%3a%2f%2fwww.faceui.com%2fapps%2fupload%2fimage%2f20200113%2f1578920626569170.jpg&amp;ehk=r2TM6AGvXY%2biZcXlEyyueiblv5fcSgYkC%2f2YJiGP3bE%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0);"> <a class="categoryBar-list-link" href="categories/蓝桥杯/">蓝桥杯</a><span class="categoryBar-list-count">13</span><span class="categoryBar-list-descr"></span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题使用Butterfly" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="https://www.fomal.cc/static/js/runtime.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '1s');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '2');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --></body></html>